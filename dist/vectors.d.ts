// Generated by dts-bundle-generator v9.5.1

export type Theme = "light" | "dark";
/** Type representing an object color, which can be a simple color representation or an object with color and shading information. */
export type ObjectColor = THREE.ColorRepresentation | {
	color?: THREE.ColorRepresentation;
	shaded?: boolean;
};
/** Returns a new THREE.Color instance. */
export declare const color: (value: THREE.ColorRepresentation) => THREE.Color;
declare const REVISION: string;
declare enum MOUSE {
	LEFT = 0,
	MIDDLE = 1,
	RIGHT = 2,
	ROTATE = 0,
	DOLLY = 1,
	PAN = 2
}
declare enum TOUCH {
	ROTATE = 0,
	PAN = 1,
	DOLLY_PAN = 2,
	DOLLY_ROTATE = 3
}
declare const CullFaceNone: 0;
declare const CullFaceBack: 1;
declare const CullFaceFront: 2;
declare const CullFaceFrontBack: 3;
export type CullFace = typeof CullFaceNone | typeof CullFaceBack | typeof CullFaceFront | typeof CullFaceFrontBack;
declare const BasicShadowMap: 0;
declare const PCFShadowMap: 1;
declare const PCFSoftShadowMap: 2;
declare const VSMShadowMap: 3;
export type ShadowMapType = typeof BasicShadowMap | typeof PCFShadowMap | typeof PCFSoftShadowMap | typeof VSMShadowMap;
declare const FrontSide: 0;
declare const BackSide: 1;
declare const DoubleSide: 2;
/**
 * Defines which side of faces will be rendered - front, back or both.
 * Default is {@link FrontSide}.
 */
export type Side = typeof FrontSide | typeof BackSide | typeof DoubleSide;
declare const NoBlending: 0;
declare const NormalBlending: 1;
declare const AdditiveBlending: 2;
declare const SubtractiveBlending: 3;
declare const MultiplyBlending: 4;
declare const CustomBlending: 5;
export type Blending = typeof NoBlending | typeof NormalBlending | typeof AdditiveBlending | typeof SubtractiveBlending | typeof MultiplyBlending | typeof CustomBlending;
declare const AddEquation: 100;
declare const SubtractEquation: 101;
declare const ReverseSubtractEquation: 102;
declare const MinEquation: 103;
declare const MaxEquation: 104;
export type BlendingEquation = typeof AddEquation | typeof SubtractEquation | typeof ReverseSubtractEquation | typeof MinEquation | typeof MaxEquation;
declare const ZeroFactor: 200;
declare const OneFactor: 201;
declare const SrcColorFactor: 202;
declare const OneMinusSrcColorFactor: 203;
declare const SrcAlphaFactor: 204;
declare const OneMinusSrcAlphaFactor: 205;
declare const DstAlphaFactor: 206;
declare const OneMinusDstAlphaFactor: 207;
declare const DstColorFactor: 208;
declare const OneMinusDstColorFactor: 209;
declare const SrcAlphaSaturateFactor: 210;
declare const ConstantColorFactor: 211;
declare const OneMinusConstantColorFactor: 212;
declare const ConstantAlphaFactor: 213;
declare const OneMinusConstantAlphaFactor: 214;
export type BlendingDstFactor = typeof ZeroFactor | typeof OneFactor | typeof SrcColorFactor | typeof OneMinusSrcColorFactor | typeof SrcAlphaFactor | typeof OneMinusSrcAlphaFactor | typeof DstAlphaFactor | typeof OneMinusDstAlphaFactor | typeof DstColorFactor | typeof OneMinusDstColorFactor | typeof ConstantColorFactor | typeof OneMinusConstantColorFactor | typeof ConstantAlphaFactor | typeof OneMinusConstantAlphaFactor;
export type BlendingSrcFactor = BlendingDstFactor | typeof SrcAlphaSaturateFactor;
declare const NeverDepth: 0;
declare const AlwaysDepth: 1;
declare const LessDepth: 2;
declare const LessEqualDepth: 3;
declare const EqualDepth: 4;
declare const GreaterEqualDepth: 5;
declare const GreaterDepth: 6;
declare const NotEqualDepth: 7;
export type DepthModes = typeof NeverDepth | typeof AlwaysDepth | typeof LessDepth | typeof LessEqualDepth | typeof EqualDepth | typeof GreaterEqualDepth | typeof GreaterDepth | typeof NotEqualDepth;
declare const MultiplyOperation: 0;
declare const MixOperation: 1;
declare const AddOperation: 2;
export type Combine = typeof MultiplyOperation | typeof MixOperation | typeof AddOperation;
declare const NoToneMapping: 0;
declare const LinearToneMapping: 1;
declare const ReinhardToneMapping: 2;
declare const CineonToneMapping: 3;
declare const ACESFilmicToneMapping: 4;
declare const CustomToneMapping: 5;
declare const AgXToneMapping: 6;
declare const NeutralToneMapping: 7;
export type ToneMapping = typeof NoToneMapping | typeof LinearToneMapping | typeof ReinhardToneMapping | typeof CineonToneMapping | typeof ACESFilmicToneMapping | typeof CustomToneMapping | typeof AgXToneMapping | typeof NeutralToneMapping;
declare const AttachedBindMode: "attached";
declare const DetachedBindMode: "detached";
export type BindMode = typeof AttachedBindMode | typeof DetachedBindMode;
declare const UVMapping: 300;
declare const CubeReflectionMapping: 301;
declare const CubeRefractionMapping: 302;
declare const CubeUVReflectionMapping: 306;
declare const EquirectangularReflectionMapping: 303;
declare const EquirectangularRefractionMapping: 304;
/**
 * Texture Mapping Modes for non-cube Textures
 * @remarks {@link UVMapping} is the _default_ value and behaver for Texture Mapping.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
export type Mapping = typeof UVMapping | typeof EquirectangularReflectionMapping | typeof EquirectangularRefractionMapping;
/**
 * Texture Mapping Modes for cube Textures
 * @remarks {@link CubeReflectionMapping} is the _default_ value and behaver for Cube Texture Mapping.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
export type CubeTextureMapping = typeof CubeReflectionMapping | typeof CubeRefractionMapping | typeof CubeUVReflectionMapping;
/**
 * Texture Mapping Modes for any type of Textures
 * @see {@link Mapping} and {@link CubeTextureMapping}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
export type AnyMapping = Mapping | CubeTextureMapping;
declare const RepeatWrapping: 1000;
declare const ClampToEdgeWrapping: 1001;
declare const MirroredRepeatWrapping: 1002;
/**
 * Texture Wrapping Modes
 * @remarks {@link ClampToEdgeWrapping} is the _default_ value and behaver for Wrapping Mapping.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
export type Wrapping = typeof RepeatWrapping | typeof ClampToEdgeWrapping | typeof MirroredRepeatWrapping;
declare const NearestFilter: 1003;
declare const NearestMipmapNearestFilter: 1004;
declare const NearestMipMapNearestFilter: 1004;
declare const NearestMipmapLinearFilter: 1005;
declare const NearestMipMapLinearFilter: 1005;
declare const LinearFilter: 1006;
declare const LinearMipmapNearestFilter: 1007;
declare const LinearMipMapNearestFilter: 1007;
declare const LinearMipmapLinearFilter: 1008;
declare const LinearMipMapLinearFilter: 1008;
/**
 * Texture Magnification Filter Modes.
 * For use with a texture's {@link THREE.Texture.magFilter | magFilter} property,
 * these define the texture magnification function to be used when the pixel being textured maps to an area less than or equal to one texture element (texel).
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 * @see {@link https://sbcode.net/threejs/mipmaps/ | Texture Mipmaps (non-official)}
 */
export type MagnificationTextureFilter = typeof NearestFilter | typeof LinearFilter;
/**
 * Texture Minification Filter Modes.
 * For use with a texture's {@link THREE.Texture.minFilter | minFilter} property,
 * these define the texture minifying function that is used whenever the pixel being textured maps to an area greater than one texture element (texel).
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 * @see {@link https://sbcode.net/threejs/mipmaps/ | Texture Mipmaps (non-official)}
 */
export type MinificationTextureFilter = typeof NearestFilter | typeof NearestMipmapNearestFilter | typeof NearestMipMapNearestFilter | typeof NearestMipmapLinearFilter | typeof NearestMipMapLinearFilter | typeof LinearFilter | typeof LinearMipmapNearestFilter | typeof LinearMipMapNearestFilter | typeof LinearMipmapLinearFilter | typeof LinearMipMapLinearFilter;
/**
 * Texture all Magnification and Minification Filter Modes.
 * @see {@link MagnificationTextureFilter} and {@link MinificationTextureFilter}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 * @see {@link https://sbcode.net/threejs/mipmaps/ | Texture Mipmaps (non-official)}
 */
export type TextureFilter = MagnificationTextureFilter | MinificationTextureFilter;
declare const UnsignedByteType: 1009;
declare const ByteType: 1010;
declare const ShortType: 1011;
declare const UnsignedShortType: 1012;
declare const IntType: 1013;
declare const UnsignedIntType: 1014;
declare const FloatType: 1015;
declare const HalfFloatType: 1016;
declare const UnsignedShort4444Type: 1017;
declare const UnsignedShort5551Type: 1018;
declare const UnsignedInt248Type: 1020;
declare const UnsignedInt5999Type: 35902;
declare const UnsignedInt101111Type: 35899;
export type AttributeGPUType = typeof FloatType | typeof IntType;
/**
 * Texture Types.
 * @remarks Must correspond to the correct {@link PixelFormat | format}.
 * @see {@link THREE.Texture.type}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
export type TextureDataType = typeof UnsignedByteType | typeof ByteType | typeof ShortType | typeof UnsignedShortType | typeof IntType | typeof UnsignedIntType | typeof FloatType | typeof HalfFloatType | typeof UnsignedShort4444Type | typeof UnsignedShort5551Type | typeof UnsignedInt248Type | typeof UnsignedInt5999Type | typeof UnsignedInt101111Type;
declare const AlphaFormat: 1021;
declare const RGBFormat: 1022;
declare const RGBAFormat: 1023;
declare const DepthFormat: 1026;
declare const DepthStencilFormat: 1027;
declare const RedFormat: 1028;
declare const RedIntegerFormat: 1029;
declare const RGFormat: 1030;
declare const RGIntegerFormat: 1031;
declare const RGBIntegerFormat: 1032;
declare const RGBAIntegerFormat: 1033;
/**
 * All Texture Pixel Formats Modes.
 * @remarks Note that the texture must have the correct {@link THREE.Texture.type} set, as described in  {@link TextureDataType}.
 * @see {@link WebGLRenderingContext.texImage2D} for details.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
export type PixelFormat = typeof AlphaFormat | typeof RGBFormat | typeof RGBAFormat | typeof DepthFormat | typeof DepthStencilFormat | typeof RedFormat | typeof RedIntegerFormat | typeof RGFormat | typeof RGIntegerFormat | typeof RGBIntegerFormat | typeof RGBAIntegerFormat;
/**
 * All Texture Pixel Formats Modes for {@link THREE.DepthTexture}.
 * @see {@link WebGLRenderingContext.texImage2D} for details.
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
export type DepthTexturePixelFormat = typeof DepthFormat | typeof DepthStencilFormat;
declare const RGB_S3TC_DXT1_Format: 33776;
declare const RGBA_S3TC_DXT1_Format: 33777;
declare const RGBA_S3TC_DXT3_Format: 33778;
declare const RGBA_S3TC_DXT5_Format: 33779;
declare const RGB_PVRTC_4BPPV1_Format: 35840;
declare const RGB_PVRTC_2BPPV1_Format: 35841;
declare const RGBA_PVRTC_4BPPV1_Format: 35842;
declare const RGBA_PVRTC_2BPPV1_Format: 35843;
declare const RGB_ETC1_Format: 36196;
declare const RGB_ETC2_Format: 37492;
declare const RGBA_ETC2_EAC_Format: 37496;
declare const R11_EAC_Format: 37488;
declare const SIGNED_R11_EAC_Format: 37489;
declare const RG11_EAC_Format: 37490;
declare const SIGNED_RG11_EAC_Format: 37491;
declare const RGBA_ASTC_4x4_Format: 37808;
declare const RGBA_ASTC_5x4_Format: 37809;
declare const RGBA_ASTC_5x5_Format: 37810;
declare const RGBA_ASTC_6x5_Format: 37811;
declare const RGBA_ASTC_6x6_Format: 37812;
declare const RGBA_ASTC_8x5_Format: 37813;
declare const RGBA_ASTC_8x6_Format: 37814;
declare const RGBA_ASTC_8x8_Format: 37815;
declare const RGBA_ASTC_10x5_Format: 37816;
declare const RGBA_ASTC_10x6_Format: 37817;
declare const RGBA_ASTC_10x8_Format: 37818;
declare const RGBA_ASTC_10x10_Format: 37819;
declare const RGBA_ASTC_12x10_Format: 37820;
declare const RGBA_ASTC_12x12_Format: 37821;
declare const RGBA_BPTC_Format: 36492;
declare const RGB_BPTC_SIGNED_Format = 36494;
declare const RGB_BPTC_UNSIGNED_Format = 36495;
declare const RED_RGTC1_Format: 36283;
declare const SIGNED_RED_RGTC1_Format: 36284;
declare const RED_GREEN_RGTC2_Format: 36285;
declare const SIGNED_RED_GREEN_RGTC2_Format: 36286;
/**
 * For use with a {@link THREE.CompressedTexture}'s {@link THREE.CompressedTexture.format | .format} property.
 * @remarks Compressed Require support for correct WebGL extension.
 */
export type CompressedPixelFormat = typeof RGB_S3TC_DXT1_Format | typeof RGBA_S3TC_DXT1_Format | typeof RGBA_S3TC_DXT3_Format | typeof RGBA_S3TC_DXT5_Format | typeof RGB_PVRTC_4BPPV1_Format | typeof RGB_PVRTC_2BPPV1_Format | typeof RGBA_PVRTC_4BPPV1_Format | typeof RGBA_PVRTC_2BPPV1_Format | typeof RGB_ETC1_Format | typeof RGB_ETC2_Format | typeof RGBA_ETC2_EAC_Format | typeof R11_EAC_Format | typeof SIGNED_R11_EAC_Format | typeof RG11_EAC_Format | typeof SIGNED_RG11_EAC_Format | typeof RGBA_ASTC_4x4_Format | typeof RGBA_ASTC_5x4_Format | typeof RGBA_ASTC_5x5_Format | typeof RGBA_ASTC_6x5_Format | typeof RGBA_ASTC_6x6_Format | typeof RGBA_ASTC_8x5_Format | typeof RGBA_ASTC_8x6_Format | typeof RGBA_ASTC_8x8_Format | typeof RGBA_ASTC_10x5_Format | typeof RGBA_ASTC_10x6_Format | typeof RGBA_ASTC_10x8_Format | typeof RGBA_ASTC_10x10_Format | typeof RGBA_ASTC_12x10_Format | typeof RGBA_ASTC_12x12_Format | typeof RGBA_BPTC_Format | typeof RGB_BPTC_SIGNED_Format | typeof RGB_BPTC_UNSIGNED_Format | typeof RED_RGTC1_Format | typeof SIGNED_RED_RGTC1_Format | typeof RED_GREEN_RGTC2_Format | typeof SIGNED_RED_GREEN_RGTC2_Format;
///////////////////////////////////////////////////////////////////////////////
/**
 * All Possible Texture Pixel Formats Modes. For any Type or SubType of Textures.
 * @remarks Note that the texture must have the correct {@link THREE.Texture.type} set, as described in {@link TextureDataType}.
 * @see {@link WebGLRenderingContext.texImage2D} for details.
 * @see {@link PixelFormat} and {@link DepthTexturePixelFormat} and {@link CompressedPixelFormat}
 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
 */
export type AnyPixelFormat = PixelFormat | DepthTexturePixelFormat | CompressedPixelFormat;
declare const LoopOnce: 2200;
declare const LoopRepeat: 2201;
declare const LoopPingPong: 2202;
export type AnimationActionLoopStyles = typeof LoopOnce | typeof LoopRepeat | typeof LoopPingPong;
declare const InterpolateDiscrete: 2300;
declare const InterpolateLinear: 2301;
declare const InterpolateSmooth: 2302;
export type InterpolationModes = typeof InterpolateDiscrete | typeof InterpolateLinear | typeof InterpolateSmooth;
declare const ZeroCurvatureEnding: 2400;
declare const ZeroSlopeEnding: 2401;
declare const WrapAroundEnding: 2402;
export type InterpolationEndingModes = typeof ZeroCurvatureEnding | typeof ZeroSlopeEnding | typeof WrapAroundEnding;
declare const NormalAnimationBlendMode: 2500;
declare const AdditiveAnimationBlendMode: 2501;
export type AnimationBlendMode = typeof NormalAnimationBlendMode | typeof AdditiveAnimationBlendMode;
declare const TrianglesDrawMode: 0;
declare const TriangleStripDrawMode: 1;
declare const TriangleFanDrawMode: 2;
export type TrianglesDrawModes = typeof TrianglesDrawMode | typeof TriangleStripDrawMode | typeof TriangleFanDrawMode;
declare const BasicDepthPacking: 3200;
declare const RGBADepthPacking: 3201;
declare const RGBDepthPacking: 3202;
declare const RGDepthPacking: 3203;
export type DepthPackingStrategies = typeof BasicDepthPacking | typeof RGBADepthPacking | typeof RGBDepthPacking | typeof RGDepthPacking;
declare const TangentSpaceNormalMap: 0;
declare const ObjectSpaceNormalMap: 1;
export type NormalMapTypes = typeof TangentSpaceNormalMap | typeof ObjectSpaceNormalMap;
declare const NoColorSpace: "";
declare const SRGBColorSpace: "srgb";
declare const LinearSRGBColorSpace: "srgb-linear";
export type ColorSpace = typeof NoColorSpace | typeof SRGBColorSpace | typeof LinearSRGBColorSpace;
declare const LinearTransfer: "linear";
declare const SRGBTransfer: "srgb";
export type ColorSpaceTransfer = typeof LinearTransfer | typeof SRGBTransfer;
declare const NoNormalPacking: "";
declare const NormalRGPacking: "rg";
declare const NormalGAPacking: "ga";
export type NormalPacking = typeof NoNormalPacking | typeof NormalRGPacking | typeof NormalGAPacking;
declare const ZeroStencilOp: 0;
declare const KeepStencilOp: 7680;
declare const ReplaceStencilOp: 7681;
declare const IncrementStencilOp: 7682;
declare const DecrementStencilOp: 7283;
declare const IncrementWrapStencilOp: 34055;
declare const DecrementWrapStencilOp: 34056;
declare const InvertStencilOp: 5386;
export type StencilOp = typeof ZeroStencilOp | typeof KeepStencilOp | typeof ReplaceStencilOp | typeof IncrementStencilOp | typeof DecrementStencilOp | typeof IncrementWrapStencilOp | typeof DecrementWrapStencilOp | typeof InvertStencilOp;
declare const NeverStencilFunc: 512;
declare const LessStencilFunc: 513;
declare const EqualStencilFunc: 514;
declare const LessEqualStencilFunc: 515;
declare const GreaterStencilFunc: 516;
declare const NotEqualStencilFunc: 517;
declare const GreaterEqualStencilFunc: 518;
declare const AlwaysStencilFunc: 519;
export type StencilFunc = typeof NeverStencilFunc | typeof LessStencilFunc | typeof EqualStencilFunc | typeof LessEqualStencilFunc | typeof GreaterStencilFunc | typeof NotEqualStencilFunc | typeof GreaterEqualStencilFunc | typeof AlwaysStencilFunc;
declare const NeverCompare: 512;
declare const LessCompare: 513;
declare const EqualCompare: 514;
declare const LessEqualCompare: 515;
declare const GreaterCompare: 516;
declare const NotEqualCompare: 517;
declare const GreaterEqualCompare: 518;
declare const AlwaysCompare: 519;
export type TextureComparisonFunction = typeof NeverCompare | typeof LessCompare | typeof EqualCompare | typeof LessEqualCompare | typeof GreaterCompare | typeof NotEqualCompare | typeof GreaterEqualCompare | typeof AlwaysCompare;
declare const StaticDrawUsage: 35044;
declare const DynamicDrawUsage: 35048;
declare const StreamDrawUsage: 35040;
declare const StaticReadUsage: 35045;
declare const DynamicReadUsage: 35049;
declare const StreamReadUsage: 35041;
declare const StaticCopyUsage: 35046;
declare const DynamicCopyUsage: 35050;
declare const StreamCopyUsage: 35042;
export type Usage = typeof StaticDrawUsage | typeof DynamicDrawUsage | typeof StreamDrawUsage | typeof StaticReadUsage | typeof DynamicReadUsage | typeof StreamReadUsage | typeof StaticCopyUsage | typeof DynamicCopyUsage | typeof StreamCopyUsage;
declare const GLSL1: "100";
declare const GLSL3: "300 es";
export type GLSLVersion = typeof GLSL1 | typeof GLSL3;
declare const WebGLCoordinateSystem: 2000;
declare const WebGPUCoordinateSystem: 2001;
export type CoordinateSystem = typeof WebGLCoordinateSystem | typeof WebGPUCoordinateSystem;
declare const TimestampQuery: {
	COMPUTE: "compute";
	RENDER: "render";
};
export type TimestampQuery = typeof TimestampQuery.COMPUTE | typeof TimestampQuery.RENDER;
declare const InterpolationSamplingType: {
	PERSPECTIVE: "perspective";
	LINEAR: "linear";
	FLAT: "flat";
};
export type InterpolationSamplingType = typeof InterpolationSamplingType.PERSPECTIVE | typeof InterpolationSamplingType.LINEAR | typeof InterpolationSamplingType.FLAT;
declare const InterpolationSamplingMode: {
	NORMAL: "normal";
	CENTROID: "centroid";
	SAMPLE: "sample";
	FIRST: "first";
	EITHER: "either";
};
export type InterpolationSamplingMode = typeof InterpolationSamplingMode.NORMAL | typeof InterpolationSamplingMode.CENTROID | typeof InterpolationSamplingMode.SAMPLE | typeof InterpolationSamplingMode.FIRST | typeof InterpolationSamplingMode.EITHER;
///////////////////////////////////////////////////////////////////////////////
// Texture - Internal Pixel Formats
/**
 * For use with a texture's {@link THREE.Texture.internalFormat} property, these define how elements of a {@link THREE.Texture}, or texels, are stored on the GPU.
 * - `R8` stores the red component on 8 bits.
 * - `R8_SNORM` stores the red component on 8 bits. The component is stored as normalized.
 * - `R8I` stores the red component on 8 bits. The component is stored as an integer.
 * - `R8UI` stores the red component on 8 bits. The component is stored as an unsigned integer.
 * - `R16I` stores the red component on 16 bits. The component is stored as an integer.
 * - `R16UI` stores the red component on 16 bits. The component is stored as an unsigned integer.
 * - `R16F` stores the red component on 16 bits. The component is stored as floating point.
 * - `R32I` stores the red component on 32 bits. The component is stored as an integer.
 * - `R32UI` stores the red component on 32 bits. The component is stored as an unsigned integer.
 * - `R32F` stores the red component on 32 bits. The component is stored as floating point.
 * - `RG8` stores the red and green components on 8 bits each.
 * - `RG8_SNORM` stores the red and green components on 8 bits each. Every component is stored as normalized.
 * - `RG8I` stores the red and green components on 8 bits each. Every component is stored as an integer.
 * - `RG8UI` stores the red and green components on 8 bits each. Every component is stored as an unsigned integer.
 * - `RG16I` stores the red and green components on 16 bits each. Every component is stored as an integer.
 * - `RG16UI` stores the red and green components on 16 bits each. Every component is stored as an unsigned integer.
 * - `RG16F` stores the red and green components on 16 bits each. Every component is stored as floating point.
 * - `RG32I` stores the red and green components on 32 bits each. Every component is stored as an integer.
 * - `RG32UI` stores the red and green components on 32 bits. Every component is stored as an unsigned integer.
 * - `RG32F` stores the red and green components on 32 bits. Every component is stored as floating point.
 * - `RGB8` stores the red, green, and blue components on 8 bits each. RGB8_SNORM` stores the red, green, and blue components on 8 bits each. Every component is stored as normalized.
 * - `RGB8I` stores the red, green, and blue components on 8 bits each. Every component is stored as an integer.
 * - `RGB8UI` stores the red, green, and blue components on 8 bits each. Every component is stored as an unsigned integer.
 * - `RGB16I` stores the red, green, and blue components on 16 bits each. Every component is stored as an integer.
 * - `RGB16UI` stores the red, green, and blue components on 16 bits each. Every component is stored as an unsigned integer.
 * - `RGB16F` stores the red, green, and blue components on 16 bits each. Every component is stored as floating point
 * - `RGB32I` stores the red, green, and blue components on 32 bits each. Every component is stored as an integer.
 * - `RGB32UI` stores the red, green, and blue components on 32 bits each. Every component is stored as an unsigned integer.
 * - `RGB32F` stores the red, green, and blue components on 32 bits each. Every component is stored as floating point
 * - `R11F_G11F_B10F` stores the red, green, and blue components respectively on 11 bits, 11 bits, and 10bits. Every component is stored as floating point.
 * - `RGB565` stores the red, green, and blue components respectively on 5 bits, 6 bits, and 5 bits.
 * - `RGB9_E5` stores the red, green, and blue components on 9 bits each.
 * - `RGBA8` stores the red, green, blue, and alpha components on 8 bits each.
 * - `RGBA8_SNORM` stores the red, green, blue, and alpha components on 8 bits. Every component is stored as normalized.
 * - `RGBA8I` stores the red, green, blue, and alpha components on 8 bits each. Every component is stored as an integer.
 * - `RGBA8UI` stores the red, green, blue, and alpha components on 8 bits. Every component is stored as an unsigned integer.
 * - `RGBA16I` stores the red, green, blue, and alpha components on 16 bits. Every component is stored as an integer.
 * - `RGBA16UI` stores the red, green, blue, and alpha components on 16 bits. Every component is stored as an unsigned integer.
 * - `RGBA16F` stores the red, green, blue, and alpha components on 16 bits. Every component is stored as floating point.
 * - `RGBA32I` stores the red, green, blue, and alpha components on 32 bits. Every component is stored as an integer.
 * - `RGBA32UI` stores the red, green, blue, and alpha components on 32 bits. Every component is stored as an unsigned integer.
 * - `RGBA32F` stores the red, green, blue, and alpha components on 32 bits. Every component is stored as floating point.
 * - `RGB5_A1` stores the red, green, blue, and alpha components respectively on 5 bits, 5 bits, 5 bits, and 1 bit.
 * - `RGB10_A2` stores the red, green, blue, and alpha components respectively on 10 bits, 10 bits, 10 bits and 2 bits.
 * - `RGB10_A2UI` stores the red, green, blue, and alpha components respectively on 10 bits, 10 bits, 10 bits and 2 bits. Every component is stored as an unsigned integer.
 * - `SRGB8` stores the red, green, and blue components on 8 bits each.
 * - `SRGB8_ALPHA8` stores the red, green, blue, and alpha components on 8 bits each.
 * - `DEPTH_COMPONENT16` stores the depth component on 16bits.
 * - `DEPTH_COMPONENT24` stores the depth component on 24bits.
 * - `DEPTH_COMPONENT32F` stores the depth component on 32bits. The component is stored as floating point.
 * - `DEPTH24_STENCIL8` stores the depth, and stencil components respectively on 24 bits and 8 bits. The stencil component is stored as an unsigned integer.
 * - `DEPTH32F_STENCIL8` stores the depth, and stencil components respectively on 32 bits and 8 bits. The depth component is stored as floating point, and the stencil component as an unsigned integer.
 * @remark Note that the texture must have the correct {@link THREE.Texture.type} set, as well as the correct {@link THREE.Texture.format}.
 * @see {@link WebGLRenderingContext.texImage2D} and {@link WebGLRenderingContext.texImage3D} for more details regarding the possible combination
 * of {@link THREE.Texture.format}, {@link THREE.Texture.internalFormat}, and {@link THREE.Texture.type}.
 * @see {@link https://registry.khronos.org/webgl/specs/latest/2.0/ | WebGL2 Specification} and
 * {@link https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf | OpenGL ES 3.0 Specification} For more in-depth information regarding internal formats.
 */
export type PixelFormatGPU = "ALPHA" | "RGB" | "RGBA" | "LUMINANCE" | "LUMINANCE_ALPHA" | "RED_INTEGER" | "R8" | "R8_SNORM" | "R8I" | "R8UI" | "R16I" | "R16UI" | "R16F" | "R32I" | "R32UI" | "R32F" | "RG8" | "RG8_SNORM" | "RG8I" | "RG8UI" | "RG16I" | "RG16UI" | "RG16F" | "RG32I" | "RG32UI" | "RG32F" | "RGB565" | "RGB8" | "RGB8_SNORM" | "RGB8I" | "RGB8UI" | "RGB16I" | "RGB16UI" | "RGB16F" | "RGB32I" | "RGB32UI" | "RGB32F" | "RGB9_E5" | "SRGB8" | "R11F_G11F_B10F" | "RGBA4" | "RGBA8" | "RGBA8_SNORM" | "RGBA8I" | "RGBA8UI" | "RGBA16I" | "RGBA16UI" | "RGBA16F" | "RGBA32I" | "RGBA32UI" | "RGBA32F" | "RGB5_A1" | "RGB10_A2" | "RGB10_A2UI" | "SRGB8_ALPHA8" | "SRGB8" | "DEPTH_COMPONENT16" | "DEPTH_COMPONENT24" | "DEPTH_COMPONENT32F" | "DEPTH24_STENCIL8" | "DEPTH32F_STENCIL8";
declare class Layers {
	/**
	 * Create a new Layers object, with membership initially set to layer 0.
	 */
	constructor();
	/**
	 * A bit mask storing which of the 32 layers this layers object is currently a member of.
	 * @defaultValue `1 | 0`
	 * @remarks Expects a `Integer`
	 */
	mask: number;
	/**
	 * Set membership to `layer`, and remove membership all other layers.
	 * @param layer An integer from 0 to 31.
	 */
	set(layer: number): void;
	/**
	 * Add membership of this `layer`.
	 * @param layer An integer from 0 to 31.
	 */
	enable(layer: number): void;
	/**
	 * Add membership to all layers.
	 */
	enableAll(): void;
	/**
	 * Toggle membership of `layer`.
	 * @param layer An integer from 0 to 31.
	 */
	toggle(layer: number): void;
	/**
	 * Remove membership of this `layer`.
	 * @param layer An integer from 0 to 31.
	 */
	disable(layer: number): void;
	/**
	 * Remove membership from all layers.
	 */
	disableAll(): void;
	/**
	 * Returns true if this and the passed `layers` object have at least one layer in common.
	 * @param layers A Layers object
	 */
	test(layers: Layers): boolean;
	/**
	 * Returns true if the given layer is enabled.
	 * @param layer An integer from 0 to 31.
	 */
	isEnabled(layer: number): boolean;
}
export type Vector2Tuple = [
	x: number,
	y: number
];
export interface Vector2Like {
	readonly x: number;
	readonly y: number;
}
declare class Vector2 {
	constructor(x?: number, y?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	width: number;
	height: number;
	readonly isVector2: true;
	/**
	 * Sets value of this vector.
	 */
	set(x: number, y: number): this;
	/**
	 * Sets the x and y values of this vector both equal to scalar.
	 */
	setScalar(scalar: number): this;
	/**
	 * Sets X component of this vector.
	 */
	setX(x: number): this;
	/**
	 * Sets Y component of this vector.
	 */
	setY(y: number): this;
	/**
	 * Sets a component of this vector.
	 */
	setComponent(index: number, value: number): this;
	/**
	 * Gets a component of this vector.
	 */
	getComponent(index: number): number;
	/**
	 * Returns a new Vector2 instance with the same `x` and `y` values.
	 */
	clone(): this;
	/**
	 * Copies value of v to this vector.
	 */
	copy(v: Vector2Like): this;
	/**
	 * Adds v to this vector.
	 */
	add(v: Vector2Like): this;
	/**
	 * Adds the scalar value s to this vector's x and y values.
	 */
	addScalar(s: number): this;
	/**
	 * Sets this vector to a + b.
	 */
	addVectors(a: Vector2Like, b: Vector2Like): this;
	/**
	 * Adds the multiple of v and s to this vector.
	 */
	addScaledVector(v: Vector2Like, s: number): this;
	/**
	 * Subtracts v from this vector.
	 */
	sub(v: Vector2Like): this;
	/**
	 * Subtracts s from this vector's x and y components.
	 */
	subScalar(s: number): this;
	/**
	 * Sets this vector to a - b.
	 */
	subVectors(a: Vector2Like, b: Vector2Like): this;
	/**
	 * Multiplies this vector by v.
	 */
	multiply(v: Vector2Like): this;
	/**
	 * Multiplies this vector by scalar s.
	 */
	multiplyScalar(scalar: number): this;
	/**
	 * Divides this vector by v.
	 */
	divide(v: Vector2Like): this;
	/**
	 * Divides this vector by scalar s.
	 * Set vector to ( 0, 0 ) if s == 0.
	 */
	divideScalar(s: number): this;
	/**
	 * Multiplies this vector (with an implicit 1 as the 3rd component) by m.
	 */
	applyMatrix3(m: Matrix3): this;
	/**
	 * If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding min value.
	 */
	min(v: Vector2Like): this;
	/**
	 * If this vector's x or y value is less than v's x or y value, replace that value with the corresponding max value.
	 */
	max(v: Vector2Like): this;
	/**
	 * If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value.
	 * If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value.
	 * @param min the minimum x and y values.
	 * @param max the maximum x and y values in the desired range.
	 */
	clamp(min: Vector2Like, max: Vector2Like): this;
	/**
	 * If this vector's x or y values are greater than the max value, they are replaced by the max value.
	 * If this vector's x or y values are less than the min value, they are replaced by the min value.
	 * @param min the minimum value the components will be clamped to.
	 * @param max the maximum value the components will be clamped to.
	 */
	clampScalar(min: number, max: number): this;
	/**
	 * If this vector's length is greater than the max value, it is replaced by the max value.
	 * If this vector's length is less than the min value, it is replaced by the min value.
	 * @param min the minimum value the length will be clamped to.
	 * @param max the maximum value the length will be clamped to.
	 */
	clampLength(min: number, max: number): this;
	/**
	 * The components of the vector are rounded down to the nearest integer value.
	 */
	floor(): this;
	/**
	 * The x and y components of the vector are rounded up to the nearest integer value.
	 */
	ceil(): this;
	/**
	 * The components of the vector are rounded to the nearest integer value.
	 */
	round(): this;
	/**
	 * The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value.
	 */
	roundToZero(): this;
	/**
	 * Inverts this vector.
	 */
	negate(): this;
	/**
	 * Computes dot product of this vector and v.
	 */
	dot(v: Vector2Like): number;
	/**
	 * Computes cross product of this vector and v.
	 */
	cross(v: Vector2Like): number;
	/**
	 * Computes squared length of this vector.
	 */
	lengthSq(): number;
	/**
	 * Computes length of this vector.
	 */
	length(): number;
	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanLength(): number;
	/**
	 * Normalizes this vector.
	 */
	normalize(): this;
	/**
	 * computes the angle in radians with respect to the positive x-axis
	 */
	angle(): number;
	/**
	 * Returns the angle between this vector and vector {@link Vector2 | v} in radians.
	 */
	angleTo(v: Vector2): number;
	/**
	 * Computes distance of this vector to v.
	 */
	distanceTo(v: Vector2Like): number;
	/**
	 * Computes squared distance of this vector to v.
	 */
	distanceToSquared(v: Vector2Like): number;
	/**
	 * Computes the Manhattan length (distance) from this vector to the given vector v
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanDistanceTo(v: Vector2Like): number;
	/**
	 * Normalizes this vector and multiplies it by l.
	 */
	setLength(length: number): this;
	/**
	 * Linearly interpolates between this vector and v, where alpha is the distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v.
	 * @param v vector to interpolate towards.
	 * @param alpha interpolation factor in the closed interval [0, 1].
	 */
	lerp(v: Vector2Like, alpha: number): this;
	/**
	 * Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2.
	 * @param v1 the starting vector.
	 * @param v2 vector to interpolate towards.
	 * @param alpha interpolation factor in the closed interval [0, 1].
	 */
	lerpVectors(v1: Vector2Like, v2: Vector2Like, alpha: number): this;
	/**
	 * Checks for strict equality of this vector and v.
	 */
	equals(v: Vector2Like): boolean;
	/**
	 * Sets this vector's x and y value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y], or copies x and y into the provided array.
	 * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Vector2Tuple, offset?: 0): Vector2Tuple;
	/**
	 * Copies x and y into the provided array-like.
	 * @param array array-like to store the vector to.
	 * @param offset (optional) optional offset into the array.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * Sets this vector's x and y values from the attribute.
	 * @param attribute the source attribute.
	 * @param index index in the attribute.
	 */
	fromBufferAttribute(attribute: BufferAttribute, index: number): this;
	/**
	 * Rotates the vector around center by angle radians.
	 * @param center the point around which to rotate.
	 * @param angle the angle to rotate, in radians.
	 */
	rotateAround(center: Vector2Like, angle: number): this;
	/**
	 * Sets this vector's x and y from Math.random
	 */
	random(): this;
	/**
	 * Iterating through a Vector2 instance will yield its components (x, y) in the corresponding order.
	 */
	[Symbol.iterator](): Iterator<number>;
}
export type Matrix3Tuple = [
	n11: number,
	n12: number,
	n13: number,
	n21: number,
	n22: number,
	n23: number,
	n31: number,
	n32: number,
	n33: number
];
declare class Matrix3 {
	readonly isMatrix3: true;
	/**
	 * Array with matrix values.
	 * @default [1, 0, 0, 0, 1, 0, 0, 0, 1]
	 */
	elements: Matrix3Tuple;
	/**
	 * Creates an identity matrix.
	 */
	constructor();
	/**
	 * Creates a 3x3 matrix with the given arguments in row-major order.
	 */
	constructor(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number);
	set(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number): Matrix3;
	identity(): this;
	copy(m: Matrix3): this;
	extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): this;
	setFromMatrix4(m: Matrix4): Matrix3;
	/**
	 * Multiplies this matrix by m.
	 */
	multiply(m: Matrix3): this;
	premultiply(m: Matrix3): this;
	/**
	 * Sets this matrix to a x b.
	 */
	multiplyMatrices(a: Matrix3, b: Matrix3): this;
	multiplyScalar(s: number): this;
	determinant(): number;
	/**
	 * Inverts this matrix in place.
	 */
	invert(): this;
	/**
	 * Transposes this matrix in place.
	 */
	transpose(): this;
	getNormalMatrix(matrix4: Matrix4): this;
	/**
	 * Transposes this matrix into the supplied array r, and returns itself.
	 */
	transposeIntoArray(r: number[]): this;
	setUvTransform(tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number): this;
	scale(sx: number, sy: number): this;
	rotate(theta: number): this;
	translate(tx: number, ty: number): this;
	/**
	 * Sets this matrix as a 2D translation transform:
	 *
	 * ```
	 * 1, 0, x,
	 * 0, 1, y,
	 * 0, 0, 1
	 * ```
	 *
	 * @param v the amount to translate.
	 */
	makeTranslation(v: Vector2): this;
	/**
	 * Sets this matrix as a 2D translation transform:
	 *
	 * ```
	 * 1, 0, x,
	 * 0, 1, y,
	 * 0, 0, 1
	 * ```
	 *
	 * @param x the amount to translate in the X axis.
	 * @param y the amount to translate in the Y axis.
	 */
	makeTranslation(x: number, y: number): this;
	/**
	 * Sets this matrix as a 2D rotational transformation by theta radians. The resulting matrix will be:
	 *
	 * ```
	 * cos(θ) -sin(θ) 0
	 * sin(θ) cos(θ)  0
	 * 0      0       1
	 * ```
	 *
	 * @param theta Rotation angle in radians. Positive values rotate counterclockwise.
	 */
	makeRotation(theta: number): this;
	/**
	 * Sets this matrix as a 2D scale transform:
	 *
	 * ```
	 * x, 0, 0,
	 * 0, y, 0,
	 * 0, 0, 1
	 * ```
	 *
	 * @param x the amount to scale in the X axis.
	 * @param y the amount to scale in the Y axis.
	 */
	makeScale(x: number, y: number): this;
	equals(matrix: Matrix3): boolean;
	/**
	 * Sets the values of this matrix from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray(array: ArrayLike<number>, offset?: number): this;
	/**
	 * Writes the elements of this matrix to an array in
	 * {@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order column-major} format.
	 */
	toArray(): Matrix3Tuple;
	/**
	 * Writes the elements of this matrix to an array in
	 * {@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order column-major} format.
	 * @param array array to store the resulting vector in. If not given a new array will be created.
	 * @param offset (optional) offset in the array at which to put the result.
	 */
	toArray<TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
	clone(): this;
}
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
export type TypedArrayConstructor = Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor;
export interface BufferAttributeJSON {
	itemSize: number;
	type: string;
	array: number[];
	normalized: boolean;
	name?: string;
	usage?: Usage;
}
declare class BufferAttribute {
	/**
	 * This creates a new {@link THREE.GLBufferAttribute | GLBufferAttribute} object.
	 * @param array Must be a `TypedArray`. Used to instantiate the buffer.
	 * This array should have `itemSize * numVertices` elements, where numVertices is the number of vertices in the associated {@link THREE.BufferGeometry | BufferGeometry}.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @throws `TypeError` When the {@link array} is not a `TypedArray`;
	 */
	constructor(array: TypedArray, itemSize: number, normalized?: boolean);
	/**
	 * Unique number for this attribute instance.
	 */
	readonly id: number;
	/**
	 * Optional name for this attribute instance.
	 * @defaultValue ''
	 */
	name: string;
	/**
	 * The {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray | TypedArray} holding data stored in the buffer.
	 * @returns `TypedArray`
	 */
	array: TypedArray;
	/**
	 * The length of vectors that are being stored in the {@link BufferAttribute.array | array}.
	 * @remarks Expects a `Integer`
	 */
	itemSize: number;
	/**
	 * Defines the intended usage pattern of the data store for optimization purposes.
	 * Corresponds to the {@link BufferAttribute.usage | usage} parameter of
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData | WebGLRenderingContext.bufferData}.
	 * @remarks
	 * After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/BufferAttributeUsage | Buffer Attribute Usage Constants} for all possible values.
	 * @see {@link BufferAttribute.setUsage | setUsage}
	 * @defaultValue {@link THREE.StaticDrawUsage | THREE.StaticDrawUsage}.
	 */
	usage: Usage;
	/**
	 * Configures the bound GPU type for use in shaders. Either {@link FloatType} or {@link IntType}, default is {@link FloatType}.
	 *
	 * Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision
	 * float types, see https://threejs.org/docs/#api/en/core/bufferAttributeTypes/BufferAttributeTypes.
	 */
	gpuType: AttributeGPUType;
	/**
	 * This can be used to only update some components of stored vectors (for example, just the component related to
	 * color). Use the {@link .addUpdateRange} function to add ranges to this array.
	 */
	updateRanges: Array<{
		/**
		 * Position at which to start update.
		 */
		start: number;
		/**
		 * The number of components to update.
		 */
		count: number;
	}>;
	/**
	 * A version number, incremented every time the {@link BufferAttribute.needsUpdate | needsUpdate} property is set to true.
	 * @remarks Expects a `Integer`
	 * @defaultValue `0`
	 */
	version: number;
	/**
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL shader code.
	 * @see `constructor` above for details.
	 * @defaultValue `false`
	 */
	normalized: boolean;
	/**
	 * Represents the number of items this buffer attribute stores. It is internally computed by dividing the
	 * {@link BufferAttribute.array | array}'s length by the {@link BufferAttribute.itemSize | itemSize}. Read-only
	 * property.
	 */
	readonly count: number;
	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to the GPU.
	 * Set this to true when you modify the value of the array.
	 * @remarks Setting this to true also increments the {@link BufferAttribute.version | version}.
	 * @remarks _set-only property_.
	 */
	set needsUpdate(value: boolean);
	/**
	 * Read-only flag to check if a given object is of type {@link BufferAttribute}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isBufferAttribute: true;
	/**
	 * A callback function that is executed after the Renderer has transferred the attribute array data to the GPU.
	 */
	onUploadCallback: () => void;
	/**
	 * Sets the value of the {@link onUploadCallback} property.
	 * @see Example: {@link https://threejs.org/examples/#webgl_buffergeometry | WebGL / BufferGeometry} this is used to free memory after the buffer has been transferred to the GPU.
	 * @see {@link onUploadCallback}
	 * @param callback function that is executed after the Renderer has transferred the attribute array data to the GPU.
	 */
	onUpload(callback: () => void): this;
	/**
	 * Set {@link BufferAttribute.usage | usage}
	 * @remarks
	 * After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/BufferAttributeUsage | Buffer Attribute Usage Constants} for all possible values.
	 * @see {@link BufferAttribute.usage | usage}
	 * @param value Corresponds to the {@link BufferAttribute.usage | usage} parameter of
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData | WebGLRenderingContext.bufferData}.
	 */
	setUsage(usage: Usage): this;
	/**
	 * Adds a range of data in the data array to be updated on the GPU. Adds an object describing the range to the
	 * {@link .updateRanges} array.
	 */
	addUpdateRange(start: number, count: number): void;
	/**
	 * Clears the {@link .updateRanges} array.
	 */
	clearUpdateRanges(): void;
	/**
	 * @returns a copy of this {@link BufferAttribute}.
	 */
	clone(): BufferAttribute;
	/**
	 * Copies another {@link BufferAttribute} to this {@link BufferAttribute}.
	 * @param bufferAttribute
	 */
	copy(source: BufferAttribute): this;
	/**
	 * Copy a vector from bufferAttribute[index2] to {@link BufferAttribute.array | array}[index1].
	 * @param index1
	 * @param bufferAttribute
	 * @param index2
	 */
	copyAt(index1: number, attribute: BufferAttribute, index2: number): this;
	/**
	 * Copy the array given here (which can be a normal array or `TypedArray`) into {@link BufferAttribute.array | array}.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set | TypedArray.set} for notes on requirements if copying a `TypedArray`.
	 */
	copyArray(array: ArrayLike<number>): this;
	/**
	 * Applies matrix {@link Matrix3 | m} to every Vector3 element of this {@link BufferAttribute}.
	 * @param m
	 */
	applyMatrix3(m: Matrix3): this;
	/**
	 * Applies matrix {@link Matrix4 | m} to every Vector3 element of this {@link BufferAttribute}.
	 * @param m
	 */
	applyMatrix4(m: Matrix4): this;
	/**
	 * Applies normal matrix {@link Matrix3 | m} to every Vector3 element of this {@link BufferAttribute}.
	 * @param m
	 */
	applyNormalMatrix(m: Matrix3): this;
	/**
	 * Applies matrix {@link Matrix4 | m} to every Vector3 element of this {@link BufferAttribute}, interpreting the elements as a direction vectors.
	 * @param m
	 */
	transformDirection(m: Matrix4): this;
	/**
	 * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set | TypedArray.set}( {@link value}, {@link offset} )
	 * on the {@link BufferAttribute.array | array}.
	 * @param value {@link Array | Array} or `TypedArray` from which to copy values.
	 * @param offset index of the {@link BufferAttribute.array | array} at which to start copying. Expects a `Integer`. Default `0`.
	 * @throws `RangeError` When {@link offset} is negative or is too large.
	 */
	set(value: ArrayLike<number> | ArrayBufferView, offset?: number): this;
	/**
	 * Returns the given component of the vector at the given index.
	 */
	getComponent(index: number, component: number): number;
	/**
	 * Sets the given component of the vector at the given index.
	 */
	setComponent(index: number, component: number, value: number): void;
	/**
	 * Returns the x component of the vector at the given index.
	 * @param index Expects a `Integer`
	 */
	getX(index: number): number;
	/**
	 * Sets the x component of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param x
	 */
	setX(index: number, x: number): this;
	/**
	 * Returns the y component of the vector at the given index.
	 * @param index Expects a `Integer`
	 */
	getY(index: number): number;
	/**
	 * Sets the y component of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param y
	 */
	setY(index: number, y: number): this;
	/**
	 * Returns the z component of the vector at the given index.
	 * @param index Expects a `Integer`
	 */
	getZ(index: number): number;
	/**
	 * Sets the z component of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param z
	 */
	setZ(index: number, z: number): this;
	/**
	 * Returns the w component of the vector at the given index.
	 * @param index Expects a `Integer`
	 */
	getW(index: number): number;
	/**
	 * Sets the w component of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param w
	 */
	setW(index: number, z: number): this;
	/**
	 * Sets the x and y components of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param x
	 * @param y
	 */
	setXY(index: number, x: number, y: number): this;
	/**
	 * Sets the x, y and z components of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param x
	 * @param y
	 * @param z
	 */
	setXYZ(index: number, x: number, y: number, z: number): this;
	/**
	 * Sets the x, y, z and w components of the vector at the given index.
	 * @param index Expects a `Integer`
	 * @param x
	 * @param y
	 * @param z
	 * @param w
	 */
	setXYZW(index: number, x: number, y: number, z: number, w: number): this;
	/**
	 * Convert this object to three.js to the `data.attributes` part of {@link https://github.com/mrdoob/three.js/wiki/JSON-Geometry-format-4 | JSON Geometry format v4},
	 */
	toJSON(): BufferAttributeJSON;
}
declare class Int8BufferAttribute extends BufferAttribute {
	/**
	 * This creates a new {@link THREE.Int8BufferAttribute | Int8BufferAttribute} object.
	 * @param array This can be a typed or untyped (normal) array or an integer length. An array value will be converted to `Int8Array`.
	 * If a length is given a new `TypedArray` will created, initialized with all elements set to zero.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 */
	constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
}
declare class Uint8BufferAttribute extends BufferAttribute {
	/**
	 * This creates a new {@link THREE.Uint8BufferAttribute | Uint8BufferAttribute} object.
	 * @param array This can be a typed or untyped (normal) array or an integer length. An array value will be converted to `Uint8Array`.
	 * If a length is given a new `TypedArray` will created, initialized with all elements set to zero.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @see {@link THREE.BufferAttribute | BufferAttribute}
	 */
	constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
}
declare class Uint8ClampedBufferAttribute extends BufferAttribute {
	/**
	 * This creates a new {@link THREE.Uint8ClampedBufferAttribute | Uint8ClampedBufferAttribute} object.
	 * @param array This can be a typed or untyped (normal) array or an integer length. An array value will be converted to `Uint8ClampedArray`.
	 * If a length is given a new `TypedArray` will created, initialized with all elements set to zero.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @see {@link THREE.BufferAttribute | BufferAttribute}
	 */
	constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
}
declare class Int16BufferAttribute extends BufferAttribute {
	/**
	 * This creates a new {@link THREE.Int16BufferAttribute | Int16BufferAttribute} object.
	 * @param array This can be a typed or untyped (normal) array or an integer length. An array value will be converted to `Int16Array`.
	 * If a length is given a new `TypedArray` will created, initialized with all elements set to zero.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @see {@link THREE.BufferAttribute | BufferAttribute}
	 */
	constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
}
declare class Uint16BufferAttribute extends BufferAttribute {
	/**
	 * This creates a new {@link THREE.Uint16BufferAttribute | Uint16BufferAttribute} object.
	 * @param array This can be a typed or untyped (normal) array or an integer length. An array value will be converted to `Uint16Array`.
	 * If a length is given a new `TypedArray` will created, initialized with all elements set to zero.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @see {@link THREE.BufferAttribute | BufferAttribute}
	 */
	constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
}
declare class Int32BufferAttribute extends BufferAttribute {
	/**
	 * This creates a new {@link THREE.Int32BufferAttribute | Int32BufferAttribute} object.
	 * @param array This can be a typed or untyped (normal) array or an integer length. An array value will be converted to `Int32Array`.
	 * If a length is given a new `TypedArray` will created, initialized with all elements set to zero.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @see {@link THREE.BufferAttribute | BufferAttribute}
	 */
	constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
}
declare class Uint32BufferAttribute extends BufferAttribute {
	/**
	 * This creates a new {@link THREE.Uint32BufferAttribute | Uint32BufferAttribute} object.
	 * @param array This can be a typed or untyped (normal) array or an integer length. An array value will be converted to `Uint32Array`.
	 * If a length is given a new `TypedArray` will created, initialized with all elements set to zero.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @see {@link THREE.BufferAttribute | BufferAttribute}
	 */
	constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
}
declare class Float16BufferAttribute extends BufferAttribute {
	/**
	 * This creates a new {@link THREE.Float16BufferAttribute | Float16BufferAttribute} object.
	 * @param array This can be a typed or untyped (normal) array or an integer length. An array value will be converted to `Uint16Array`.
	 * If a length is given a new `TypedArray` will created, initialized with all elements set to zero.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @see {@link THREE.BufferAttribute | BufferAttribute}
	 */
	constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
}
declare class Float32BufferAttribute extends BufferAttribute {
	/**
	 * This creates a new {@link THREE.Float32BufferAttribute | Float32BufferAttribute} object.
	 * @param array This can be a typed or untyped (normal) array or an integer length. An array value will be converted to `Float32Array`.
	 * If a length is given a new `TypedArray` will created, initialized with all elements set to zero.
	 * @param itemSize the number of values of the {@link array} that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a _position_, _normal_, or _color_),
	 * then itemSize should be `3`.
	 * @param normalized Applies to integer data only.
	 * Indicates how the underlying data in the buffer maps to the values in the GLSL code.
	 * For instance, if {@link array} is an instance of `UInt16Array`, and  {@link normalized} is true,
	 * the values `0` - `+65535` in the array data will be mapped to `0.0f` - `+1.0f` in the GLSL attribute.
	 * An `Int16Array` (signed) would map from `-32768` - `+32767` to `-1.0f` - `+1.0f`.
	 * If normalized is false, the values will be converted to floats unmodified,
	 * i.e. `32767` becomes `32767.0f`.
	 * Default `false`.
	 * @see {@link THREE.BufferAttribute | BufferAttribute}
	 */
	constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
}
declare class InterleavedBuffer {
	readonly isInterleavedBuffer: true;
	/**
	 * Create a new instance of {@link InterleavedBuffer}
	 * @param array A {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray | TypedArray} with a shared buffer. Stores the geometry data.
	 * @param stride The number of typed-array elements per vertex. Expects a `Integer`
	 */
	constructor(array: TypedArray, stride: number);
	/**
	 * A {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray | TypedArray} with a shared buffer. Stores the geometry data.
	 */
	array: TypedArray;
	/**
	 * The number of {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray | TypedArray} elements per vertex.
	 * @remarks Expects a `Integer`
	 */
	stride: number;
	/**
	 * Defines the intended usage pattern of the data store for optimization purposes.
	 * Corresponds to the {@link BufferAttribute.usage | usage} parameter of
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData | WebGLRenderingContext.bufferData}.
	 * @remarks
	 * After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/BufferAttributeUsage | Buffer Attribute Usage Constants} for all possible values.
	 * @see {@link BufferAttribute.setUsage | setUsage}
	 * @defaultValue {@link THREE.StaticDrawUsage | THREE.StaticDrawUsage}.
	 */
	usage: Usage;
	/**
	 * This can be used to only update some components of stored data. Use the {@link .addUpdateRange} function to add
	 * ranges to this array.
	 */
	updateRanges: Array<{
		/**
		 * Position at which to start update.
		 */
		start: number;
		/**
		 * The number of components to update.
		 */
		count: number;
	}>;
	/**
	 * A version number, incremented every time the {@link BufferAttribute.needsUpdate | needsUpdate} property is set to true.
	 * @remarks Expects a `Integer`
	 * @defaultValue `0`
	 */
	version: number;
	/**
	 * Gives the total number of elements in the array.
	 * @remarks Expects a `Integer`
	 * @defaultValue 0
	 */
	count: number;
	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to the GPU.
	 * Set this to true when you modify the value of the array.
	 * @remarks Setting this to true also increments the {@link BufferAttribute.version | version}.
	 * @remarks _set-only property_.
	 */
	set needsUpdate(value: boolean);
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * A callback function that is executed after the Renderer has transferred the geometry data to the GPU.
	 */
	onUploadCallback: () => void;
	/**
	 * Sets the value of the {@link onUploadCallback} property.
	 * @see {@link onUploadCallback}
	 * @param callback function that is executed after the Renderer has transferred the geometry data to the GPU.
	 */
	onUpload(callback: () => void): this;
	/**
	 * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set | TypedArray.set}( {@link value}, {@link offset} )
	 * on the {@link BufferAttribute.array | array}.
	 * @param value The source `TypedArray`.
	 * @param offset index of the {@link BufferAttribute.array | array} at which to start copying. Expects a `Integer`. Default `0`.
	 * @throws `RangeError` When {@link offset} is negative or is too large.
	 */
	set(value: ArrayLike<number>, offset: number): this;
	/**
	 * Set {@link BufferAttribute.usage | usage}
	 * @remarks
	 * After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/BufferAttributeUsage | Buffer Attribute Usage Constants} for all possible values.
	 * @see {@link BufferAttribute.usage | usage}
	 * @param value Corresponds to the {@link BufferAttribute.usage | usage} parameter of
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData | WebGLRenderingContext.bufferData}.
	 */
	setUsage(value: Usage): this;
	/**
	 * Adds a range of data in the data array to be updated on the GPU. Adds an object describing the range to the
	 * {@link .updateRanges} array.
	 */
	addUpdateRange(start: number, count: number): void;
	/**
	 * Clears the {@link .updateRanges} array.
	 */
	clearUpdateRanges(): void;
	/**
	 * Copies another {@link InterleavedBuffer} to this {@link InterleavedBuffer} instance.
	 * @param source
	 */
	copy(source: InterleavedBuffer): this;
	/**
	 * Copies data from {@link attribute}[{@link index2}] to {@link InterleavedBuffer.array | array}[{@link index1}].
	 * @param index1 Expects a `Integer`
	 * @param attribute
	 * @param index2 Expects a `Integer`
	 */
	copyAt(index1: number, attribute: InterleavedBufferAttribute, index2: number): this;
	/**
	 * Creates a clone of this {@link InterleavedBuffer}.
	 * @param data This object holds shared array buffers required for properly cloning geometries with interleaved attributes.
	 */
	clone(data: {}): InterleavedBuffer;
	/**
	 * Serializes this {@link InterleavedBuffer}.
	 * Converting to {@link https://github.com/mrdoob/three.js/wiki/JSON-Geometry-format-4 | JSON Geometry format v4},
	 * @param data This object holds shared array buffers required for properly serializing geometries with interleaved attributes.
	 */
	toJSON(data: {}): {
		uuid: string;
		buffer: string;
		type: string;
		stride: number;
	};
}
declare class InterleavedBufferAttribute {
	/**
	 * Create a new instance of {@link THREE.InterleavedBufferAttribute | InterleavedBufferAttribute}.
	 * @param interleavedBuffer
	 * @param itemSize
	 * @param offset
	 * @param normalized Default `false`.
	 */
	constructor(interleavedBuffer: InterleavedBuffer, itemSize: number, offset: number, normalized?: boolean);
	/**
	 * Optional name for this attribute instance.
	 * @defaultValue `''`
	 */
	name: string;
	/**
	 * The {@link InterleavedBuffer | InterleavedBuffer} instance passed in the constructor.
	 */
	data: InterleavedBuffer;
	/**
	 * How many values make up each item.
	 * @remarks Expects a `Integer`
	 */
	itemSize: number;
	/**
	 * The offset in the underlying array buffer where an item starts.
	 * @remarks Expects a `Integer`
	 */
	offset: number;
	/**
	 * @defaultValue `false`
	 */
	normalized: boolean;
	/**
	 * The value of {@link data | .data}.{@link InterleavedBuffer.count | count}.
	 * If the buffer is storing a 3-component item (such as a _position, normal, or color_), then this will count the number of such items stored.
	 * @remarks _get-only property_.
	 * @remarks Expects a `Integer`
	 */
	get count(): number;
	/**
	 * The value of {@link InterleavedBufferAttribute.data | data}.{@link InterleavedBuffer.array | array}.
	 * @remarks _get-only property_.
	 */
	get array(): TypedArray;
	/**
	 * Flag to indicate that the {@link data | .data} ({@link InterleavedBuffer}) attribute has changed and should be re-sent to the GPU.
	 * @remarks Setting this to have the same result of setting true also increments the {@link InterleavedBuffer.needsUpdate | InterleavedBuffer.needsUpdate} of {@link data | .data}.
	 * @remarks Setting this to true also increments the {@link InterleavedBuffer.version | InterleavedBuffer.version}.
	 * @remarks _set-only property_.
	 */
	set needsUpdate(value: boolean);
	/**
	 * Read-only flag to check if a given object is of type {@link InterleavedBufferAttribute}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isInterleavedBufferAttribute: true;
	/**
	 * Applies matrix {@link Matrix4 | m} to every Vector3 element of this InterleavedBufferAttribute.
	 * @param m
	 */
	applyMatrix4(m: Matrix4): this;
	/**
	 * Applies normal matrix {@link Matrix3 | m} to every Vector3 element of this InterleavedBufferAttribute.
	 * @param m
	 */
	applyNormalMatrix(m: Matrix3): this;
	/**
	 * Applies matrix {@link Matrix4 | m} to every Vector3 element of this InterleavedBufferAttribute, interpreting the elements as a direction vectors.
	 * @param m
	 */
	transformDirection(m: Matrix4): this;
	/**
	 * Returns the given component of the vector at the given index.
	 */
	getComponent(index: number, component: number): number;
	/**
	 * Sets the given component of the vector at the given index.
	 */
	setComponent(index: number, component: number, value: number): this;
	/**
	 * Returns the x component of the item at the given index.
	 * @param index Expects a `Integer`
	 */
	getX(index: number): number;
	/**
	 * Sets the x component of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param x Expects a `Float`
	 */
	setX(index: number, x: number): this;
	/**
	 * Returns the y component of the item at the given index.
	 * @param index Expects a `Integer`
	 */
	getY(index: number): number;
	/**
	 * Sets the y component of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param y Expects a `Float`
	 */
	setY(index: number, y: number): this;
	/**
	 * Returns the z component of the item at the given index.
	 * @param index Expects a `Integer`
	 */
	getZ(index: number): number;
	/**
	 * Sets the z component of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param z Expects a `Float`
	 */
	setZ(index: number, z: number): this;
	/**
	 * Returns the w component of the item at the given index.
	 * @param index Expects a `Integer`
	 */
	getW(index: number): number;
	/**
	 * Sets the w component of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param w Expects a `Float`
	 */
	setW(index: number, z: number): this;
	/**
	 * Sets the x and y components of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	setXY(index: number, x: number, y: number): this;
	/**
	 * Sets the x, y and z components of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 */
	setXYZ(index: number, x: number, y: number, z: number): this;
	/**
	 * Sets the x, y, z and w components of the item at the given index.
	 * @param index Expects a `Integer`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 * @param w Expects a `Float`
	 */
	setXYZW(index: number, x: number, y: number, z: number, w: number): this;
	/**
	 * Creates a clone of this {@link InterleavedBufferAttribute}.
	 * @param data This object holds shared array buffers required for properly cloning geometries with interleaved attributes.
	 */
	clone(data?: {}): BufferAttribute;
	/**
	 * Serializes this {@link InterleavedBufferAttribute}.
	 * Converting to {@link https://github.com/mrdoob/three.js/wiki/JSON-Geometry-format-4 | JSON Geometry format v4},
	 * @param data This object holds shared array buffers required for properly serializing geometries with interleaved attributes.
	 */
	toJSON(data?: {}): {
		isInterleavedBufferAttribute: true;
		itemSize: number;
		data: string;
		offset: number;
		normalized: boolean;
	};
}
export interface QuaternionLike {
	readonly x: number;
	readonly y: number;
	readonly z: number;
	readonly w: number;
}
export type QuaternionTuple = [
	x: number,
	y: number,
	z: number,
	w: number
];
declare class Quaternion {
	/**
	 * @param x x coordinate
	 * @param y y coordinate
	 * @param z z coordinate
	 * @param w w coordinate
	 */
	constructor(x?: number, y?: number, z?: number, w?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	/**
	 * @default 1
	 */
	w: number;
	readonly isQuaternion: true;
	/**
	 * Sets values of this quaternion.
	 */
	set(x: number, y: number, z: number, w: number): this;
	/**
	 * Clones this quaternion.
	 */
	clone(): this;
	/**
	 * Copies values of q to this quaternion.
	 */
	copy(q: QuaternionLike): this;
	/**
	 * Sets this quaternion from rotation specified by Euler angles.
	 */
	setFromEuler(euler: Euler, update?: boolean): this;
	/**
	 * Sets this quaternion from rotation specified by axis and angle.
	 * Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.
	 * Axis have to be normalized, angle is in radians.
	 */
	setFromAxisAngle(axis: Vector3Like, angle: number): this;
	/**
	 * Sets this quaternion from rotation component of m. Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm.
	 */
	setFromRotationMatrix(m: Matrix4): this;
	setFromUnitVectors(vFrom: Vector3, vTo: Vector3Like): this;
	angleTo(q: Quaternion): number;
	rotateTowards(q: Quaternion, step: number): this;
	identity(): this;
	/**
	 * Inverts this quaternion.
	 */
	invert(): this;
	conjugate(): this;
	dot(v: Quaternion): number;
	lengthSq(): number;
	/**
	 * Computes length of this quaternion.
	 */
	length(): number;
	/**
	 * Normalizes this quaternion.
	 */
	normalize(): this;
	/**
	 * Multiplies this quaternion by b.
	 */
	multiply(q: Quaternion): this;
	premultiply(q: Quaternion): this;
	/**
	 * Sets this quaternion to a x b
	 * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm.
	 */
	multiplyQuaternions(a: Quaternion, b: Quaternion): this;
	slerp(qb: Quaternion, t: number): this;
	slerpQuaternions(qa: Quaternion, qb: Quaternion, t: number): this;
	equals(v: Quaternion): boolean;
	/**
	 * Sets this quaternion's x, y, z and w value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
	 * @param array (optional) array to store the quaternion to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: QuaternionTuple, offset?: 0): QuaternionTuple;
	/**
	 * Copies x, y, z and w into the provided array-like.
	 * @param array array-like to store the quaternion to.
	 * @param offset (optional) optional offset into the array.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * This method defines the serialization result of Quaternion.
	 * @return The numerical elements of this quaternion in an array of format [x, y, z, w].
	 */
	toJSON(): [
		number,
		number,
		number,
		number
	];
	/**
	 * Sets x, y, z, w properties of this quaternion from the attribute.
	 * @param attribute the source attribute.
	 * @param index index in the attribute.
	 */
	fromBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, index: number): this;
	_onChange(callback: () => void): this;
	_onChangeCallback: () => void;
	static slerpFlat(dst: number[], dstOffset: number, src0: number[], srcOffset: number, src1: number[], stcOffset1: number, t: number): void;
	static multiplyQuaternionsFlat(dst: number[], dstOffset: number, src0: number[], srcOffset: number, src1: number[], stcOffset1: number): number[];
	random(): this;
	[Symbol.iterator](): Generator<number, void>;
}
export type EulerOrder = "XYZ" | "YXZ" | "ZXY" | "ZYX" | "YZX" | "XZY";
export type EulerTuple = [
	x: number,
	y: number,
	z: number,
	order?: EulerOrder
];
declare class Euler {
	constructor(x?: number, y?: number, z?: number, order?: EulerOrder);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	/**
	 * @default THREE.Euler.DEFAULT_ORDER
	 */
	order: EulerOrder;
	readonly isEuler: true;
	_onChangeCallback: () => void;
	set(x: number, y: number, z: number, order?: EulerOrder): Euler;
	clone(): this;
	copy(euler: Euler): this;
	setFromRotationMatrix(m: Matrix4, order?: EulerOrder, update?: boolean): Euler;
	setFromQuaternion(q: Quaternion, order?: EulerOrder, update?: boolean): Euler;
	setFromVector3(v: Vector3, order?: EulerOrder): Euler;
	reorder(newOrder: EulerOrder): Euler;
	equals(euler: Euler): boolean;
	fromArray(array: EulerTuple): Euler;
	toArray(array?: Partial<EulerTuple>, offset?: number): EulerTuple;
	_onChange(callback: () => void): this;
	static DEFAULT_ORDER: "XYZ";
	[Symbol.iterator](): Generator<string | number, void>;
}
export type Matrix4Tuple = [
	n11: number,
	n12: number,
	n13: number,
	n14: number,
	n21: number,
	n22: number,
	n23: number,
	n24: number,
	n31: number,
	n32: number,
	n33: number,
	n34: number,
	n41: number,
	n42: number,
	n43: number,
	n44: number
];
declare class Matrix4 {
	readonly isMatrix4: true;
	/**
	 * Array with matrix values.
	 * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
	 */
	elements: Matrix4Tuple;
	/**
	 * Creates an identity matrix.
	 */
	constructor();
	/**
	 * Creates a 4x4 matrix with the given arguments in row-major order.
	 */
	constructor(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number);
	/**
	 * Sets all fields of this matrix.
	 */
	set(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number): this;
	/**
	 * Resets this matrix to identity.
	 */
	identity(): this;
	clone(): Matrix4;
	copy(m: Matrix4): this;
	copyPosition(m: Matrix4): this;
	/**
	 * Set the upper 3x3 elements of this matrix to the values of the Matrix3 m.
	 */
	setFromMatrix3(m: Matrix3): this;
	extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): this;
	makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): this;
	/**
	 * Copies the rotation component of the supplied matrix m into this matrix rotation component.
	 */
	extractRotation(m: Matrix4): this;
	makeRotationFromEuler(euler: Euler): this;
	makeRotationFromQuaternion(q: Quaternion): this;
	/**
	 * Sets the rotation component of the transformation matrix, looking from [eye]{@link Vector3} towards
	 * [target]{@link Vector3}, and oriented by the up-direction [up]{@link Vector3}.
	 */
	lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
	/**
	 * Multiplies this matrix by m.
	 */
	multiply(m: Matrix4): this;
	premultiply(m: Matrix4): this;
	/**
	 * Sets this matrix to a x b.
	 */
	multiplyMatrices(a: Matrix4, b: Matrix4): this;
	/**
	 * Multiplies this matrix by s.
	 */
	multiplyScalar(s: number): this;
	/**
	 * Computes determinant of this matrix.
	 * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	 */
	determinant(): number;
	/**
	 * Transposes this matrix.
	 */
	transpose(): this;
	/**
	 * Sets the position component for this matrix from vector v.
	 */
	setPosition(v: Vector3): this;
	setPosition(x: number, y: number, z: number): this;
	/**
	 * Inverts this matrix.
	 */
	invert(): this;
	/**
	 * Multiplies the columns of this matrix by vector v.
	 */
	scale(v: Vector3): this;
	getMaxScaleOnAxis(): number;
	/**
	 * Sets this matrix as translation transform.
	 */
	makeTranslation(v: Vector3): this;
	makeTranslation(x: number, y: number, z: number): this;
	/**
	 * Sets this matrix as rotation transform around x axis by theta radians.
	 *
	 * @param theta Rotation angle in radians.
	 */
	makeRotationX(theta: number): this;
	/**
	 * Sets this matrix as rotation transform around y axis by theta radians.
	 *
	 * @param theta Rotation angle in radians.
	 */
	makeRotationY(theta: number): this;
	/**
	 * Sets this matrix as rotation transform around z axis by theta radians.
	 *
	 * @param theta Rotation angle in radians.
	 */
	makeRotationZ(theta: number): this;
	/**
	 * Sets this matrix as rotation transform around axis by angle radians.
	 * Based on http://www.gamedev.net/reference/articles/article1199.asp.
	 *
	 * @param axis Rotation axis.
	 * @param angle Rotation angle in radians.
	 */
	makeRotationAxis(axis: Vector3, angle: number): this;
	/**
	 * Sets this matrix as scale transform.
	 */
	makeScale(x: number, y: number, z: number): this;
	/**
	 * Sets this matrix as shear transform.
	 */
	makeShear(xy: number, xz: number, yx: number, yz: number, zx: number, zy: number): this;
	/**
	 * Sets this matrix to the transformation composed of translation, rotation and scale.
	 */
	compose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
	/**
	 * Decomposes this matrix into it's position, quaternion and scale components.
	 */
	decompose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
	/**
	 * Creates a perspective projection matrix.
	 */
	makePerspective(left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: CoordinateSystem, reversedDepth?: boolean): this;
	/**
	 * Creates an orthographic projection matrix.
	 */
	makeOrthographic(left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: CoordinateSystem, reversedDepth?: boolean): this;
	equals(matrix: Matrix4): boolean;
	/**
	 * Sets the values of this matrix from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray(array: ArrayLike<number>, offset?: number): this;
	/**
	 * Writes the elements of this matrix to an array in
	 * {@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order column-major} format.
	 */
	toArray(): Matrix4Tuple;
	/**
	 * Writes the elements of this matrix to an array in
	 * {@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order column-major} format.
	 * @param array array to store the resulting vector in.
	 * @param offset (optional) offset in the array at which to put the result.
	 */
	toArray<TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
}
export type Vector4Tuple = [
	number,
	number,
	number,
	number
];
export interface Vector4Like {
	readonly x: number;
	readonly y: number;
	readonly z: number;
	readonly w: number;
}
declare class Vector4 {
	constructor(x?: number, y?: number, z?: number, w?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	/**
	 * @default 0
	 */
	w: number;
	width: number;
	height: number;
	readonly isVector4: true;
	/**
	 * Sets value of this vector.
	 */
	set(x: number, y: number, z: number, w: number): this;
	/**
	 * Sets all values of this vector.
	 */
	setScalar(scalar: number): this;
	/**
	 * Sets X component of this vector.
	 */
	setX(x: number): this;
	/**
	 * Sets Y component of this vector.
	 */
	setY(y: number): this;
	/**
	 * Sets Z component of this vector.
	 */
	setZ(z: number): this;
	/**
	 * Sets w component of this vector.
	 */
	setW(w: number): this;
	setComponent(index: number, value: number): this;
	getComponent(index: number): number;
	/**
	 * Clones this vector.
	 */
	clone(): this;
	/**
	 * Copies value of v to this vector.
	 */
	copy(v: Vector4Like): this;
	/**
	 * Adds v to this vector.
	 */
	add(v: Vector4Like): this;
	addScalar(scalar: number): this;
	/**
	 * Sets this vector to a + b.
	 */
	addVectors(a: Vector4Like, b: Vector4Like): this;
	addScaledVector(v: Vector4Like, s: number): this;
	/**
	 * Subtracts v from this vector.
	 */
	sub(v: Vector4Like): this;
	subScalar(s: number): this;
	/**
	 * Sets this vector to a - b.
	 */
	subVectors(a: Vector4Like, b: Vector4Like): this;
	multiply(v: Vector4Like): this;
	/**
	 * Multiplies this vector by scalar s.
	 */
	multiplyScalar(s: number): this;
	applyMatrix4(m: Matrix4): this;
	divide(v: Vector4Like): this;
	/**
	 * Divides this vector by scalar s.
	 * Set vector to ( 0, 0, 0 ) if s == 0.
	 */
	divideScalar(s: number): this;
	/**
	 * http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	 * @param q is assumed to be normalized
	 */
	setAxisAngleFromQuaternion(q: QuaternionLike): this;
	/**
	 * http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	 * @param m assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	 */
	setAxisAngleFromRotationMatrix(m: Matrix4): this;
	/**
	 * Sets this vector to the position elements of the
	 * [transformation matrix]{@link https://en.wikipedia.org/wiki/Transformation_matrix} m.
	 */
	setFromMatrixPosition(m: Matrix4): this;
	min(v: Vector4Like): this;
	max(v: Vector4Like): this;
	clamp(min: Vector4Like, max: Vector4Like): this;
	clampScalar(min: number, max: number): this;
	floor(): this;
	ceil(): this;
	round(): this;
	roundToZero(): this;
	/**
	 * Inverts this vector.
	 */
	negate(): this;
	/**
	 * Computes dot product of this vector and v.
	 */
	dot(v: Vector4Like): number;
	/**
	 * Computes squared length of this vector.
	 */
	lengthSq(): number;
	/**
	 * Computes length of this vector.
	 */
	length(): number;
	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanLength(): number;
	/**
	 * Normalizes this vector.
	 */
	normalize(): this;
	/**
	 * Normalizes this vector and multiplies it by l.
	 */
	setLength(length: number): this;
	/**
	 * Linearly interpolate between this vector and v with alpha factor.
	 */
	lerp(v: Vector4Like, alpha: number): this;
	lerpVectors(v1: Vector4Like, v2: Vector4Like, alpha: number): this;
	/**
	 * Checks for strict equality of this vector and v.
	 */
	equals(v: Vector4Like): boolean;
	/**
	 * Sets this vector's x, y, z and w value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
	 * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Vector4Tuple, offset?: 0): Vector4Tuple;
	/**
	 * Copies x, y, z and w into the provided array-like.
	 * @param array array-like to store the vector to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	fromBufferAttribute(attribute: BufferAttribute, index: number): this;
	/**
	 * Sets this vector's x, y, z and w from Math.random
	 */
	random(): this;
	/**
	 * Iterating through a Vector4 instance will yield its components (x, y, z, w) in the corresponding order.
	 */
	[Symbol.iterator](): Iterator<number>;
}
declare class Camera extends Object3D {
	/**
	 * Read-only flag to check if a given object is of type {@link Camera}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCamera: true;
	/**
	 * @override
	 * @defaultValue `Camera`
	 */
	override readonly type: string | "Camera";
	/**
	 * @override
	 * The {@link Layers | layers} that the {@link Camera} is a member of.
	 * @remarks Objects must share at least one layer with the {@link Camera} to be n when the camera's viewpoint is rendered.
	 * @defaultValue `new THREE.Layers()`
	 */
	override layers: Layers;
	/**
	 * This is the inverse of matrixWorld.
	 * @remarks MatrixWorld contains the Matrix which has the world transform of the {@link Camera} .
	 * @defaultValue {@link Matrix4 | `new THREE.Matrix4()`}
	 */
	matrixWorldInverse: Matrix4;
	/**
	 * This is the matrix which contains the projection.
	 * @defaultValue {@link Matrix4 | `new THREE.Matrix4()`}
	 */
	projectionMatrix: Matrix4;
	/**
	 * This is the inverse of projectionMatrix.
	 * @defaultValue {@link Matrix4 | `new THREE.Matrix4()`}
	 */
	projectionMatrixInverse: Matrix4;
	coordinateSystem: CoordinateSystem;
	viewport?: Vector4;
	/**
	 * @remarks
	 * Note that this class is not intended to be called directly; you probably want a
	 * {@link PerspectiveCamera | PerspectiveCamera} or
	 * {@link OrthographicCamera | OrthographicCamera} instead.
	 */
	constructor();
	/**
	 * The flag that indicates whether the camera uses a reversed depth buffer.
	 *
	 * @default false
	 */
	get reversedDepth(): boolean;
	/**
	 * Returns a {@link Vector3 | Vector3} representing the world space direction in which the {@link Camera} is looking.
	 * @remarks Note: A {@link Camera} looks down its local, negative z-axis.
	 * @param target The result will be copied into this Vector3.
	 */
	getWorldDirection(target: Vector3): Vector3;
}
export interface ColorSpaceDefinition {
	primaries: [
		number,
		number,
		number,
		number,
		number,
		number
	];
	whitePoint: [
		number,
		number
	];
	transfer: ColorSpaceTransfer;
	toXYZ: Matrix3;
	fromXYZ: Matrix3;
	luminanceCoefficients: [
		number,
		number,
		number
	];
	workingColorSpaceConfig?: {
		unpackColorSpace: string;
	};
	outputColorSpaceConfig?: {
		drawingBufferColorSpace: string;
		toneMappingNode?: "extended" | "standard";
	};
}
export interface ColorManagement {
	/**
	 * @default true
	 */
	enabled: boolean;
	/**
	 * @default LinearSRGBColorSpace
	 */
	workingColorSpace: string;
	spaces: Record<string, ColorSpaceDefinition>;
	convert: (color: Color, sourceColorSpace: string, targetColorSpace: string) => Color;
	workingToColorSpace: (color: Color, targetColorSpace: string) => Color;
	colorSpaceToWorking: (color: Color, sourceColorSpace: string) => Color;
	getPrimaries: (colorSpace: string) => [
		number,
		number,
		number,
		number,
		number,
		number
	];
	getTransfer: (colorSpace: string) => ColorSpaceTransfer;
	getLuminanceCoefficients: (target: Vector3, colorSpace?: string) => [
		number,
		number,
		number
	];
	define: (colorSpaces: Record<string, ColorSpaceDefinition>) => void;
	/**
	 * @deprecated .fromWorkingColorSpace() has been renamed to .workingToColorSpace().
	 */
	fromWorkingColorSpace: (color: Color, targetColorSpace: string) => Color;
	/**
	 * @deprecated .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().
	 */
	toWorkingColorSpace: (color: Color, sourceColorSpace: string) => Color;
}
declare const ColorManagement: ColorManagement;
declare function SRGBToLinear(c: number): number;
declare const _colorKeywords: {
	aliceblue: 15792383;
	antiquewhite: 16444375;
	aqua: 65535;
	aquamarine: 8388564;
	azure: 15794175;
	beige: 16119260;
	bisque: 16770244;
	black: 0;
	blanchedalmond: 16772045;
	blue: 255;
	blueviolet: 9055202;
	brown: 10824234;
	burlywood: 14596231;
	cadetblue: 6266528;
	chartreuse: 8388352;
	chocolate: 13789470;
	coral: 16744272;
	cornflowerblue: 6591981;
	cornsilk: 16775388;
	crimson: 14423100;
	cyan: 65535;
	darkblue: 139;
	darkcyan: 35723;
	darkgoldenrod: 12092939;
	darkgray: 11119017;
	darkgreen: 25600;
	darkgrey: 11119017;
	darkkhaki: 12433259;
	darkmagenta: 9109643;
	darkolivegreen: 5597999;
	darkorange: 16747520;
	darkorchid: 10040012;
	darkred: 9109504;
	darksalmon: 15308410;
	darkseagreen: 9419919;
	darkslateblue: 4734347;
	darkslategray: 3100495;
	darkslategrey: 3100495;
	darkturquoise: 52945;
	darkviolet: 9699539;
	deeppink: 16716947;
	deepskyblue: 49151;
	dimgray: 6908265;
	dimgrey: 6908265;
	dodgerblue: 2003199;
	firebrick: 11674146;
	floralwhite: 16775920;
	forestgreen: 2263842;
	fuchsia: 16711935;
	gainsboro: 14474460;
	ghostwhite: 16316671;
	gold: 16766720;
	goldenrod: 14329120;
	gray: 8421504;
	green: 32768;
	greenyellow: 11403055;
	grey: 8421504;
	honeydew: 15794160;
	hotpink: 16738740;
	indianred: 13458524;
	indigo: 4915330;
	ivory: 16777200;
	khaki: 15787660;
	lavender: 15132410;
	lavenderblush: 16773365;
	lawngreen: 8190976;
	lemonchiffon: 16775885;
	lightblue: 11393254;
	lightcoral: 15761536;
	lightcyan: 14745599;
	lightgoldenrodyellow: 16448210;
	lightgray: 13882323;
	lightgreen: 9498256;
	lightgrey: 13882323;
	lightpink: 16758465;
	lightsalmon: 16752762;
	lightseagreen: 2142890;
	lightskyblue: 8900346;
	lightslategray: 7833753;
	lightslategrey: 7833753;
	lightsteelblue: 11584734;
	lightyellow: 16777184;
	lime: 65280;
	limegreen: 3329330;
	linen: 16445670;
	magenta: 16711935;
	maroon: 8388608;
	mediumaquamarine: 6737322;
	mediumblue: 205;
	mediumorchid: 12211667;
	mediumpurple: 9662683;
	mediumseagreen: 3978097;
	mediumslateblue: 8087790;
	mediumspringgreen: 64154;
	mediumturquoise: 4772300;
	mediumvioletred: 13047173;
	midnightblue: 1644912;
	mintcream: 16121850;
	mistyrose: 16770273;
	moccasin: 16770229;
	navajowhite: 16768685;
	navy: 128;
	oldlace: 16643558;
	olive: 8421376;
	olivedrab: 7048739;
	orange: 16753920;
	orangered: 16729344;
	orchid: 14315734;
	palegoldenrod: 15657130;
	palegreen: 10025880;
	paleturquoise: 11529966;
	palevioletred: 14381203;
	papayawhip: 16773077;
	peachpuff: 16767673;
	peru: 13468991;
	pink: 16761035;
	plum: 14524637;
	powderblue: 11591910;
	purple: 8388736;
	rebeccapurple: 6697881;
	red: 16711680;
	rosybrown: 12357519;
	royalblue: 4286945;
	saddlebrown: 9127187;
	salmon: 16416882;
	sandybrown: 16032864;
	seagreen: 3050327;
	seashell: 16774638;
	sienna: 10506797;
	silver: 12632256;
	skyblue: 8900331;
	slateblue: 6970061;
	slategray: 7372944;
	slategrey: 7372944;
	snow: 16775930;
	springgreen: 65407;
	steelblue: 4620980;
	tan: 13808780;
	teal: 32896;
	thistle: 14204888;
	tomato: 16737095;
	turquoise: 4251856;
	violet: 15631086;
	wheat: 16113331;
	white: 16777215;
	whitesmoke: 16119285;
	yellow: 16776960;
	yellowgreen: 10145074;
};
export type ColorRepresentation = Color | string | number;
export interface HSL {
	h: number;
	s: number;
	l: number;
}
export interface RGB {
	r: number;
	g: number;
	b: number;
}
declare class Color {
	constructor(color?: ColorRepresentation);
	constructor(r: number, g: number, b: number);
	readonly isColor: true;
	/**
	 * Red channel value between `0.0` and `1.0`. Default is `1`.
	 * @default 1
	 */
	r: number;
	/**
	 * Green channel value between `0.0` and `1.0`. Default is `1`.
	 * @default 1
	 */
	g: number;
	/**
	 * Blue channel value between `0.0` and `1.0`. Default is `1`.
	 * @default 1
	 */
	b: number;
	set(...args: [
		color: ColorRepresentation
	] | [
		r: number,
		g: number,
		b: number
	]): this;
	/**
	 * Sets this color's {@link r}, {@link g} and {@link b} components from the x, y, and z components of the specified
	 * {@link Vector3 | vector}.
	 */
	setFromVector3(vector: Vector3): this;
	setScalar(scalar: number): Color;
	setHex(hex: number, colorSpace?: string): Color;
	/**
	 * Sets this color from RGB values.
	 * @param r Red channel value between 0 and 1.
	 * @param g Green channel value between 0 and 1.
	 * @param b Blue channel value between 0 and 1.
	 */
	setRGB(r: number, g: number, b: number, colorSpace?: string): Color;
	/**
	 * Sets this color from HSL values.
	 * Based on MochiKit implementation by Bob Ippolito.
	 *
	 * @param h Hue channel value between 0 and 1.
	 * @param s Saturation value channel between 0 and 1.
	 * @param l Value channel value between 0 and 1.
	 */
	setHSL(h: number, s: number, l: number, colorSpace?: string): Color;
	/**
	 * Sets this color from a CSS context style string.
	 * @param contextStyle Color in CSS context style format.
	 */
	setStyle(style: string, colorSpace?: string): Color;
	/**
	 * Sets this color from a color name.
	 * Faster than {@link Color#setStyle .setStyle()} method if you don't need the other CSS-style formats.
	 * @param style Color name in X11 format.
	 */
	setColorName(style: string, colorSpace?: string): Color;
	/**
	 * Clones this color.
	 */
	clone(): this;
	/**
	 * Copies given color.
	 * @param color Color to copy.
	 */
	copy(color: Color): this;
	/**
	 * Copies given color making conversion from `SRGBColorSpace` to `LinearSRGBColorSpace`.
	 * @param color Color to copy.
	 */
	copySRGBToLinear(color: Color): Color;
	/**
	 * Copies given color making conversion from `LinearSRGBColorSpace` to `SRGBColorSpace`.
	 * @param color Color to copy.
	 */
	copyLinearToSRGB(color: Color): Color;
	/**
	 * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
	 */
	convertSRGBToLinear(): Color;
	/**
	 * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
	 */
	convertLinearToSRGB(): Color;
	/**
	 * Returns the hexadecimal value of this color.
	 */
	getHex(colorSpace?: string): number;
	/**
	 * Returns the string formatted hexadecimal value of this color.
	 */
	getHexString(colorSpace?: string): string;
	getHSL(target: HSL, colorSpace?: string): HSL;
	getRGB(target: RGB, colorSpace?: string): RGB;
	/**
	 * Returns the value of this color in CSS context style.
	 * Example: rgb(r, g, b)
	 */
	getStyle(colorSpace?: string): string;
	offsetHSL(h: number, s: number, l: number): this;
	add(color: Color): this;
	addColors(color1: Color, color2: Color): this;
	addScalar(s: number): this;
	/**
	 * Applies the transform {@link Matrix3 | m} to this color's RGB components.
	 */
	applyMatrix3(m: Matrix3): this;
	sub(color: Color): this;
	multiply(color: Color): this;
	multiplyScalar(s: number): this;
	lerp(color: Color, alpha: number): this;
	lerpColors(color1: Color, color2: Color, alpha: number): this;
	lerpHSL(color: Color, alpha: number): this;
	equals(color: Color): boolean;
	/**
	 * Sets this color's red, green and blue value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [red, green, blue], or copies red, green and blue into the provided array.
	 * @param array (optional) array to store the color to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	/**
	 * Copies red, green and blue into the provided array-like.
	 * @param array array-like to store the color to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
	/**
	 * This method defines the serialization result of Color.
	 * @return The color as a hexadecimal value.
	 */
	toJSON(): number;
	fromBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, index: number): this;
	[Symbol.iterator](): Generator<number, void>;
	/**
	 * List of X11 color names.
	 */
	static NAMES: typeof _colorKeywords;
}
declare class Cylindrical {
	constructor(radius?: number, theta?: number, y?: number);
	/**
	 * @default 1
	 */
	radius: number;
	/**
	 * @default 0
	 */
	theta: number;
	/**
	 * @default 0
	 */
	y: number;
	clone(): this;
	copy(other: Cylindrical): this;
	set(radius: number, theta: number, y: number): this;
	setFromVector3(vec3: Vector3): this;
	setFromCartesianCoords(x: number, y: number, z: number): this;
}
declare class Spherical {
	constructor(radius?: number, phi?: number, theta?: number);
	/**
	 * @default 1
	 */
	radius: number;
	/**
	 * @default 0
	 */
	phi: number;
	/**
	 * @default 0
	 */
	theta: number;
	set(radius: number, phi: number, theta: number): this;
	clone(): this;
	copy(other: Spherical): this;
	makeSafe(): this;
	setFromVector3(v: Vector3): this;
	setFromCartesianCoords(x: number, y: number, z: number): this;
}
export type Vector3Tuple = [
	number,
	number,
	number
];
export interface Vector3Like {
	readonly x: number;
	readonly y: number;
	readonly z: number;
}
declare class Vector3 {
	constructor(x?: number, y?: number, z?: number);
	/**
	 * @default 0
	 */
	x: number;
	/**
	 * @default 0
	 */
	y: number;
	/**
	 * @default 0
	 */
	z: number;
	readonly isVector3: true;
	/**
	 * Sets value of this vector.
	 */
	set(x: number, y: number, z: number): this;
	/**
	 * Sets all values of this vector.
	 */
	setScalar(scalar: number): this;
	/**
	 * Sets x value of this vector.
	 */
	setX(x: number): this;
	/**
	 * Sets y value of this vector.
	 */
	setY(y: number): this;
	/**
	 * Sets z value of this vector.
	 */
	setZ(z: number): this;
	setComponent(index: number, value: number): this;
	getComponent(index: number): number;
	/**
	 * Clones this vector.
	 */
	clone(): this;
	/**
	 * Copies value of v to this vector.
	 */
	copy(v: Vector3Like): this;
	/**
	 * Adds v to this vector.
	 */
	add(v: Vector3Like): this;
	addScalar(s: number): this;
	/**
	 * Sets this vector to a + b.
	 */
	addVectors(a: Vector3Like, b: Vector3Like): this;
	addScaledVector(v: Vector3, s: number): this;
	/**
	 * Subtracts v from this vector.
	 */
	sub(v: Vector3Like): this;
	subScalar(s: number): this;
	/**
	 * Sets this vector to a - b.
	 */
	subVectors(a: Vector3Like, b: Vector3Like): this;
	multiply(v: Vector3Like): this;
	/**
	 * Multiplies this vector by scalar s.
	 */
	multiplyScalar(s: number): this;
	multiplyVectors(a: Vector3Like, b: Vector3Like): this;
	applyEuler(euler: Euler): this;
	applyAxisAngle(axis: Vector3, angle: number): this;
	applyMatrix3(m: Matrix3): this;
	applyNormalMatrix(m: Matrix3): this;
	applyMatrix4(m: Matrix4): this;
	applyQuaternion(q: QuaternionLike): this;
	project(camera: Camera): this;
	unproject(camera: Camera): this;
	transformDirection(m: Matrix4): this;
	divide(v: Vector3Like): this;
	/**
	 * Divides this vector by scalar s.
	 * Set vector to ( 0, 0, 0 ) if s == 0.
	 */
	divideScalar(s: number): this;
	min(v: Vector3Like): this;
	max(v: Vector3Like): this;
	clamp(min: Vector3Like, max: Vector3Like): this;
	clampScalar(min: number, max: number): this;
	clampLength(min: number, max: number): this;
	floor(): this;
	ceil(): this;
	round(): this;
	roundToZero(): this;
	/**
	 * Inverts this vector.
	 */
	negate(): this;
	/**
	 * Computes dot product of this vector and v.
	 */
	dot(v: Vector3Like): number;
	/**
	 * Computes squared length of this vector.
	 */
	lengthSq(): number;
	/**
	 * Computes length of this vector.
	 */
	length(): number;
	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanLength(): number;
	/**
	 * Normalizes this vector.
	 */
	normalize(): this;
	/**
	 * Normalizes this vector and multiplies it by l.
	 */
	setLength(l: number): this;
	lerp(v: Vector3Like, alpha: number): this;
	lerpVectors(v1: Vector3Like, v2: Vector3Like, alpha: number): this;
	/**
	 * Sets this vector to cross product of itself and v.
	 */
	cross(v: Vector3Like): this;
	/**
	 * Sets this vector to cross product of a and b.
	 */
	crossVectors(a: Vector3Like, b: Vector3Like): this;
	projectOnVector(v: Vector3): this;
	projectOnPlane(planeNormal: Vector3): this;
	reflect(vector: Vector3Like): this;
	angleTo(v: Vector3): number;
	/**
	 * Computes distance of this vector to v.
	 */
	distanceTo(v: Vector3Like): number;
	/**
	 * Computes squared distance of this vector to v.
	 */
	distanceToSquared(v: Vector3Like): number;
	/**
	 * Computes the Manhattan length (distance) from this vector to the given vector v
	 *
	 * see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
	 */
	manhattanDistanceTo(v: Vector3Like): number;
	setFromSpherical(s: Spherical): this;
	setFromSphericalCoords(r: number, phi: number, theta: number): this;
	setFromCylindrical(s: Cylindrical): this;
	setFromCylindricalCoords(radius: number, theta: number, y: number): this;
	setFromMatrixPosition(m: Matrix4): this;
	setFromMatrixScale(m: Matrix4): this;
	setFromMatrixColumn(matrix: Matrix4, index: number): this;
	setFromMatrix3Column(matrix: Matrix3, index: number): this;
	/**
	 * Sets this vector's {@link x}, {@link y} and {@link z} components from the x, y, and z components of the specified {@link Euler Euler Angle}.
	 */
	setFromEuler(e: Euler): this;
	/**
	 * Sets this vector's {@link x}, {@link y} and {@link z} components from the r, g, and b components of the specified
	 * {@link Color | color}.
	 */
	setFromColor(color: RGB): this;
	/**
	 * Checks for strict equality of this vector and v.
	 */
	equals(v: Vector3Like): boolean;
	/**
	 * Sets this vector's x, y and z value from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array [x, y, z], or copies x, y and z into the provided array.
	 * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	toArray(array?: Vector3Tuple, offset?: 0): Vector3Tuple;
	/**
	 * Copies x, y and z into the provided array-like.
	 * @param array array-like to store the vector to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	fromBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, index: number): this;
	/**
	 * Sets this vector's x, y and z from Math.random
	 */
	random(): this;
	randomDirection(): this;
	/**
	 * Iterating through a Vector3 instance will yield its components (x, y, z) in the corresponding order.
	 */
	[Symbol.iterator](): Iterator<number>;
}
declare class Bone<TEventMap extends Object3DEventMap = Object3DEventMap> extends Object3D<TEventMap> {
	/**
	 * Creates a new {@link Bone}.
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link Bone}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isBone: true;
	/**
	 * @override
	 * @defaultValue `Bone`
	 */
	override readonly type: string | "Bone";
}
declare abstract class Interpolant {
	constructor(parameterPositions: any, sampleValues: any, sampleSize: number, resultBuffer?: any);
	parameterPositions: any;
	sampleValues: any;
	valueSize: number;
	resultBuffer: any;
	evaluate(time: number): any;
}
declare class CubicInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
declare class DiscreteInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
declare class LinearInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
export interface KeyframeTrackJSON {
	name: string;
	times: number[];
	values: number[];
	interpolation?: InterpolationModes;
	type: string;
}
declare class KeyframeTrack {
	/**
	 * Converts the keyframe track to JSON.
	 *
	 * @static
	 * @param {KeyframeTrack} track - The keyframe track to serialize.
	 * @return {Object} The serialized keyframe track as JSON.
	 */
	static toJSON(track: KeyframeTrack): KeyframeTrackJSON;
	/**
	 * Constructs a new keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number|string|boolean>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor(name: string, times: ArrayLike<number>, values: ArrayLike<number | string | boolean>, interpolation?: InterpolationModes);
	/**
	 * The track's name can refer to morph targets or bones or
	 * possibly other values within an animated object. See {@link PropertyBinding#parseTrackName}
	 * for the forms of strings that can be parsed for property binding.
	 */
	name: string;
	/**
	 * The keyframe times.
	 */
	times: Float32Array;
	/**
	 * The keyframe values.
	 */
	values: Float32Array;
	/**
	 * Factory method for creating a new discrete interpolant.
	 *
	 * @static
	 * @param {TypedArray} [result] - The result buffer.
	 * @return {DiscreteInterpolant} The new interpolant.
	 */
	InterpolantFactoryMethodDiscrete(result?: TypedArray): DiscreteInterpolant;
	/**
	 * Factory method for creating a new linear interpolant.
	 *
	 * @static
	 * @param {TypedArray} [result] - The result buffer.
	 * @return {LinearInterpolant} The new interpolant.
	 */
	InterpolantFactoryMethodLinear(result?: TypedArray): LinearInterpolant;
	/**
	 * Factory method for creating a new smooth interpolant.
	 *
	 * @static
	 * @param {TypedArray} [result] - The result buffer.
	 * @return {CubicInterpolant} The new interpolant.
	 */
	InterpolantFactoryMethodSmooth(result?: TypedArray): CubicInterpolant;
	/**
	 * Defines the interpolation factor method for this keyframe track.
	 *
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
	 * @return {KeyframeTrack} A reference to this keyframe track.
	 */
	setInterpolation(interpolation: InterpolationModes): KeyframeTrack;
	/**
	 * Returns the current interpolation type.
	 *
	 * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
	 */
	getInterpolation(): InterpolationModes;
	/**
	 * Returns the value size.
	 *
	 * @return {number} The value size.
	 */
	getValueSize(): number;
	/**
	 * Moves all keyframes either forward or backward in time.
	 *
	 * @param {number} timeOffset - The offset to move the time values.
	 * @return {KeyframeTrack} A reference to this keyframe track.
	 */
	shift(timeOffset: number): KeyframeTrack;
	/**
	 * Scale all keyframe times by a factor (useful for frame - seconds conversions).
	 *
	 * @param {number} timeScale - The time scale.
	 * @return {KeyframeTrack} A reference to this keyframe track.
	 */
	scale(timeScale: number): KeyframeTrack;
	/**
	 * Removes keyframes before and after animation without changing any values within the defined time range.
	 *
	 * Note: The method does not shift around keys to the start of the track time, because for interpolated
	 * keys this will change their values
	 *
	 * @param {number} startTime - The start time.
	 * @param {number} endTime - The end time.
	 * @return {KeyframeTrack} A reference to this keyframe track.
	 */
	trim(startTime: number, endTime: number): KeyframeTrack;
	/**
	 * Performs minimal validation on the keyframe track. Returns `true` if the values
	 * are valid.
	 *
	 * @return {boolean} Whether the keyframes are valid or not.
	 */
	validate(): boolean;
	/**
	 * Optimizes this keyframe track by removing equivalent sequential keys (which are
	 * common in morph target sequences).
	 *
	 * @return {AnimationClip} A reference to this animation clip.
	 */
	optimize(): this;
	/**
	 * Returns a new keyframe track with copied values from this instance.
	 *
	 * @return {KeyframeTrack} A clone of this instance.
	 */
	clone(): this;
	/**
	 * The value type name.
	 *
	 * @default ''
	 */
	ValueTypeName: string;
	/**
	 * The time buffer type of this keyframe track.
	 *
	 * @default Float32Array.constructor
	 */
	TimeBufferType: TypedArrayConstructor | ArrayConstructor;
	/**
	 * The value buffer type of this keyframe track.
	 *
	 * @default Float32Array.constructor
	 */
	ValueBufferType: TypedArrayConstructor | ArrayConstructor;
	/**
	 * The default interpolation type of this keyframe track.
	 *
	 * @default InterpolateLinear
	 */
	DefaultInterpolation: InterpolationModes;
}
export interface AnimationClipJSON {
	name: string;
	duration: number;
	tracks: KeyframeTrackJSON[];
	uuid: string;
	blendMode: AnimationBlendMode;
}
export interface MorphTarget {
	name: string;
	vertices: Vector3[];
}
declare class AnimationClip {
	/**
	 * Factory method for creating an animation clip from the given JSON.
	 *
	 * @static
	 * @param {Object} json - The serialized animation clip.
	 * @return {AnimationClip} The new animation clip.
	 */
	static parse(json: AnimationClipJSON): AnimationClip;
	/**
	 * Serializes the given animation clip into JSON.
	 *
	 * @static
	 * @param {AnimationClip} clip - The animation clip to serialize.
	 * @return {Object} The JSON object.
	 */
	static toJSON(clip: AnimationClip): AnimationClipJSON;
	/**
	 * Returns a new animation clip from the passed morph targets array of a
	 * geometry, taking a name and the number of frames per second.
	 *
	 * Note: The fps parameter is required, but the animation speed can be
	 * overridden via {@link AnimationAction#setDuration}.
	 *
	 * @static
	 * @param {string} name - The name of the animation clip.
	 * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.
	 * @param {number} fps - The Frames-Per-Second value.
	 * @param {boolean} noLoop - Whether the clip should be no loop or not.
	 * @return {AnimationClip} The new animation clip.
	 */
	static CreateFromMorphTargetSequence(name: string, morphTargetSequence: Array<MorphTarget>, fps: number, noLoop: boolean): AnimationClip;
	/**
	 * Searches for an animation clip by name, taking as its first parameter
	 * either an array of clips, or a mesh or geometry that contains an
	 * array named "animations" property.
	 *
	 * @static
	 * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
	 * @param {string} name - The name to search for.
	 * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
	 */
	static findByName(objectOrClipArray: Array<AnimationClip> | Object3D, name: string): AnimationClip | null;
	/**
	 * Returns an array of new AnimationClips created from the morph target
	 * sequences of a geometry, trying to sort morph target names into
	 * animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".
	 *
	 * See {@link MD2Loader#parse} as an example for how the method should be used.
	 *
	 * @static
	 * @param {Array<Object>} morphTargets - A sequence of morph targets.
	 * @param {number} fps - The Frames-Per-Second value.
	 * @param {boolean} noLoop - Whether the clip should be no loop or not.
	 * @return {Array<AnimationClip>} An array of new animation clips.
	 */
	static CreateClipsFromMorphTargetSequences(morphTargets: Array<MorphTarget>, fps: number, noLoop: boolean): Array<AnimationClip>;
	/**
	 * Parses the `animation.hierarchy` format and returns a new animation clip.
	 *
	 * @static
	 * @deprecated since r175.
	 * @param {Object} animation - A serialized animation clip as JSON.
	 * @param {Array<Bones>} bones - An array of bones.
	 * @return {?AnimationClip} The new animation clip.
	 */
	static parseAnimation(animation: AnimationClipJSON, bones: Array<Bone>): AnimationClip | null;
	/**
	 * Constructs a new animation clip.
	 *
	 * Note: Instead of instantiating an AnimationClip directly with the constructor, you can
	 * use the static interface of this class for creating clips. In most cases though, animation clips
	 * will automatically be created by loaders when importing animated 3D assets.
	 *
	 * @param {string} [name=''] - The clip's name.
	 * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,
	 * the duration will be calculated from the passed keyframes.
	 * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.
	 * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation
	 * is blended/combined when two or more animations are simultaneously played.
	 */
	constructor(name?: string, duration?: number, tracks?: Array<KeyframeTrack>, blendMode?: AnimationBlendMode);
	/**
	 * The clip's name.
	 */
	name: string;
	/**
	 *  An array of keyframe tracks.
	 */
	tracks: Array<KeyframeTrack>;
	/**
	 * The clip's duration in seconds.
	 */
	duration: number;
	/**
	 * Defines how the animation is blended/combined when two or more animations
	 * are simultaneously played.
	 */
	blendMode: AnimationBlendMode;
	/**
	 * The UUID of the animation clip.
	 */
	readonly uuid: string;
	/**
	 * An object that can be used to store custom data about the animation clip.
	 * It should not hold references to functions as these will not be cloned.
	 */
	userData: Record<string, unknown>;
	/**
	 * Sets the duration of this clip to the duration of its longest keyframe track.
	 *
	 * @return {AnimationClip} A reference to this animation clip.
	 */
	resetDuration(): AnimationClip;
	/**
	 * Trims all tracks to the clip's duration.
	 *
	 * @return {AnimationClip} A reference to this animation clip.
	 */
	trim(): AnimationClip;
	/**
	 * Performs minimal validation on each track in the clip. Returns `true` if all
	 * tracks are valid.
	 *
	 * @return {boolean} Whether the clip's keyframes are valid or not.
	 */
	validate(): boolean;
	/**
	 * Optimizes each track by removing equivalent sequential keys (which are
	 * common in morph target sequences).
	 *
	 * @return {AnimationClip} A reference to this animation clip.
	 */
	optimize(): AnimationClip;
	/**
	 * Returns a new animation clip with copied values from this instance.
	 *
	 * @return {AnimationClip} A clone of this instance.
	 */
	clone(): this;
	/**
	 * Serializes this animation clip into JSON.
	 *
	 * @return {Object} The JSON object.
	 */
	toJSON(): AnimationClipJSON;
}
export interface CurveJSON {
	metadata: {
		version: number;
		type: string;
		generator: string;
	};
	arcLengthDivisions: number;
	type: string;
}
declare abstract class Curve<TVector extends Vector2 | Vector3> {
	protected constructor();
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `Curve`
	 */
	readonly type: string | "Curve";
	/**
	 * This value determines the amount of divisions when calculating the cumulative segment lengths of a {@link Curve}
	 * via {@link .getLengths}.
	 * To ensure precision when using methods like {@link .getSpacedPoints}, it is recommended to increase {@link .arcLengthDivisions} if the {@link Curve} is very large.
	 * @defaultValue `200`
	 * @remarks Expects a `Integer`
	 */
	arcLengthDivisions: number;
	/**
	 * Returns a vector for a given position on the curve.
	 * @param t A position on the curve. Must be in the range `[ 0, 1 ]`. Expects a `Float`
	 * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created. Default `new T`.
	 */
	getPoint(t: number, optionalTarget?: TVector): TVector;
	/**
	 * Returns a vector for a given position on the {@link Curve} according to the arc length.
	 * @param u A position on the {@link Curve} according to the arc length. Must be in the range `[ 0, 1 ]`. Expects a `Float`
	 * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created. Default `new T`.
	 */
	getPointAt(u: number, optionalTarget?: TVector): TVector;
	/**
	 * Returns a set of divisions `+1` points using {@link .getPoint | getPoint(t)}.
	 * @param divisions Number of pieces to divide the {@link Curve} into. Expects a `Integer`. Default `5`
	 */
	getPoints(divisions?: number): TVector[];
	/**
	 * Returns a set of divisions `+1` equi-spaced points using {@link .getPointAt | getPointAt(u)}.
	 * @param divisions Number of pieces to divide the {@link Curve} into. Expects a `Integer`. Default `5`
	 */
	getSpacedPoints(divisions?: number): TVector[];
	/**
	 * Get total {@link Curve} arc length.
	 */
	getLength(): number;
	/**
	 * Get list of cumulative segment lengths.
	 * @param divisions Expects a `Integer`
	 */
	getLengths(divisions?: number): number[];
	/**
	 * Update the cumulative segment distance cache
	 * @remarks
	 * The method must be called every time {@link Curve} parameters are changed
	 * If an updated {@link Curve} is part of a composed {@link Curve} like {@link THREE.CurvePath | CurvePath},
	 * {@link .updateArcLengths}() must be called on the composed curve, too.
	 */
	updateArcLengths(): void;
	/**
	 * Given u in the range `[ 0, 1 ]`,
	 * @remarks
	 * `u` and `t` can then be used to give you points which are equidistant from the ends of the curve, using {@link .getPoint}.
	 * @param u Expects a `Float`
	 * @param distance Expects a `Float`
	 * @returns `t` also in the range `[ 0, 1 ]`. Expects a `Float`.
	 */
	getUtoTmapping(u: number, distance: number): number;
	/**
	 * Returns a unit vector tangent at t
	 * @remarks
	 * If the derived {@link Curve} does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation.
	 * @param t A position on the curve. Must be in the range `[ 0, 1 ]`. Expects a `Float`
	 * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created.
	 */
	getTangent(t: number, optionalTarget?: TVector): TVector;
	/**
	 * Returns tangent at a point which is equidistant to the ends of the {@link Curve} from the point given in {@link .getTangent}.
	 * @param u A position on the {@link Curve} according to the arc length. Must be in the range `[ 0, 1 ]`. Expects a `Float`
	 * @param optionalTarget If specified, the result will be copied into this Vector, otherwise a new Vector will be created.
	 */
	getTangentAt(u: number, optionalTarget?: TVector): TVector;
	/**
	 * Generates the Frenet Frames
	 * @remarks
	 * Requires a {@link Curve} definition in 3D space
	 * Used in geometries like {@link THREE.TubeGeometry | TubeGeometry} or {@link THREE.ExtrudeGeometry | ExtrudeGeometry}.
	 * @param segments Expects a `Integer`
	 * @param closed
	 */
	computeFrenetFrames(segments: number, closed?: boolean): {
		tangents: Vector3[];
		normals: Vector3[];
		binormals: Vector3[];
	};
	/**
	 * Creates a clone of this instance.
	 */
	clone(): this;
	/**
	 * Copies another {@link Curve} object to this instance.
	 * @param source
	 */
	copy(source: Curve<TVector>): this;
	/**
	 * Returns a JSON object representation of this instance.
	 */
	toJSON(): CurveJSON;
	/**
	 * Copies the data from the given JSON object to this instance.
	 * @param json
	 */
	fromJSON(json: CurveJSON): this;
}
export interface CurvePathJSON extends CurveJSON {
	autoClose: boolean;
	curves: CurveJSON[];
}
declare class CurvePath<TVector extends Vector2 | Vector3> extends Curve<TVector> {
	/**
	 * The constructor take no parameters.
	 */
	constructor();
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `CurvePath`
	 */
	override readonly type: string | "CurvePath";
	/**
	 * The array of {@link Curve | Curves}.
	 * @defaultValue `[]`
	 */
	curves: Array<Curve<TVector>>;
	/**
	 * Whether or not to automatically close the path.
	 * @defaultValue false
	 */
	autoClose: boolean;
	/**
	 * Add a curve to the {@link .curves} array.
	 * @param curve
	 */
	add(curve: Curve<TVector>): void;
	/**
	 * Adds a {@link LineCurve | lineCurve} to close the path.
	 */
	closePath(): this;
	getPoint(t: number, optionalTarget?: TVector): TVector;
	/**
	 * Get list of cumulative curve lengths of the curves in the {@link .curves} array.
	 */
	getCurveLengths(): number[];
	/**
	 * Returns an array of points representing a sequence of curves
	 * @remarks
	 * The `division` parameter defines the number of pieces each curve is divided into
	 * However, for optimization and quality purposes, the actual sampling resolution for each curve depends on its type
	 * For example, for a {@link THREE.LineCurve | LineCurve}, the returned number of points is always just 2.
	 * @param divisions Number of pieces to divide the curve into. Expects a `Integer`. Default `12`
	 */
	override getPoints(divisions?: number): TVector[];
	/**
	 * Returns a set of divisions `+1` equi-spaced points using {@link .getPointAt | getPointAt(u)}.
	 * @param divisions Number of pieces to divide the curve into. Expects a `Integer`. Default `40`
	 */
	override getSpacedPoints(divisions?: number): TVector[];
	toJSON(): CurvePathJSON;
	fromJSON(json: CurvePathJSON): this;
}
export interface PathJSON extends CurvePathJSON {
	currentPoint: Vector2Tuple;
}
declare class Path extends CurvePath<Vector2> {
	/**
	 * Creates a {@link Path} from the points
	 * @remarks
	 * The first point defines the offset, then successive points are added to the {@link CurvePath.curves | curves} array as {@link LineCurve | LineCurves}.
	 * If no points are specified, an empty {@link Path} is created and the {@link .currentPoint} is set to the origin.
	 * @param points Array of {@link Vector2 | Vector2s}.
	 */
	constructor(points?: Vector2[]);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `Path`
	 */
	override readonly type: string | "Path";
	/**
	 * The current offset of the path. Any new {@link THREE.Curve | Curve} added will start here.
	 * @defaultValue `new THREE.Vector2()`
	 */
	currentPoint: Vector2;
	/**
	 * Adds an absolutely positioned {@link THREE.EllipseCurve | EllipseCurve} to the path.
	 * @param x Expects a `Float`
	 * @param y X, The absolute center of the arc. Expects a `Float`
	 * @param radius The radius of the arc. Expects a `Float`
	 * @param startAngle The start angle in radians. Expects a `Float`
	 * @param endAngle The end angle in radians. Expects a `Float`
	 * @param clockwise Sweep the arc clockwise. Default `false`
	 */
	absarc(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise?: boolean): this;
	/**
	 * Adds an absolutely positioned {@link THREE.EllipseCurve | EllipseCurve} to the path.
	 * @param x Expects a `Float`
	 * @param y X, The absolute center of the ellipse. Expects a `Float`
	 * @param xRadius The radius of the ellipse in the x axis. Expects a `Float`
	 * @param yRadius The radius of the ellipse in the y axis. Expects a `Float`
	 * @param startAngle The start angle in radians. Expects a `Float`
	 * @param endAngle The end angle in radians. Expects a `Float`
	 * @param clockwise Sweep the ellipse clockwise. Default `false`
	 * @param rotation The rotation angle of the ellipse in radians, counterclockwise from the positive X axis. Optional, Expects a `Float`. Default `0`
	 */
	absellipse(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise?: boolean, aRotation?: number): this;
	/**
	 * Adds an {@link THREE.EllipseCurve | EllipseCurve} to the path, positioned relative to {@link .currentPoint}.
	 * @param x Expects a `Float`
	 * @param y X, The center of the arc offset from the last call. Expects a `Float`
	 * @param radius The radius of the arc. Expects a `Float`
	 * @param startAngle The start angle in radians. Expects a `Float`
	 * @param endAngle The end angle in radians. Expects a `Float`
	 * @param clockwise Sweep the arc clockwise. Default `false`
	 */
	arc(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise?: boolean): this;
	/**
	 * This creates a bezier curve from {@link .currentPoint} with (cp1X, cp1Y) and (cp2X, cp2Y) as control points and updates {@link .currentPoint} to x and y.
	 * @param cp1X Expects a `Float`
	 * @param cp1Y Expects a `Float`
	 * @param cp2X Expects a `Float`
	 * @param cp2Y Expects a `Float`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	bezierCurveTo(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number): this;
	/**
	 * Adds an {@link THREE.EllipseCurve | EllipseCurve} to the path, positioned relative to {@link .currentPoint}.
	 * @param x Expects a `Float`
	 * @param y X, The center of the ellipse offset from the last call. Expects a `Float`
	 * @param xRadius The radius of the ellipse in the x axis. Expects a `Float`
	 * @param yRadius The radius of the ellipse in the y axis. Expects a `Float`
	 * @param startAngle The start angle in radians. Expects a `Float`
	 * @param endAngle The end angle in radians. Expects a `Float`
	 * @param clockwise Sweep the ellipse clockwise. Default `false`
	 * @param rotation The rotation angle of the ellipse in radians, counterclockwise from the positive X axis. Optional, Expects a `Float`. Default `0`
	 */
	ellipse(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise?: boolean, aRotation?: number): this;
	/**
	 * Connects a {@link THREE.LineCurve | LineCurve} from {@link .currentPoint} to x, y onto the path.
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	lineTo(x: number, y: number): this;
	/**
	 * Move the {@link .currentPoint} to x, y.
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	moveTo(x: number, y: number): this;
	/**
	 * Creates a quadratic curve from {@link .currentPoint} with cpX and cpY as control point and updates {@link .currentPoint} to x and y.
	 * @param cpX Expects a `Float`
	 * @param cpY Expects a `Float`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): this;
	/**
	 * Points are added to the {@link CurvePath.curves | curves} array as {@link THREE.LineCurve | LineCurves}.
	 * @param vector2s
	 */
	setFromPoints(vectors: Vector2[]): this;
	/**
	 * Connects a new {@link THREE.SplineCurve | SplineCurve} onto the path.
	 * @param points An array of {@link Vector2 | Vector2's}
	 */
	splineThru(pts: Vector2[]): this;
	toJSON(): PathJSON;
	fromJSON(json: PathJSON): this;
}
export interface ShapeJSON extends PathJSON {
	uuid: string;
	holes: PathJSON[];
}
declare class Shape extends Path {
	/**
	 * Creates a {@link Shape} from the points
	 * @remarks
	 * The first point defines the offset, then successive points are added to the {@link CurvePath.curves | curves} array as {@link THREE.LineCurve | LineCurves}.
	 * If no points are specified, an empty {@link Shape} is created and the {@link .currentPoint} is set to the origin.
	 * @param points Array of {@link Vector2 | Vector2s}.
	 */
	constructor(points?: Vector2[]);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `Shape`
	 */
	override readonly type: string | "Shape";
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * An array of {@link Path | paths} that define the holes in the shape.
	 * @defaultValue `[]`
	 */
	holes: Path[];
	/**
	 * Call {@link THREE.Curve.getPoints | getPoints} on the {@link Shape} and the {@link holes} array
	 * @param divisions The fineness of the result. Expects a `Integer`
	 */
	extractPoints(divisions: number): {
		shape: Vector2[];
		holes: Vector2[][];
	};
	/**
	 * Get an array of {@link Vector2 | Vector2's} that represent the holes in the shape.
	 * @param divisions The fineness of the result. Expects a `Integer`
	 */
	getPointsHoles(divisions: number): Vector2[][];
	toJSON(): ShapeJSON;
	fromJSON(json: ShapeJSON): this;
}
declare class Line3 {
	constructor(start?: Vector3, end?: Vector3);
	/**
	 * @default new THREE.Vector3()
	 */
	start: Vector3;
	/**
	 * @default new THREE.Vector3()
	 */
	end: Vector3;
	set(start?: Vector3, end?: Vector3): Line3;
	clone(): this;
	copy(line: Line3): this;
	getCenter(target: Vector3): Vector3;
	delta(target: Vector3): Vector3;
	distanceSq(): number;
	distance(): number;
	at(t: number, target: Vector3): Vector3;
	closestPointToPointParameter(point: Vector3, clampToLine?: boolean): number;
	closestPointToPoint(point: Vector3, clampToLine: boolean, target: Vector3): Vector3;
	distanceSqToLine3(line: Line3, c1?: Vector3, c2?: Vector3): number;
	applyMatrix4(matrix: Matrix4): Line3;
	equals(line: Line3): boolean;
}
declare class Sphere {
	constructor(center?: Vector3, radius?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link Sphere}.
	 */
	readonly isSphere: true;
	/**
	 * @default new Vector3()
	 */
	center: Vector3;
	/**
	 * @default 1
	 */
	radius: number;
	set(center: Vector3, radius: number): Sphere;
	setFromPoints(points: Vector3[], optionalCenter?: Vector3): Sphere;
	clone(): this;
	copy(sphere: Sphere): this;
	expandByPoint(point: Vector3): this;
	isEmpty(): boolean;
	makeEmpty(): this;
	containsPoint(point: Vector3): boolean;
	distanceToPoint(point: Vector3): number;
	intersectsSphere(sphere: Sphere): boolean;
	intersectsBox(box: Box3): boolean;
	intersectsPlane(plane: Plane): boolean;
	clampPoint(point: Vector3, target: Vector3): Vector3;
	getBoundingBox(target: Box3): Box3;
	applyMatrix4(matrix: Matrix4): Sphere;
	translate(offset: Vector3): Sphere;
	equals(sphere: Sphere): boolean;
	union(sphere: Sphere): this;
	/**
	 * @deprecated Use {@link Sphere#isEmpty .isEmpty()} instead.
	 */
	empty(): any;
	toJSON(): SphereJSON;
	fromJSON(json: SphereJSON): this;
}
export interface SphereJSON {
	radius: number;
	center: number[];
}
declare class Plane {
	constructor(normal?: Vector3, constant?: number);
	/**
	 * @default new THREE.Vector3( 1, 0, 0 )
	 */
	normal: Vector3;
	/**
	 * @default 0
	 */
	constant: number;
	readonly isPlane: true;
	set(normal: Vector3, constant: number): Plane;
	setComponents(x: number, y: number, z: number, w: number): Plane;
	setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3): Plane;
	setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3): Plane;
	clone(): this;
	copy(plane: Plane): this;
	normalize(): Plane;
	negate(): Plane;
	distanceToPoint(point: Vector3): number;
	distanceToSphere(sphere: Sphere): number;
	projectPoint(point: Vector3, target: Vector3): Vector3;
	intersectLine(line: Line3, target: Vector3): Vector3 | null;
	intersectsLine(line: Line3): boolean;
	intersectsBox(box: Box3): boolean;
	intersectsSphere(sphere: Sphere): boolean;
	coplanarPoint(target: Vector3): Vector3;
	applyMatrix4(matrix: Matrix4, optionalNormalMatrix?: Matrix3): Plane;
	translate(offset: Vector3): Plane;
	equals(plane: Plane): boolean;
	/**
	 * @deprecated Use {@link Plane#intersectsLine .intersectsLine()} instead.
	 */
	isIntersectionLine(l: any): any;
}
declare class Triangle {
	constructor(a?: Vector3, b?: Vector3, c?: Vector3);
	/**
	 * @default new THREE.Vector3()
	 */
	a: Vector3;
	/**
	 * @default new THREE.Vector3()
	 */
	b: Vector3;
	/**
	 * @default new THREE.Vector3()
	 */
	c: Vector3;
	set(a: Vector3, b: Vector3, c: Vector3): Triangle;
	setFromPointsAndIndices(points: Vector3[], i0: number, i1: number, i2: number): this;
	setFromAttributeAndIndices(attribute: BufferAttribute | InterleavedBufferAttribute, i0: number, i1: number, i2: number): this;
	clone(): this;
	copy(triangle: Triangle): this;
	getArea(): number;
	getMidpoint(target: Vector3): Vector3;
	getNormal(target: Vector3): Vector3;
	getPlane(target: Plane): Plane;
	getBarycoord(point: Vector3, target: Vector3): Vector3 | null;
	getInterpolation(point: Vector3, v1: Vector2, v2: Vector2, v3: Vector2, target: Vector2): Vector2 | null;
	getInterpolation(point: Vector3, v1: Vector3, v2: Vector3, v3: Vector3, target: Vector3): Vector3 | null;
	getInterpolation(point: Vector3, v1: Vector4, v2: Vector4, v3: Vector4, target: Vector4): Vector4 | null;
	containsPoint(point: Vector3): boolean;
	intersectsBox(box: Box3): boolean;
	isFrontFacing(direction: Vector3): boolean;
	closestPointToPoint(point: Vector3, target: Vector3): Vector3;
	equals(triangle: Triangle): boolean;
	static getNormal(a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3;
	static getBarycoord(point: Vector3, a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3 | null;
	static containsPoint(point: Vector3, a: Vector3, b: Vector3, c: Vector3): boolean;
	static getInterpolation(point: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, v1: Vector2, v2: Vector2, v3: Vector2, target: Vector2): Vector2 | null;
	static getInterpolation(point: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, v1: Vector3, v2: Vector3, v3: Vector3, target: Vector3): Vector3 | null;
	static getInterpolation(point: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, v1: Vector4, v2: Vector4, v3: Vector4, target: Vector4): Vector4 | null;
	static getInterpolatedAttribute(attr: BufferAttribute | InterleavedBufferAttribute, i1: number, i2: number, i3: number, barycoord: Vector3, target: Vector2): Vector2;
	static getInterpolatedAttribute(attr: BufferAttribute | InterleavedBufferAttribute, i1: number, i2: number, i3: number, barycoord: Vector3, target: Vector3): Vector3;
	static getInterpolatedAttribute(attr: BufferAttribute | InterleavedBufferAttribute, i1: number, i2: number, i3: number, barycoord: Vector3, target: Vector4): Vector4;
	static isFrontFacing(a: Vector3, b: Vector3, c: Vector3, direction: Vector3): boolean;
}
declare class Box3 {
	constructor(min?: Vector3, max?: Vector3);
	/**
	 * @default new THREE.Vector3( + Infinity, + Infinity, + Infinity )
	 */
	min: Vector3;
	/**
	 * @default new THREE.Vector3( - Infinity, - Infinity, - Infinity )
	 */
	max: Vector3;
	readonly isBox3: true;
	set(min: Vector3, max: Vector3): this;
	setFromArray(array: ArrayLike<number>): this;
	setFromBufferAttribute(bufferAttribute: BufferAttribute): this;
	setFromPoints(points: Vector3[]): this;
	setFromCenterAndSize(center: Vector3, size: Vector3): this;
	setFromObject(object: Object3D, precise?: boolean): this;
	clone(): this;
	copy(box: Box3): this;
	makeEmpty(): this;
	isEmpty(): boolean;
	getCenter(target: Vector3): Vector3;
	getSize(target: Vector3): Vector3;
	expandByPoint(point: Vector3): this;
	expandByVector(vector: Vector3): this;
	expandByScalar(scalar: number): this;
	expandByObject(object: Object3D, precise?: boolean): this;
	containsPoint(point: Vector3): boolean;
	containsBox(box: Box3): boolean;
	getParameter(point: Vector3, target: Vector3): Vector3;
	intersectsBox(box: Box3): boolean;
	intersectsSphere(sphere: Sphere): boolean;
	intersectsPlane(plane: Plane): boolean;
	intersectsTriangle(triangle: Triangle): boolean;
	clampPoint(point: Vector3, target: Vector3): Vector3;
	distanceToPoint(point: Vector3): number;
	getBoundingSphere(target: Sphere): Sphere;
	intersect(box: Box3): this;
	union(box: Box3): this;
	applyMatrix4(matrix: Matrix4): this;
	translate(offset: Vector3): this;
	equals(box: Box3): boolean;
	/**
	 * @deprecated Use {@link Box3#isEmpty .isEmpty()} instead.
	 */
	empty(): any;
	/**
	 * @deprecated Use {@link Box3#intersectsBox .intersectsBox()} instead.
	 */
	isIntersectionBox(b: any): any;
	/**
	 * @deprecated Use {@link Box3#intersectsSphere .intersectsSphere()} instead.
	 */
	isIntersectionSphere(s: any): any;
	toJSON(): Box3JSON;
	fromJSON(json: Box3JSON): this;
}
export interface Box3JSON {
	min: number[];
	max: number[];
}
declare class StorageBufferAttribute extends BufferAttribute {
	readonly isStorageBufferAttribute: true;
	constructor(array: TypedArray | number, itemSize: number);
}
declare class IndirectStorageBufferAttribute extends StorageBufferAttribute {
	readonly isIndirectStorageBufferAttribute: true;
	constructor(array: TypedArray, itemSize: number);
}
/**
 * The minimal basic Event that can be dispatched by a {@link EventDispatcher<>}.
 */
export interface BaseEvent<TEventType extends string = string> {
	readonly type: TEventType;
}
interface Event$1<TEventType extends string = string, TTarget = unknown> {
	readonly type: TEventType;
	readonly target: TTarget;
}
type EventListener$1<TEventData, TEventType extends string, TTarget> = (event: TEventData & Event$1<TEventType, TTarget>) => void;
declare class EventDispatcher<TEventMap extends {} = {}> {
	/**
	 * Creates {@link THREE.EventDispatcher | EventDispatcher} object.
	 */
	constructor();
	/**
	 * Adds a listener to an event type.
	 * @param type The type of event to listen to.
	 * @param listener The function that gets called when the event is fired.
	 */
	addEventListener<T extends Extract<keyof TEventMap, string>>(type: T, listener: EventListener$1<TEventMap[T], T, this>): void;
	/**
	 * Checks if listener is added to an event type.
	 * @param type The type of event to listen to.
	 * @param listener The function that gets called when the event is fired.
	 */
	hasEventListener<T extends Extract<keyof TEventMap, string>>(type: T, listener: EventListener$1<TEventMap[T], T, this>): boolean;
	/**
	 * Removes a listener from an event type.
	 * @param type The type of the listener that gets removed.
	 * @param listener The listener function that gets removed.
	 */
	removeEventListener<T extends Extract<keyof TEventMap, string>>(type: T, listener: EventListener$1<TEventMap[T], T, this>): void;
	/**
	 * Fire an event type.
	 * @param event The event that gets fired.
	 */
	dispatchEvent<T extends Extract<keyof TEventMap, string>>(event: BaseEvent<T> & TEventMap[T]): void;
}
declare class GLBufferAttribute {
	/**
	 * This creates a new GLBufferAttribute object.
	 * @param buffer Must be a {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer | WebGLBuffer}. See {@link GLBufferAttribute.buffer | .buffer}
	 * @param type One of {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Data_types | WebGL Data Types}. See {@link GLBufferAttribute.type | .type}
	 * @param itemSize How many values make up each item (vertex). See {@link GLBufferAttribute.itemSize | .itemSize}
	 * @param elementSize `1`, `2` or `4`. The corresponding size (in bytes) for the given {@link type} param. See {@link GLBufferAttribute.elementSize | .elementSize}
	 * @param count The expected number of vertices in VBO. See {@link GLBufferAttribute.count | .count}
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor(buffer: WebGLBuffer, type: GLenum, itemSize: number, elementSize: 1 | 2 | 4, count: number, normalized?: boolean);
	/**
	 * Read-only flag to check if a given object is of type {@link GLBufferAttribute}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isGLBufferAttribute: true;
	/**
	 * Optional name for this attribute instance.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * The current {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer | WebGLBuffer} instance.
	 */
	buffer: WebGLBuffer;
	/**
	 * A {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Data_types | WebGL Data Type} describing the underlying VBO contents.
	 *
	 * #### WebGL Data Type (`GLenum`)
	 * - gl.BYTE: 0x1400
	 * - gl.UNSIGNED_BYTE: 0x1401
	 * - gl.SHORT: 0x1402
	 * - gl.UNSIGNED_SHORT: 0x1403
	 * - gl.INT: 0x1404
	 * - gl.UNSIGNED_INT: 0x1405
	 * - gl.FLOAT: 0x1406
	 * @remarks Set this property together with {@link elementSize | .elementSize}. The recommended way is using the {@link setType | .setType()} method.
	 * @remarks Expects a `DataType` `GLenum` _possible values:_ `0x1400` `0x1401` `0x1402` `0x1403` `0x1404` `0x1405` `0x1406`
	 */
	type: GLenum;
	/**
	 * How many values make up each item (vertex).
	 * @remarks The number of values of the array that should be associated with a particular vertex.
	 * For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then itemSize should be 3.
	 * @remarks Expects a `Integer`
	 */
	itemSize: number;
	/**
	 * Stores the corresponding size in bytes for the current {@link type | .type} property value.
	 *
	 * The corresponding size (_in bytes_) for the given "type" param.
	 * #### WebGL Data Type (`GLenum`)
	 * - gl.BYTE: 1
	 * - gl.UNSIGNED_BYTE: 1
	 * - gl.SHORT: 2
	 * - gl.UNSIGNED_SHORT: 2
	 * - gl.INT: 4
	 * - gl.UNSIGNED_INT: 4
	 * - gl.FLOAT: 4
	 * @remarks Set this property together with {@link type | .type}. The recommended way is using the {@link setType | .setType} method.
	 * @see `constructor`` for a list of known type sizes.
	 * @remarks Expects a `1`, `2` or `4`
	 */
	elementSize: 1 | 2 | 4;
	/**
	 * The expected number of vertices in VBO.
	 * @remarks Expects a `Integer`
	 */
	count: number;
	/**
	 * Applies to integer data only. Indicates how the underlying data in the buffer maps to
	 * the values in the GLSL code. For instance, if `buffer` contains data of `gl.UNSIGNED_SHORT`,
	 * and `normalized` is `true`, the values `0 - +65535` in the buffer data will be mapped to
	 * `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
	 * to floats unmodified, i.e. `65535` becomes `65535.0f`.
	 */
	normalized: boolean;
	/**
	 * A version number, incremented every time the needsUpdate property is set to true.
	 * @remarks Expects a `Integer`
	 */
	version: number;
	/**
	 * Setting this to true increments {@link version | .version}.
	 * @remarks _set-only property_.
	 */
	set needsUpdate(value: boolean);
	/**
	 * Sets the {@link buffer | .buffer} property.
	 */
	setBuffer(buffer: WebGLBuffer): this;
	/**
	 * Sets the both {@link GLBufferAttribute.type | type} and {@link GLBufferAttribute.elementSize | elementSize} properties.
	 */
	setType(type: GLenum, elementSize: 1 | 2 | 4): this;
	/**
	 * Sets the {@link GLBufferAttribute.itemSize | itemSize} property.
	 */
	setItemSize(itemSize: number): this;
	/**
	 * Sets the {@link GLBufferAttribute.count | count} property.
	 */
	setCount(count: number): this;
}
export type NormalBufferAttributes = Record<string, BufferAttribute | InterleavedBufferAttribute>;
export type NormalOrGLBufferAttributes = Record<string, BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute>;
export interface BufferGeometryJSON {
	metadata?: {
		version: number;
		type: string;
		generator: string;
	};
	uuid: string;
	type: string;
	name?: string;
	userData?: Record<string, unknown>;
	data?: {
		attributes: Record<string, BufferAttributeJSON>;
		index?: {
			type: string;
			array: number[];
		};
		morphAttributes?: Record<string, BufferAttributeJSON[]>;
		morphTargetsRelative?: boolean;
		groups?: GeometryGroup[];
		boundingSphere?: {
			center: Vector3Tuple;
			radius: number;
		};
	};
}
export interface GeometryGroup {
	/**
	 * Specifies the first element in this draw call – the first vertex for non-indexed geometry, otherwise the first triangle index.
	 * @remarks Expects a `Integer`
	 */
	start: number;
	/**
	 * Specifies how many vertices (or indices) are included.
	 * @remarks Expects a `Integer`
	 */
	count: number;
	/**
	 * Specifies the material array index to use.
	 * @remarks Expects a `Integer`
	 */
	materialIndex?: number | undefined;
}
export interface BufferGeometryEventMap {
	dispose: {};
}
declare class BufferGeometry<Attributes extends NormalOrGLBufferAttributes = NormalBufferAttributes, TEventMap extends BufferGeometryEventMap = BufferGeometryEventMap> extends EventDispatcher<TEventMap> {
	/**
	 * This creates a new {@link THREE.BufferGeometry | BufferGeometry} object.
	 */
	constructor();
	/**
	 * Unique number for this {@link THREE.BufferGeometry | BufferGeometry} instance.
	 * @remarks Expects a `Integer`
	 */
	id: number;
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * Optional name for this {@link THREE.BufferGeometry | BufferGeometry} instance.
	 * @defaultValue `''`
	 */
	name: string;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `BufferGeometry`
	 */
	readonly type: string | "BufferGeometry";
	/**
	 * Allows for vertices to be re-used across multiple triangles; this is called using "indexed triangles".
	 * Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face.
	 * If this attribute is not set, the {@link THREE.WebGLRenderer | renderer}  assumes that each three contiguous positions represent a single triangle.
	 * @defaultValue `null`
	 */
	index: BufferAttribute | null;
	indirect: IndirectStorageBufferAttribute | null;
	indirectOffset: number | number[];
	/**
	 * This hashmap has as id the name of the attribute to be set and as value the {@link THREE.BufferAttribute | buffer} to set it to. Rather than accessing this property directly,
	 * use {@link setAttribute | .setAttribute} and {@link getAttribute | .getAttribute} to access attributes of this geometry.
	 * @defaultValue `{}`
	 */
	attributes: Attributes;
	/**
	 * Hashmap of {@link THREE.BufferAttribute | BufferAttributes} holding details of the geometry's morph targets.
	 * @remarks
	 * Once the geometry has been rendered, the morph attribute data cannot be changed.
	 * You will have to call {@link dispose | .dispose}(), and create a new instance of {@link THREE.BufferGeometry | BufferGeometry}.
	 * @defaultValue `{}`
	 */
	morphAttributes: {
		position?: Array<BufferAttribute | InterleavedBufferAttribute> | undefined;
		normal?: Array<BufferAttribute | InterleavedBufferAttribute> | undefined;
		color?: Array<BufferAttribute | InterleavedBufferAttribute> | undefined;
	};
	/**
	 * Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals.
	 * @defaultValue `false`
	 */
	morphTargetsRelative: boolean;
	/**
	 * Split the geometry into groups, each of which will be rendered in a separate WebGL draw call. This allows an array of materials to be used with the geometry.
	 * @remarks Every vertex and index must belong to exactly one group — groups must not share vertices or indices, and must not leave vertices or indices unused.
	 * @remarks Use {@link addGroup | .addGroup} to add groups, rather than modifying this array directly.
	 * @defaultValue `[]`
	 */
	groups: GeometryGroup[];
	/**
	 * Bounding box for the {@link THREE.BufferGeometry | BufferGeometry}, which can be calculated with {@link computeBoundingBox | .computeBoundingBox()}.
	 * @remarks Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 * @defaultValue `null`
	 */
	boundingBox: Box3 | null;
	/**
	 * Bounding sphere for the {@link THREE.BufferGeometry | BufferGeometry}, which can be calculated with {@link computeBoundingSphere | .computeBoundingSphere()}.
	 * @remarks bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 * @defaultValue `null`
	 */
	boundingSphere: Sphere | null;
	/**
	 * Determines the part of the geometry to render. This should not be set directly, instead use {@link setDrawRange | .setDrawRange(...)}.
	 * @remarks For non-indexed {@link THREE.BufferGeometry | BufferGeometry}, count is the number of vertices to render.
	 * @remarks For indexed {@link THREE.BufferGeometry | BufferGeometry}, count is the number of indices to render.
	 * @defaultValue `{ start: 0, count: Infinity }`
	 */
	drawRange: {
		start: number;
		count: number;
	};
	/**
	 * An object that can be used to store custom data about the BufferGeometry. It should not hold references to functions as these will not be cloned.
	 * @defaultValue `{}`
	 */
	userData: Record<string, any>;
	/**
	 * Read-only flag to check if a given object is of type {@link BufferGeometry}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isBufferGeometry: true;
	/**
	 * Return the {@link index | .index} buffer.
	 */
	getIndex(): BufferAttribute | null;
	/**
	 * Set the {@link THREE.BufferGeometry.index | .index} buffer.
	 * @param index
	 */
	setIndex(index: BufferAttribute | number[] | null): this;
	setIndirect(indirect: IndirectStorageBufferAttribute | null, indirectOffset?: number | number[]): this;
	getIndirect(): IndirectStorageBufferAttribute | null;
	/**
	 * Sets an {@link attributes | attribute} to this geometry with the specified name.
	 * @remarks
	 * Use this rather than the attributes property, because an internal hashmap of {@link attributes | .attributes} is maintained to speed up iterating over attributes.
	 * @param name
	 * @param attribute
	 */
	setAttribute<K extends keyof Attributes>(name: K, attribute: Attributes[K]): this;
	/**
	 * Returns the {@link attributes | attribute} with the specified name.
	 * @param name
	 */
	getAttribute<K extends keyof Attributes>(name: K): Attributes[K];
	/**
	 * Deletes the  {@link attributes | attribute} with the specified name.
	 * @param name
	 */
	deleteAttribute(name: keyof Attributes): this;
	/**
	 * Returns true if the {@link attributes | attribute} with the specified name exists.
	 * @param name
	 */
	hasAttribute(name: keyof Attributes): boolean;
	/**
	 * Adds a group to this geometry
	 * @see the {@link BufferGeometry.groups | groups} property for details.
	 * @param start
	 * @param count
	 * @param materialIndex
	 */
	addGroup(start: number, count: number, materialIndex?: number): void;
	/**
	 * Clears all groups.
	 */
	clearGroups(): void;
	/**
	 * Set the {@link drawRange | .drawRange} property
	 * @remarks For non-indexed BufferGeometry, count is the number of vertices to render
	 * @remarks For indexed BufferGeometry, count is the number of indices to render.
	 * @param start
	 * @param count is the number of vertices or indices to render. Expects a `Integer`
	 */
	setDrawRange(start: number, count: number): void;
	/**
	 * Applies the matrix transform to the geometry.
	 * @param matrix
	 */
	applyMatrix4(matrix: Matrix4): this;
	/**
	 * Applies the rotation represented by the quaternion to the geometry.
	 * @param quaternion
	 */
	applyQuaternion(quaternion: Quaternion): this;
	/**
	 * Rotate the geometry about the X axis. This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link THREE.Object3D.rotation | Object3D.rotation} for typical real-time mesh rotation.
	 * @param angle radians. Expects a `Float`
	 */
	rotateX(angle: number): this;
	/**
	 * Rotate the geometry about the Y axis.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link THREE.Object3D.rotation | Object3D.rotation} for typical real-time mesh rotation.
	 * @param angle radians. Expects a `Float`
	 */
	rotateY(angle: number): this;
	/**
	 * Rotate the geometry about the Z axis.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link THREE.Object3D.rotation | Object3D.rotation} for typical real-time mesh rotation.
	 * @param angle radians. Expects a `Float`
	 */
	rotateZ(angle: number): this;
	/**
	 * Translate the geometry.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link THREE.Object3D.position | Object3D.position} for typical real-time mesh rotation.
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 */
	translate(x: number, y: number, z: number): this;
	/**
	 * Scale the geometry data.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link THREE.Object3D.scale | Object3D.scale} for typical real-time mesh scaling.
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 */
	scale(x: number, y: number, z: number): this;
	/**
	 * Rotates the geometry to face a point in space.
	 * @remarks This is typically done as a one time operation, and not during a loop.
	 * @remarks Use {@link THREE.Object3D.lookAt | Object3D.lookAt} for typical real-time mesh usage.
	 * @param vector A world vector to look at.
	 */
	lookAt(vector: Vector3): this;
	/**
	 * Center the geometry based on the bounding box.
	 */
	center(): this;
	/**
	 * Defines a geometry by creating a `position` attribute based on the given array of points. The array can hold
	 * instances of {@link Vector2} or {@link Vector3}. When using two-dimensional data, the `z` coordinate for all
	 * vertices is set to `0`.
	 *
	 * If the method is used with an existing `position` attribute, the vertex data are overwritten with the data from
	 * the array. The length of the array must match the vertex count.
	 */
	setFromPoints(points: Vector3[] | Vector2[]): this;
	/**
	 * Computes the bounding box of the geometry, and updates the {@link .boundingBox} attribute. The bounding box is
	 * not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the
	 * geometry vertices are modified.
	 */
	computeBoundingBox(): void;
	/**
	 * Computes the bounding sphere of the geometry, and updates the {@link .boundingSphere} attribute. The engine
	 * automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You
	 * may need to recompute the bounding sphere if the geometry vertices are modified.
	 */
	computeBoundingSphere(): void;
	/**
	 * Calculates and adds a tangent attribute to this geometry.
	 * The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined
	 * @remarks
	 * When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
	 * {@link BufferGeometryUtils.computeMikkTSpaceTangents} instead.
	 */
	computeTangents(): void;
	/**
	 * Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to
	 * be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are
	 * not shared, and the method sets each vertex normal to be the same as the face normal.
	 */
	computeVertexNormals(): void;
	/**
	 * Every normal vector in a geometry will have a magnitude of 1
	 * @remarks This will correct lighting on the geometry surfaces.
	 */
	normalizeNormals(): void;
	/**
	 * Return a non-index version of an indexed BufferGeometry.
	 */
	toNonIndexed(): BufferGeometry;
	/**
	 * Convert the buffer geometry to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 */
	toJSON(): BufferGeometryJSON;
	/**
	 * Creates a clone of this BufferGeometry
	 */
	clone(): this;
	/**
	 * Copies another BufferGeometry to this BufferGeometry.
	 * @param source
	 */
	copy(source: BufferGeometry): this;
	/**
	 * Frees the GPU-related resources allocated by this instance.
	 * @remarks Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class Group<TEventMap extends Object3DEventMap = Object3DEventMap> extends Object3D<TEventMap> {
	/**
	 * Creates a new {@link Group}.
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link Group}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isGroup: true;
}
declare class DepthTexture extends Texture<DepthTextureImageData> {
	/**
	 * Create a new instance of {@link DepthTexture}
	 * @param width Width of the texture.
	 * @param height Height of the texture.
	 * @param type See {@link Texture.type | .type}. Default {@link THREE.UnsignedByteType} or {@link THREE.UnsignedInt248Type}
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link THREE.Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link THREE.NearestFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link THREE.NearestFilter}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link THREE.Texture.DEFAULT_ANISOTROPY}
	 * @param format See {@link DepthTexture.format | .format}. Default {@link THREE.DepthFormat}
	 * @param {number} [depth=1] - The depth of the texture.
	 */
	constructor(width: number, height: number, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, anisotropy?: number, format?: DepthTexturePixelFormat, depth?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link DepthTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDepthTexture: true;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override Depth textures do not use mipmaps.
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
	/**
	 * @override
	 * @see {@link Texture.format | Texture.format}
	 * @defaultValue {@link THREE.DepthFormat}.
	 */
	format: DepthTexturePixelFormat;
	/**
	 * @override
	 * @defaultValue {@link THREE.UnsignedByteType} when {@link format | .format} === {@link THREE.DepthFormat}
	 * @defaultValue {@link THREE.UnsignedInt248Type} when {@link format | .format} === {@link THREE.DepthStencilFormat}
	 */
	type: TextureDataType;
	/**
	 * This is used to define the comparison function used when comparing texels in the depth texture to the value in
	 * the depth buffer. Default is `null` which means comparison is disabled.
	 *
	 * See {@link THREE.TextureComparisonFunction} for functions.
	 */
	compareFunction: TextureComparisonFunction | null;
}
export interface DepthTextureImageData {
	width: number;
	height: number;
	depth: number;
}
export interface RenderTargetOptions extends TextureParameters {
	depthBuffer?: boolean | undefined; // true
	stencilBuffer?: boolean | undefined; // false
	resolveDepthBuffer?: boolean | undefined; // true
	resolveStencilBuffer?: boolean | undefined; // true
	depthTexture?: DepthTexture | null | undefined; // null
	/**
	 * Defines the count of MSAA samples. Can only be used with WebGL 2. Default is **0**.
	 * @default 0
	 */
	samples?: number | undefined;
	count?: number | undefined;
	depth?: number | undefined;
	multiview?: boolean | undefined;
}
declare class RenderTarget<TTexture extends Texture | Texture[] = Texture> extends EventDispatcher<{
	dispose: {};
}> {
	readonly isRenderTarget: true;
	width: number;
	height: number;
	depth: number;
	scissor: Vector4;
	/**
	 * @default false
	 */
	scissorTest: boolean;
	viewport: Vector4;
	textures: TTexture[];
	/**
	 * @default true
	 */
	depthBuffer: boolean;
	/**
	 * @default false
	 */
	stencilBuffer: boolean;
	/**
	 * Defines whether the depth buffer should be resolved when rendering into a multisampled render target.
	 * @default true
	 */
	resolveDepthBuffer: boolean;
	/**
	 * Defines whether the stencil buffer should be resolved when rendering into a multisampled render target.
	 * This property has no effect when {@link .resolveDepthBuffer} is set to `false`.
	 * @default true
	 */
	resolveStencilBuffer: boolean;
	/**
	 * Defines the count of MSAA samples. Can only be used with WebGL 2. Default is **0**.
	 * @default 0
	 */
	samples: number;
	/**
	 * Whether to this target is used in multiview rendering.
	 *
	 * @default false
	 */
	multiview: boolean;
	constructor(width?: number, height?: number, options?: RenderTargetOptions);
	get texture(): TTexture;
	set texture(value: TTexture);
	set depthTexture(current: DepthTexture | null);
	get depthTexture(): DepthTexture | null;
	setSize(width: number, height: number, depth?: number): void;
	clone(): this;
	copy(source: RenderTarget): this;
	dispose(): void;
}
export interface CompressedTextureMipmap {
	data: TypedArray;
	width: number;
	height: number;
}
declare class CompressedTexture<TImageData = CompressedTextureImageData> extends Texture<TImageData> {
	/**
	 * This creates a new {@link THREE.CompressedTexture | CompressedTexture} object.
	 * @param mipmaps The mipmaps array should contain objects with data, width and height. The mipmaps should be of the
	 * correct format and type.
	 * @param width The width of the biggest mipmap.
	 * @param height The height of the biggest mipmap.
	 * @param format The format used in the mipmaps. See {@link THREE.CompressedPixelFormat}.
	 * @param type See {@link Texture.type | .type}. Default {@link THREE.UnsignedByteType}
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link THREE.Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link THREE.LinearFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link THREE.LinearMipmapLinearFilter}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link THREE.Texture.DEFAULT_ANISOTROPY}
	 * @param colorSpace See {@link Texture.colorSpace .colorSpace}. Default {@link NoColorSpace}
	 */
	constructor(mipmaps: CompressedTextureMipmap[], width: number, height: number, format?: CompressedPixelFormat, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, anisotropy?: number, colorSpace?: string);
	/**
	 * Read-only flag to check if a given object is of type {@link CompressedTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCompressedTexture: true;
	/**
	 *  The mipmaps array should contain objects with data, width and height. The mipmaps should be of the correct
	 *  format and type.
	 */
	mipmaps: CompressedTextureMipmap[];
	/**
	 * @override
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link THREE.CompressedPixelFormat}
	 */
	format: CompressedPixelFormat;
	/**
	 * @override No flipping for cube textures. (also flipping doesn't work for compressed textures)
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override Can't generate mipmaps for compressed textures. mips must be embedded in DDS files
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
}
export interface CompressedTextureImageData {
	width: number;
	height: number;
}
declare class CubeTexture<TImage = unknown> extends Texture<TImage[]> {
	/**
	 * This creates a new {@link THREE.CubeTexture | CubeTexture} object.
	 * @param images
	 * @param mapping See {@link CubeTexture.mapping | .mapping}. Default {@link THREE.CubeReflectionMapping}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link THREE.LinearFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link THREE.LinearMipmapLinearFilter}
	 * @param format See {@link Texture.format | .format}. Default {@link THREE.RGBAFormat}
	 * @param type See {@link Texture.type | .type}. Default {@link THREE.UnsignedByteType}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link THREE.Texture.DEFAULT_ANISOTROPY}
	 * @param colorSpace See {@link Texture.colorSpace | .colorSpace}. Default {@link NoColorSpace}
	 */
	constructor(images?: TImage[], mapping?: CubeTextureMapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number, colorSpace?: string);
	/**
	 * Read-only flag to check if a given object is of type {@link CubeTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCubeTexture: true;
	/**
	 * An image object, typically created using the {@link THREE.CubeTextureLoader.load | CubeTextureLoader.load()} method.
	 * @see {@link Texture.image}
	 */
	get images(): TImage[];
	set images(value: TImage[]);
	/**
	 * @inheritDoc
	 * @defaultValue {@link THREE.CubeReflectionMapping}
	 */
	mapping: CubeTextureMapping;
	/**
	 * @inheritDoc
	 * @defaultValue `false`
	 */
	flipY: boolean;
}
export type SerializedImage = string | {
	data: number[];
	width: number;
	height: number;
	type: string;
};
declare class SourceJSON {
	uuid: string;
	url: SerializedImage | SerializedImage[];
}
declare class Source<TData> {
	/**
	 * Flag to check if a given object is of type {@link Source}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSource: true;
	readonly id: number;
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * The actual data of a texture.
	 * @remarks The type of this property depends on the texture that uses this instance.
	 */
	data: TData;
	/**
	 * This property is only relevant when {@link .needsUpdate} is set to `true` and provides more control on how
	 * texture data should be processed.
	 * When `dataReady` is set to `false`, the engine performs the memory allocation (if necessary) but does not
	 * transfer the data into the GPU memory.
	 * @default true
	 */
	dataReady: boolean;
	/**
	 * This starts at `0` and counts how many times {@link needsUpdate | .needsUpdate} is set to `true`.
	 * @remarks Expects a `Integer`
	 * @defaultValue `0`
	 */
	version: number;
	/**
	 * Create a new instance of {@link Source}
	 * @param data The data definition of a texture. Default `null`
	 */
	constructor(data: TData);
	getSize(target: Vector3): Vector3;
	/**
	 * When the property is set to `true`, the engine allocates the memory for the texture (if necessary) and triggers
	 * the actual texture upload to the GPU next time the source is used.
	 */
	set needsUpdate(value: boolean);
	/**
	 * Convert the data {@link Source} to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 * @param meta Optional object containing metadata.
	 */
	toJSON(meta?: string | {}): SourceJSON;
}
// NOTE: DOM upload fields are not implemented where parameters are accepted.
export interface TextureParameters {
	mapping?: AnyMapping | undefined;
	// image?: TexImageSource | OffscreenCanvas | undefined;
	// channel?: number | undefined;
	wrapS?: Wrapping | undefined;
	wrapT?: Wrapping | undefined;
	wrapR?: Wrapping | undefined;
	format?: PixelFormat | undefined;
	internalFormat?: PixelFormatGPU | null | undefined;
	type?: TextureDataType | undefined;
	colorSpace?: ColorSpace | undefined;
	magFilter?: MagnificationTextureFilter | undefined;
	minFilter?: MinificationTextureFilter | undefined;
	anisotropy?: number | undefined;
	flipY?: boolean | undefined;
	generateMipmaps?: boolean | undefined;
}
export interface TextureJSON {
	metadata: {
		version: number;
		type: string;
		generator: string;
	};
	uuid: string;
	name: string;
	image: string;
	mapping: AnyMapping;
	channel: number;
	repeat: [
		x: number,
		y: number
	];
	offset: [
		x: number,
		y: number
	];
	center: [
		x: number,
		y: number
	];
	rotation: number;
	wrap: [
		wrapS: number,
		wrapT: number
	];
	format: AnyPixelFormat;
	internalFormat: PixelFormatGPU | null;
	type: TextureDataType;
	colorSpace: string;
	minFilter: MinificationTextureFilter;
	magFilter: MagnificationTextureFilter;
	anisotropy: number;
	flipY: boolean;
	generateMipmaps: boolean;
	premultiplyAlpha: boolean;
	unpackAlignment: number;
	userData?: Record<string, unknown>;
}
interface OffscreenCanvas$1 extends EventTarget {
}
declare class Texture<TImage = unknown> extends EventDispatcher<{
	dispose: {};
}> {
	/**
	 * This creates a new {@link THREE.Texture | Texture} object.
	 * @param image See {@link Texture.image | .image}. Default {@link THREE.Texture.DEFAULT_IMAGE}
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link THREE.Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link THREE.LinearFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link THREE.LinearMipmapLinearFilter}
	 * @param format See {@link Texture.format | .format}. Default {@link THREE.RGBAFormat}
	 * @param type See {@link Texture.type | .type}. Default {@link THREE.UnsignedByteType}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link THREE.Texture.DEFAULT_ANISOTROPY}
	 * @param colorSpace See {@link Texture.colorSpace | .colorSpace}. Default {@link THREE.NoColorSpace}
	 */
	constructor(image?: TImage, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number, colorSpace?: ColorSpace);
	/**
	 * @deprecated
	 */
	constructor(image: TImage, mapping: Mapping, wrapS: Wrapping, wrapT: Wrapping, magFilter: MagnificationTextureFilter, minFilter: MinificationTextureFilter, format: PixelFormat, type: TextureDataType, anisotropy: number);
	/**
	 * Read-only flag to check if a given object is of type {@link Texture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isTexture: true;
	/**
	 * Unique number for this {@link Texture} instance.
	 * @remarks Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.
	 * @remarks Expects a `Integer`
	 */
	readonly id: number;
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * Optional name of the object
	 * @remarks _(doesn't need to be unique)_.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * The data definition of a texture. A reference to the data source can be shared across textures.
	 * This is often useful in context of spritesheets where multiple textures render the same data
	 * but with different {@link Texture} transformations.
	 */
	source: Source<TImage>;
	/**
	 * The width of the texture in pixels.
	 */
	get width(): number;
	/**
	 * The height of the texture in pixels.
	 */
	get height(): number;
	/**
	 * The depth of the texture in pixels.
	 */
	get depth(): number;
	/**
	 * An image object, typically created using the {@link THREE.TextureLoader.load | TextureLoader.load()} method.
	 * @remarks This can be any image (e.g., PNG, JPG, GIF, DDS) or video (e.g., MP4, OGG/OGV) type supported by three.js.
	 * @remarks To use video as a {@link Texture} you need to have a playing HTML5 video element as a source
	 * for your {@link Texture} image and continuously update this {@link Texture}
	 * as long as video is playing - the {@link THREE.VideoTexture | VideoTexture} class handles this automatically.
	 */
	get image(): TImage;
	set image(data: TImage);
	/**
	 * Array of user-specified mipmaps
	 * @defaultValue `[]`
	 */
	mipmaps: CompressedTextureMipmap[] | CubeTexture[] | HTMLCanvasElement[];
	/**
	 * How the image is applied to the object.
	 * @remarks All {@link Texture} types except {@link THREE.CubeTexture} expect the _values_ be {@link THREE.Mapping}
	 * @remarks {@link CubeTexture} expect the _values_ be {@link THREE.CubeTextureMapping}
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @defaultValue _value of_ {@link THREE.Texture.DEFAULT_MAPPING}
	 */
	mapping: AnyMapping;
	/**
	 * Lets you select the uv attribute to map the texture to. `0` for `uv`, `1` for `uv1`, `2` for `uv2` and `3` for
	 * `uv3`.
	 */
	channel: number;
	/**
	 * This defines how the {@link Texture} is wrapped *horizontally* and corresponds to **U** in UV mapping.
	 * @remarks for **WEBGL1** - tiling of images in textures only functions if image dimensions are powers of two
	 * (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, ...) in terms of pixels.
	 * Individual dimensions need not be equal, but each must be a power of two. This is a limitation of WebGL1, not three.js.
	 * **WEBGL2** does not have this limitation.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link wrapT}
	 * @see {@link repeat}
	 * @defaultValue {@link THREE.ClampToEdgeWrapping}
	 */
	wrapS: Wrapping;
	/**
	 * This defines how the {@link Texture} is wrapped *vertically* and corresponds to **V** in UV mapping.
	 * @remarks for **WEBGL1** - tiling of images in textures only functions if image dimensions are powers of two
	 * (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, ...) in terms of pixels.
	 * Individual dimensions need not be equal, but each must be a power of two. This is a limitation of WebGL1, not three.js.
	 * **WEBGL2** does not have this limitation.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link wrapS}
	 * @see {@link repeat}
	 * @defaultValue {@link THREE.ClampToEdgeWrapping}
	 */
	wrapT: Wrapping;
	/**
	 * How the {@link Texture} is sampled when a texel covers more than one pixel.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link minFilter}
	 * @see {@link THREE.MagnificationTextureFilter}
	 * @defaultValue {@link THREE.LinearFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * How the {@link Texture} is sampled when a texel covers less than one pixel.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link magFilter}
	 * @see {@link THREE.MinificationTextureFilter}
	 * @defaultValue {@link THREE.LinearMipmapLinearFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * The number of samples taken along the axis through the pixel that has the highest density of texels.
	 * @remarks A higher value gives a less blurry result than a basic mipmap, at the cost of more {@link Texture} samples being used.
	 * @remarks Use {@link THREE.WebGLCapabilities.getMaxAnisotropy() | renderer.capabilities.getMaxAnisotropy()} to find the maximum valid anisotropy value for the GPU;
	 * @remarks This value is usually a power of 2.
	 * @default _value of_ {@link THREE.Texture.DEFAULT_ANISOTROPY}. That is normally `1`.
	 */
	anisotropy: number;
	/**
	 * These define how elements of a 2D texture, or texels, are read by shaders.
	 * @remarks All {@link Texture} types except {@link THREE.DepthTexture} and {@link THREE.CompressedPixelFormat} expect the _values_ be {@link THREE.PixelFormat}
	 * @remarks {@link DepthTexture} expect the _values_ be {@link THREE.CubeTextureMapping}
	 * @remarks {@link CompressedPixelFormat} expect the _values_ be {@link THREE.CubeTextureMapping}
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link THREE.PixelFormat}
	 * @defaultValue {@link THREE.RGBAFormat}.
	 */
	format: AnyPixelFormat;
	/**
	 * This must correspond to the {@link Texture.format | .format}.
	 * @remarks {@link THREE.UnsignedByteType}, is the type most used by Texture formats.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link THREE.TextureDataType}
	 * @defaultValue {@link THREE.UnsignedByteType}
	 */
	type: TextureDataType;
	/**
	 * The GPU Pixel Format allows the developer to specify how the data is going to be stored on the GPU.
	 * @remarks Compatible only with {@link WebGL2RenderingContext | WebGL 2 Rendering Context}.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @defaultValue The default value is obtained using a combination of {@link Texture.format | .format} and {@link Texture.type | .type}.
	 */
	internalFormat: PixelFormatGPU | null;
	/**
	 * The uv-transform matrix for the texture.
	 * @remarks
	 * When {@link Texture.matrixAutoUpdate | .matrixAutoUpdate} property is `true`.
	 * Will be updated by the renderer from the properties:
	 *  - {@link Texture.offset | .offset}
	 *  - {@link Texture.repeat | .repeat}
	 *  - {@link Texture.rotation | .rotation}
	 *  - {@link Texture.center | .center}
	 * @remarks
	 * When {@link Texture.matrixAutoUpdate | .matrixAutoUpdate} property is `false`.
	 * This matrix may be set manually.
	 * @see {@link matrixAutoUpdate | .matrixAutoUpdate}
	 * @defaultValue `new THREE.Matrix3()`
	 */
	matrix: Matrix3;
	/**
	 * Whether is to update the texture's uv-transform {@link matrix | .matrix}.
	 * @remarks Set this to `false` if you are specifying the uv-transform {@link matrix} directly.
	 * @see {@link matrix | .matrix}
	 * @defaultValue `true`
	 */
	matrixAutoUpdate: boolean;
	/**
	 * How much a single repetition of the texture is offset from the beginning, in each direction **U** and **V**.
	 * @remarks Typical range is `0.0` to `1.0`.
	 * @defaultValue `new THREE.Vector2(0, 0)`
	 */
	offset: Vector2;
	/**
	 * How many times the texture is repeated across the surface, in each direction **U** and **V**.
	 * @remarks
	 * If repeat is set greater than `1` in either direction, the corresponding *Wrap* parameter should
	 * also be set to {@link THREE.RepeatWrapping} or {@link THREE.MirroredRepeatWrapping} to achieve the desired tiling effect.
	 * @see {@link wrapS}
	 * @see {@link wrapT}
	 * @defaultValue `new THREE.Vector2( 1, 1 )`
	 */
	repeat: Vector2;
	/**
	 * The point around which rotation occurs.
	 * @remarks A value of `(0.5, 0.5)` corresponds to the center of the texture.
	 * @defaultValue `new THREE.Vector2( 0, 0 )`, _lower left._
	 */
	center: Vector2;
	/**
	 * How much the texture is rotated around the center point, in radians.
	 * @remarks Positive values are counter-clockwise.
	 * @defaultValue `0`
	 */
	rotation: number;
	/**
	 * Whether to generate mipmaps, _(if possible)_ for a texture.
	 * @remarks Set this to false if you are creating mipmaps manually.
	 * @defaultValue true
	 */
	generateMipmaps: boolean;
	/**
	 * If set to `true`, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU.
	 * @remarks
	 * Note that this property has no effect for {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap | ImageBitmap}.
	 * You need to configure on bitmap creation instead. See {@link THREE.ImageBitmapLoader | ImageBitmapLoader}.
	 * @see {@link THREE.ImageBitmapLoader | ImageBitmapLoader}.
	 * @defaultValue `false`
	 */
	premultiplyAlpha: boolean;
	/**
	 * If set to `true`, the texture is flipped along the vertical axis when uploaded to the GPU.
	 * @remarks
	 * Note that this property has no effect for {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap | ImageBitmap}.
	 * You need to configure on bitmap creation instead. See {@link THREE.ImageBitmapLoader | ImageBitmapLoader}.
	 * @see {@link THREE.ImageBitmapLoader | ImageBitmapLoader}.
	 * @defaultValue `true`
	 */
	flipY: boolean;
	/**
	 * Specifies the alignment requirements for the start of each pixel row in memory.
	 * @remarks
	 * The allowable values are:
	 *  - `1` (byte-alignment)
	 *  - `2` (rows aligned to even-numbered bytes)
	 *  - `4` (word-alignment)
	 *  - `8` (rows start on double-word boundaries).
	 * @see {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml | glPixelStorei} for more information.
	 * @defaultValue `4`
	 */
	unpackAlignment: number; // TODO Fix typing to only allow the expected values.
	/**
	 * The {@link Textures | {@link Texture} constants} page for details of other color spaces.
	 * @remarks
	 * Textures containing color data should be annotated with {@link SRGBColorSpace THREE.SRGBColorSpace} or
	 * {@link LinearSRGBColorSpace THREE.LinearSRGBColorSpace}.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @see {@link THREE.TextureDataType}
	 * @defaultValue {@link THREE.NoColorSpace}
	 */
	colorSpace: string;
	/**
	 * Indicates whether a texture belongs to a render target or not
	 * @defaultValue `false`
	 */
	isRenderTargetTexture: boolean;
	/**
	 * Indicates if a texture should be handled like a texture array.
	 *
	 * @default false
	 */
	isArrayTexture: boolean;
	/**
	 * An object that can be used to store custom data about the texture.
	 * @remarks It should not hold references to functions as these will not be cloned.
	 * @defaultValue `{}`
	 */
	userData: Record<string, any>;
	/**
	 * This can be used to only update a subregion or specific rows of the texture (for example, just the
	 * first 3 rows). Use the `addUpdateRange()` function to add ranges to this array.
	 */
	updateRanges: Array<{
		start: number;
		count: number;
	}>;
	/**
	 * This starts at `0` and counts how many times {@link needsUpdate | .needsUpdate} is set to `true`.
	 * @remarks Expects a `Integer`
	 * @defaultValue `0`
	 */
	version: number;
	/**
	 * Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target
	 * textures)
	 */
	pmremVersion: number;
	/**
	 * Set this to `true` to trigger an update next time the texture is used. Particularly important for setting the wrap mode.
	 */
	set needsUpdate(value: boolean);
	/**
	 * Indicates whether this texture should be processed by {@link THREE.PMREMGenerator} or not.
	 * @remarks Only relevant for render target textures.
	 * @defaultValue `false`
	 */
	set needsPMREMUpdate(value: boolean);
	/**
	 * The Global default value for {@link anisotropy | .anisotropy}.
	 * @defaultValue `1`.
	 */
	static DEFAULT_ANISOTROPY: number;
	/**
	 * The Global default value for {@link Texture.image | .image}.
	 * @defaultValue `null`.
	 */
	static DEFAULT_IMAGE: null;
	/**
	 * The Global default value for {@link mapping | .mapping}.
	 * @defaultValue {@link THREE.UVMapping}
	 */
	static DEFAULT_MAPPING: Mapping;
	renderTarget: RenderTarget | null;
	/**
	 * A callback function, called when the texture is updated _(e.g., when needsUpdate has been set to true and then the texture is used)_.
	 */
	onUpdate: ((texture: Texture) => void) | null;
	/**
	 * Transform the **UV** based on the value of this texture's
	 * {@link offset | .offset},
	 * {@link repeat | .repeat},
	 * {@link wrapS | .wrapS},
	 * {@link wrapT | .wrapT} and
	 * {@link flipY | .flipY} properties.
	 * @param uv
	 */
	transformUv(uv: Vector2): Vector2;
	/**
	 * Update the texture's **UV-transform** {@link matrix | .matrix} from the texture properties
	 * {@link offset | .offset},
	 * {@link repeat | .repeat},
	 * {@link rotation | .rotation} and
	 * {@link center | .center}.
	 */
	updateMatrix(): void;
	/**
	 * Adds a range of data in the data texture to be updated on the GPU.
	 *
	 * @param {number} start - Position at which to start update.
	 * @param {number} count - The number of components to update.
	 */
	addUpdateRange(start: number, count: number): void;
	/**
	 * Clears the update ranges.
	 */
	clearUpdateRanges(): void;
	/**
	 * Make copy of the texture. Note this is not a "deep copy", the image is shared. Cloning the texture automatically
	 * marks it for texture upload.
	 */
	clone(): this;
	copy(source: Texture<TImage>): this;
	/**
	 * Sets this texture's properties based on `values`.
	 * @param values - A container with texture parameters.
	 */
	setValues(values: TextureParameters): void;
	/**
	 * Convert the texture to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 * @param meta Optional object containing metadata.
	 */
	toJSON(meta?: string | {}): TextureJSON;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
export interface LineBasicMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (1,1,1)
	 */
	color: Color;
	/**
	 * Sets the color of the lines using data from a texture. The texture map
	 * color is modulated by the diffuse `color`.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * Controls line thickness or lines.
	 *
	 * Can only be used with {@link SVGRenderer}. WebGL and WebGPU
	 * ignore this setting and always render line primitives with a
	 * width of one pixel.
	 *
	 * @default 1
	 */
	linewidth: number;
	/**
	 * Defines appearance of line ends.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	linecap: "butt" | "round" | "square";
	/**
	 * Defines appearance of line joints.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	linejoin: "round" | "bevel" | "miter";
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface LineBasicMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<LineBasicMaterialProperties>> {
}
declare class LineBasicMaterial extends Material {
	/**
	 * Constructs a new line basic material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: LineBasicMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isLineBasicMaterial: boolean;
	setValues(values?: LineBasicMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface LineBasicMaterial extends LineBasicMaterialProperties {
}
export interface LineDashedMaterialProperties extends LineBasicMaterialProperties {
	/**
	 * The scale of the dashed part of a line.
	 *
	 * @default 1
	 */
	scale: number;
	/**
	 * The size of the dash. This is both the gap with the stroke.
	 *
	 * @default 3
	 */
	dashSize: number;
	/**
	 * The size of the gap.
	 *
	 * @default 1
	 */
	gapSize: number;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface LineDashedMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<LineDashedMaterialProperties>> {
}
declare class LineDashedMaterial extends LineBasicMaterial {
	constructor(parameters?: LineDashedMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isLineDashedMaterial: boolean;
	setValues(values?: LineDashedMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface LineDashedMaterial extends LineDashedMaterialProperties {
}
export interface MeshBasicMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (1,1,1)
	 */
	color: Color;
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
	 * color is modulated by the diffuse `color`.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * The light map. Requires a second set of UVs.
	 *
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * Intensity of the baked light.
	 *
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * The red channel of this texture is used as the ambient occlusion map.
	 * Requires a second set of UVs.
	 *
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
	 * disables ambient occlusion. Where intensity is `1` and the AO map's
	 * red channel is also `1`, ambient light is fully occluded on a surface.
	 *
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * Specular map used by the material.
	 *
	 * @default null
	 */
	specularMap: Texture | null;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * The environment map.
	 *
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * The rotation of the environment map in radians.
	 *
	 * @default (0,0,0)
	 */
	envMapRotation: Euler;
	/**
	 * How to combine the result of the surface's color with the environment map, if any.
	 *
	 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
	 * blend between the two colors.
	 *
	 * @default MultiplyOperation
	 */
	combine: Combine;
	/**
	 * How much the environment map affects the surface.
	 * The valid range is between `0` (no reflections) and `1` (full reflections).
	 *
	 * @default 1
	 */
	reflectivity: number;
	/**
	 * The index of refraction (IOR) of air (approximately 1) divided by the
	 * index of refraction of the material. It is used with environment mapping
	 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
	 * The refraction ratio should not exceed `1`.
	 *
	 * @default 0.98
	 */
	refractionRatio: number;
	/**
	 * Renders the geometry as a wireframe.
	 *
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * Controls the thickness of the wireframe.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Defines appearance of wireframe ends.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinecap: "round" | "bevel" | "miter";
	/**
	 * Defines appearance of wireframe joints.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinejoin: "round" | "bevel" | "miter";
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshBasicMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshBasicMaterialProperties>> {
}
declare class MeshBasicMaterial extends Material {
	/**
	 * Constructs a new mesh basic material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: MeshBasicMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshBasicMaterial: boolean;
	setValues(values?: MeshBasicMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshBasicMaterial extends MeshBasicMaterialProperties {
}
export interface MeshDepthMaterialProperties extends MaterialProperties {
	/**
	 * Type for depth packing.
	 *
	 * @default BasicDepthPacking
	 */
	depthPacking: DepthPackingStrategies;
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * The displacement map affects the position of the mesh's vertices. Unlike
	 * other maps which only affect the light and shade of the material the
	 * displaced vertices can cast shadows, block other objects, and otherwise
	 * act as real geometry. The displacement texture is an image where the value
	 * of each pixel (white being the highest) is mapped against, and
	 * repositions, the vertices of the mesh.
	 *
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * How much the displacement map affects the mesh (where black is no
	 * displacement, and white is maximum displacement). Without a displacement
	 * map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementScale: number;
	/**
	 * The offset of the displacement map's values on the mesh's vertices.
	 * The bias is added to the scaled sample of the displacement map.
	 * Without a displacement map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * Renders the geometry as a wireframe.
	 *
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * Controls the thickness of the wireframe.
	 *
	 * WebGL and WebGPU ignore this property and always render
	 * 1 pixel wide lines.
	 *
	 * @default 1
	 */
	wireframeLinewidth: number;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshDepthMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshDepthMaterialProperties>> {
}
declare class MeshDepthMaterial extends Material {
	/**
	 * Constructs a new mesh depth material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: MeshDepthMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshDepthMaterial: boolean;
	setValues(values?: MeshDepthMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshDepthMaterial extends MeshDepthMaterialProperties {
}
export interface MeshDistanceMaterialProperties extends MaterialProperties {
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * The displacement map affects the position of the mesh's vertices. Unlike
	 * other maps which only affect the light and shade of the material the
	 * displaced vertices can cast shadows, block other objects, and otherwise
	 * act as real geometry. The displacement texture is an image where the value
	 * of each pixel (white being the highest) is mapped against, and
	 * repositions, the vertices of the mesh.
	 *
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * How much the displacement map affects the mesh (where black is no
	 * displacement, and white is maximum displacement). Without a displacement
	 * map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementScale: number;
	/**
	 * The offset of the displacement map's values on the mesh's vertices.
	 * The bias is added to the scaled sample of the displacement map.
	 * Without a displacement map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementBias: number;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshDistanceMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshDistanceMaterialProperties>> {
}
declare class MeshDistanceMaterial extends Material {
	/**
	 * Constructs a new mesh distance material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: MeshDistanceMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshDistanceMaterial: boolean;
	setValues(values?: MeshDistanceMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshDistanceMaterial extends MeshDistanceMaterialProperties {
}
export interface MeshLambertMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (1,1,1)
	 */
	color: Color;
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
	 * color is modulated by the diffuse `color`.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * The light map. Requires a second set of UVs.
	 *
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * Intensity of the baked light.
	 *
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * The red channel of this texture is used as the ambient occlusion map.
	 * Requires a second set of UVs.
	 *
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
	 * disables ambient occlusion. Where intensity is `1` and the AO map's
	 * red channel is also `1`, ambient light is fully occluded on a surface.
	 *
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * Emissive (light) color of the material, essentially a solid color
	 * unaffected by other lighting.
	 *
	 * @default (0,0,0)
	 */
	emissive: Color;
	/**
	 * Intensity of the emissive light. Modulates the emissive color.
	 *
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * Set emissive (glow) map. The emissive map color is modulated by the
	 * emissive color and the emissive intensity. If you have an emissive map,
	 * be sure to set the emissive color to something other than black.
	 *
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * The texture to create a bump map. The black and white values map to the
	 * perceived depth in relation to the lights. Bump doesn't actually affect
	 * the geometry of the object, only the lighting. If a normal map is defined
	 * this will be ignored.
	 *
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * How much the bump map affects the material. Typical range is `[0,1]`.
	 *
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * The texture to create a normal map. The RGB values affect the surface
	 * normal for each pixel fragment and change the way the color is lit. Normal
	 * maps do not change the actual shape of the surface, only the lighting. In
	 * case the material has a normal map authored using the left handed
	 * convention, the `y` component of `normalScale` should be negated to compensate
	 * for the different handedness.
	 *
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * The type of normal map.
	 *
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * How much the normal map affects the material. Typical value range is `[0,1]`.
	 *
	 * @default (1,1)
	 */
	normalScale: Vector2;
	/**
	 * The displacement map affects the position of the mesh's vertices. Unlike
	 * other maps which only affect the light and shade of the material the
	 * displaced vertices can cast shadows, block other objects, and otherwise
	 * act as real geometry. The displacement texture is an image where the value
	 * of each pixel (white being the highest) is mapped against, and
	 * repositions, the vertices of the mesh.
	 *
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * How much the displacement map affects the mesh (where black is no
	 * displacement, and white is maximum displacement). Without a displacement
	 * map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementScale: number;
	/**
	 * The offset of the displacement map's values on the mesh's vertices.
	 * The bias is added to the scaled sample of the displacement map.
	 * Without a displacement map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * Specular map used by the material.
	 *
	 * @default null
	 */
	specularMap: Texture | null;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * The environment map.
	 *
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * The rotation of the environment map in radians.
	 *
	 * @default (0,0,0)
	 */
	envMapRotation: Euler;
	/**
	 * How to combine the result of the surface's color with the environment map, if any.
	 *
	 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
	 * blend between the two colors.
	 *
	 * @default MultiplyOperation
	 */
	combine: Combine;
	/**
	 * How much the environment map affects the surface.
	 * The valid range is between `0` (no reflections) and `1` (full reflections).
	 *
	 * @default 1
	 */
	reflectivity: number;
	/**
	 * The index of refraction (IOR) of air (approximately 1) divided by the
	 * index of refraction of the material. It is used with environment mapping
	 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
	 * The refraction ratio should not exceed `1`.
	 *
	 * @default 0.98
	 */
	refractionRatio: number;
	/**
	 * Renders the geometry as a wireframe.
	 *
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * Controls the thickness of the wireframe.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Defines appearance of wireframe ends.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinecap: "round" | "bevel" | "miter";
	/**
	 * Defines appearance of wireframe joints.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinejoin: "round" | "bevel" | "miter";
	/**
	 * Whether the material is rendered with flat shading or not.
	 *
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshLambertMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshLambertMaterialProperties>> {
}
declare class MeshLambertMaterial extends Material {
	/**
	 * Constructs a new mesh lambert material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: MeshLambertMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshLambertMaterial: boolean;
	setValues(values?: MeshLambertMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshLambertMaterial extends MeshLambertMaterialProperties {
}
export interface MeshMatcapMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (1,1,1)
	 */
	color: Color;
	/**
	 * The matcap map.
	 *
	 * @default null
	 */
	matcap: Texture | null;
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
	 * color is modulated by the diffuse `color`.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * The texture to create a bump map. The black and white values map to the
	 * perceived depth in relation to the lights. Bump doesn't actually affect
	 * the geometry of the object, only the lighting. If a normal map is defined
	 * this will be ignored.
	 *
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * How much the bump map affects the material. Typical range is `[0,1]`.
	 *
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * The texture to create a normal map. The RGB values affect the surface
	 * normal for each pixel fragment and change the way the color is lit. Normal
	 * maps do not change the actual shape of the surface, only the lighting. In
	 * case the material has a normal map authored using the left handed
	 * convention, the `y` component of `normalScale` should be negated to compensate
	 * for the different handedness.
	 *
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * The type of normal map.
	 *
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * How much the normal map affects the material. Typical value range is `[0,1]`.
	 *
	 * @default (1,1)
	 */
	normalScale: Vector2;
	/**
	 * The displacement map affects the position of the mesh's vertices. Unlike
	 * other maps which only affect the light and shade of the material the
	 * displaced vertices can cast shadows, block other objects, and otherwise
	 * act as real geometry. The displacement texture is an image where the value
	 * of each pixel (white being the highest) is mapped against, and
	 * repositions, the vertices of the mesh.
	 *
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * How much the displacement map affects the mesh (where black is no
	 * displacement, and white is maximum displacement). Without a displacement
	 * map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementScale: number;
	/**
	 * The offset of the displacement map's values on the mesh's vertices.
	 * The bias is added to the scaled sample of the displacement map.
	 * Without a displacement map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * Renders the geometry as a wireframe.
	 *
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * Controls the thickness of the wireframe.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Whether the material is rendered with flat shading or not.
	 *
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshMatcapMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshMatcapMaterialProperties>> {
}
declare class MeshMatcapMaterial extends Material {
	/**
	 * Constructs a new mesh matcap material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: MeshMatcapMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshMatcapMaterial: boolean;
	setValues(values?: MeshMatcapMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshMatcapMaterial extends MeshMatcapMaterialProperties {
}
export interface MeshNormalMaterialProperties extends MaterialProperties {
	/**
	 * The texture to create a bump map. The black and white values map to the
	 * perceived depth in relation to the lights. Bump doesn't actually affect
	 * the geometry of the object, only the lighting. If a normal map is defined
	 * this will be ignored.
	 *
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * How much the bump map affects the material. Typical range is `[0,1]`.
	 *
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * The texture to create a normal map. The RGB values affect the surface
	 * normal for each pixel fragment and change the way the color is lit. Normal
	 * maps do not change the actual shape of the surface, only the lighting. In
	 * case the material has a normal map authored using the left handed
	 * convention, the `y` component of `normalScale` should be negated to compensate
	 * for the different handedness.
	 *
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * The type of normal map.
	 *
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * How much the normal map affects the material. Typical value range is `[0,1]`.
	 *
	 * @default (1,1)
	 */
	normalScale: Vector2;
	/**
	 * The displacement map affects the position of the mesh's vertices. Unlike
	 * other maps which only affect the light and shade of the material the
	 * displaced vertices can cast shadows, block other objects, and otherwise
	 * act as real geometry. The displacement texture is an image where the value
	 * of each pixel (white being the highest) is mapped against, and
	 * repositions, the vertices of the mesh.
	 *
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * How much the displacement map affects the mesh (where black is no
	 * displacement, and white is maximum displacement). Without a displacement
	 * map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementScale: number;
	/**
	 * The offset of the displacement map's values on the mesh's vertices.
	 * The bias is added to the scaled sample of the displacement map.
	 * Without a displacement map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * Renders the geometry as a wireframe.
	 *
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * Controls the thickness of the wireframe.
	 *
	 * WebGL and WebGPU ignore this property and always render
	 * 1 pixel wide lines.
	 *
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Whether the material is rendered with flat shading or not.
	 *
	 * @default false
	 */
	flatShading: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshNormalMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshNormalMaterialProperties>> {
}
declare class MeshNormalMaterial extends Material {
	/**
	 * Constructs a new mesh normal material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: MeshNormalMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshNormalMaterial: boolean;
	setValues(values?: MeshNormalMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshNormalMaterial extends MeshNormalMaterialProperties {
}
export interface MeshPhongMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (1,1,1)
	 */
	color: Color;
	/**
	 * Specular color of the material. The default color is set to `0x111111` (very dark grey)
	 *
	 * This defines how shiny the material is and the color of its shine.
	 */
	specular: Color;
	/**
	 * How shiny the specular highlight is; a higher value gives a sharper highlight.
	 *
	 * @default 30
	 */
	shininess: number;
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
	 * color is modulated by the diffuse `color`.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * The light map. Requires a second set of UVs.
	 *
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * Intensity of the baked light.
	 *
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * The red channel of this texture is used as the ambient occlusion map.
	 * Requires a second set of UVs.
	 *
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
	 * disables ambient occlusion. Where intensity is `1` and the AO map's
	 * red channel is also `1`, ambient light is fully occluded on a surface.
	 *
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * Emissive (light) color of the material, essentially a solid color
	 * unaffected by other lighting.
	 *
	 * @default (0,0,0)
	 */
	emissive: Color;
	/**
	 * Intensity of the emissive light. Modulates the emissive color.
	 *
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * Set emissive (glow) map. The emissive map color is modulated by the
	 * emissive color and the emissive intensity. If you have an emissive map,
	 * be sure to set the emissive color to something other than black.
	 *
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * The texture to create a bump map. The black and white values map to the
	 * perceived depth in relation to the lights. Bump doesn't actually affect
	 * the geometry of the object, only the lighting. If a normal map is defined
	 * this will be ignored.
	 *
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * How much the bump map affects the material. Typical range is `[0,1]`.
	 *
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * The texture to create a normal map. The RGB values affect the surface
	 * normal for each pixel fragment and change the way the color is lit. Normal
	 * maps do not change the actual shape of the surface, only the lighting. In
	 * case the material has a normal map authored using the left handed
	 * convention, the `y` component of `normalScale` should be negated to compensate
	 * for the different handedness.
	 *
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * The type of normal map.
	 *
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * How much the normal map affects the material. Typical value range is `[0,1]`.
	 *
	 * @default (1,1)
	 */
	normalScale: Vector2;
	/**
	 * The displacement map affects the position of the mesh's vertices. Unlike
	 * other maps which only affect the light and shade of the material the
	 * displaced vertices can cast shadows, block other objects, and otherwise
	 * act as real geometry. The displacement texture is an image where the value
	 * of each pixel (white being the highest) is mapped against, and
	 * repositions, the vertices of the mesh.
	 *
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * How much the displacement map affects the mesh (where black is no
	 * displacement, and white is maximum displacement). Without a displacement
	 * map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementScale: number;
	/**
	 * The offset of the displacement map's values on the mesh's vertices.
	 * The bias is added to the scaled sample of the displacement map.
	 * Without a displacement map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * The specular map value affects both how much the specular surface
	 * highlight contributes and how much of the environment map affects the
	 * surface.
	 *
	 * @default null
	 */
	specularMap: Texture | null;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * The environment map.
	 *
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * The rotation of the environment map in radians.
	 *
	 * @default (0,0,0)
	 */
	envMapRotation: Euler;
	/**
	 * How to combine the result of the surface's color with the environment map, if any.
	 *
	 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
	 * blend between the two colors.
	 *
	 * @default MultiplyOperation
	 */
	combine: Combine;
	/**
	 * How much the environment map affects the surface.
	 * The valid range is between `0` (no reflections) and `1` (full reflections).
	 *
	 * @default 1
	 */
	reflectivity: number;
	/**
	 * The index of refraction (IOR) of air (approximately 1) divided by the
	 * index of refraction of the material. It is used with environment mapping
	 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
	 * The refraction ratio should not exceed `1`.
	 *
	 * @default 0.98
	 */
	refractionRatio: number;
	/**
	 * Renders the geometry as a wireframe.
	 *
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * Controls the thickness of the wireframe.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Defines appearance of wireframe ends.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinecap: "round" | "bevel" | "miter";
	/**
	 * Defines appearance of wireframe joints.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinejoin: "round" | "bevel" | "miter";
	/**
	 * Whether the material is rendered with flat shading or not.
	 *
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshPhongMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshPhongMaterialProperties>> {
}
declare class MeshPhongMaterial extends Material {
	/**
	 * Constructs a new mesh phong material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: MeshPhongMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshPhongMaterial: boolean;
	setValues(values?: MeshPhongMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshPhongMaterial extends MeshPhongMaterialProperties {
}
export interface MeshStandardMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (1,1,1)
	 */
	color: Color;
	/**
	 * How rough the material appears. `0.0` means a smooth mirror reflection, `1.0`
	 * means fully diffuse. If `roughnessMap` is also provided,
	 * both values are multiplied.
	 *
	 * @default 1
	 */
	roughness: number;
	/**
	 * How much the material is like a metal. Non-metallic materials such as wood
	 * or stone use `0.0`, metallic use `1.0`, with nothing (usually) in between.
	 * A value between `0.0` and `1.0` could be used for a rusty metal look.
	 * If `metalnessMap` is also provided, both values are multiplied.
	 *
	 * @default 0
	 */
	metalness: number;
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
	 * color is modulated by the diffuse `color`.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * The light map. Requires a second set of UVs.
	 *
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * Intensity of the baked light.
	 *
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * The red channel of this texture is used as the ambient occlusion map.
	 * Requires a second set of UVs.
	 *
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
	 * disables ambient occlusion. Where intensity is `1` and the AO map's
	 * red channel is also `1`, ambient light is fully occluded on a surface.
	 *
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * Emissive (light) color of the material, essentially a solid color
	 * unaffected by other lighting.
	 *
	 * @default (0,0,0)
	 */
	emissive: Color;
	/**
	 * Intensity of the emissive light. Modulates the emissive color.
	 *
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * Set emissive (glow) map. The emissive map color is modulated by the
	 * emissive color and the emissive intensity. If you have an emissive map,
	 * be sure to set the emissive color to something other than black.
	 *
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * The texture to create a bump map. The black and white values map to the
	 * perceived depth in relation to the lights. Bump doesn't actually affect
	 * the geometry of the object, only the lighting. If a normal map is defined
	 * this will be ignored.
	 *
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * How much the bump map affects the material. Typical range is `[0,1]`.
	 *
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * The texture to create a normal map. The RGB values affect the surface
	 * normal for each pixel fragment and change the way the color is lit. Normal
	 * maps do not change the actual shape of the surface, only the lighting. In
	 * case the material has a normal map authored using the left handed
	 * convention, the `y` component of `normalScale` should be negated to compensate
	 * for the different handedness.
	 *
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * The type of normal map.
	 *
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * How much the normal map affects the material. Typical value range is `[0,1]`.
	 *
	 * @default (1,1)
	 */
	normalScale: Vector2;
	/**
	 * The displacement map affects the position of the mesh's vertices. Unlike
	 * other maps which only affect the light and shade of the material the
	 * displaced vertices can cast shadows, block other objects, and otherwise
	 * act as real geometry. The displacement texture is an image where the value
	 * of each pixel (white being the highest) is mapped against, and
	 * repositions, the vertices of the mesh.
	 *
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * How much the displacement map affects the mesh (where black is no
	 * displacement, and white is maximum displacement). Without a displacement
	 * map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementScale: number;
	/**
	 * The offset of the displacement map's values on the mesh's vertices.
	 * The bias is added to the scaled sample of the displacement map.
	 * Without a displacement map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * The green channel of this texture is used to alter the roughness of the
	 * material.
	 *
	 * @default null
	 */
	roughnessMap: Texture | null;
	/**
	 * The blue channel of this texture is used to alter the metalness of the
	 * material.
	 *
	 * @default null
	 */
	metalnessMap: Texture | null;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * The environment map. To ensure a physically correct rendering, environment maps
	 * are internally pre-processed with {@link PMREMGenerator}.
	 *
	 * @default null
	 */
	envMap: Texture | null;
	/**
	 * The rotation of the environment map in radians.
	 *
	 * @default (0,0,0)
	 */
	envMapRotation: Euler;
	/**
	 * Scales the effect of the environment map by multiplying its color.
	 *
	 * @default 1
	 */
	envMapIntensity: number;
	/**
	 * Renders the geometry as a wireframe.
	 *
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * Controls the thickness of the wireframe.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Defines appearance of wireframe ends.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinecap: "round" | "bevel" | "miter";
	/**
	 * Defines appearance of wireframe joints.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinejoin: "round" | "bevel" | "miter";
	/**
	 * Whether the material is rendered with flat shading or not.
	 *
	 * @default false
	 */
	flatShading: boolean;
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshStandardMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshStandardMaterialProperties>> {
}
declare class MeshStandardMaterial extends Material {
	/**
	 * Constructs a new mesh standard material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: MeshStandardMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshStandardMaterial: boolean;
	setValues(values?: MeshStandardMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshStandardMaterial extends MeshStandardMaterialProperties {
}
export interface MeshPhysicalMaterialProperties extends MeshStandardMaterialProperties {
	/**
	 * The rotation of the anisotropy in tangent, bitangent space, measured in radians
	 * counter-clockwise from the tangent. When `anisotropyMap` is present, this
	 * property provides additional rotation to the vectors in the texture.
	 *
	 * @default 1
	 */
	anisotropyRotation: number;
	/**
	 * Red and green channels represent the anisotropy direction in `[-1, 1]` tangent,
	 * bitangent space, to be rotated by `anisotropyRotation`. The blue channel
	 * contains strength as `[0, 1]` to be multiplied by `anisotropy`.
	 *
	 * @default null
	 */
	anisotropyMap: Texture | null;
	/**
	 * The red channel of this texture is multiplied against `clearcoat`,
	 * for per-pixel control over a coating's intensity.
	 *
	 * @default null
	 */
	clearcoatMap: Texture | null;
	/**
	 * Roughness of the clear coat layer, from `0.0` to `1.0`.
	 *
	 * @default 0
	 */
	clearcoatRoughness: number;
	/**
	 * The green channel of this texture is multiplied against
	 * `clearcoatRoughness`, for per-pixel control over a coating's roughness.
	 *
	 * @default null
	 */
	clearcoatRoughnessMap: Texture | null;
	/**
	 * How much `clearcoatNormalMap` affects the clear coat layer, from
	 * `(0,0)` to `(1,1)`.
	 *
	 * @default (1,1)
	 */
	clearcoatNormalScale: Vector2;
	/**
	 * Can be used to enable independent normals for the clear coat layer.
	 *
	 * @default null
	 */
	clearcoatNormalMap: Texture | null;
	/**
	 * Index-of-refraction for non-metallic materials, from `1.0` to `2.333`.
	 *
	 * @default 1.5
	 */
	ior: number;
	/**
	 * Degree of reflectivity, from `0.0` to `1.0`. Default is `0.5`, which
	 * corresponds to an index-of-refraction of `1.5`.
	 *
	 * This models the reflectivity of non-metallic materials. It has no effect
	 * when `metalness` is `1.0`
	 *
	 * @name MeshPhysicalMaterial#reflectivity
	 * @default 0.5
	 */
	get reflectivity(): number;
	set reflectivity(reflectivity: number);
	/**
	 * The red channel of this texture is multiplied against `iridescence`, for per-pixel
	 * control over iridescence.
	 *
	 * @default null
	 */
	iridescenceMap: Texture | null;
	/**
	 * Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
	 * Between `1.0` to `2.333`.
	 *
	 * @default 1.3
	 */
	iridescenceIOR: number;
	/**
	 *Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer.
	 Thickness of iridescence layer has an equivalent effect of the one `thickness` has on `ior`.
	 *
	 * @default [100,400]
	 */
	iridescenceThicknessRange: [
		number,
		number
	];
	/**
	 * A texture that defines the thickness of the iridescence layer, stored in the green channel.
	 * Minimum and maximum values of thickness are defined by `iridescenceThicknessRange` array:
	 * - `0.0` in the green channel will result in thickness equal to first element of the array.
	 * - `1.0` in the green channel will result in thickness equal to second element of the array.
	 * - Values in-between will linearly interpolate between the elements of the array.
	 *
	 * @default null
	 */
	iridescenceThicknessMap: Texture | null;
	/**
	 * The sheen tint.
	 *
	 * @default (0,0,0)
	 */
	sheenColor: Color;
	/**
	 * The RGB channels of this texture are multiplied against  `sheenColor`, for per-pixel control
	 * over sheen tint.
	 *
	 * @default null
	 */
	sheenColorMap: Texture | null;
	/**
	 * Roughness of the sheen layer, from `0.0` to `1.0`.
	 *
	 * @default 1
	 */
	sheenRoughness: number;
	/**
	 * The alpha channel of this texture is multiplied against `sheenRoughness`, for per-pixel control
	 * over sheen roughness.
	 *
	 * @default null
	 */
	sheenRoughnessMap: Texture | null;
	/**
	 * The red channel of this texture is multiplied against `transmission`, for per-pixel control over
	 * optical transparency.
	 *
	 * @default null
	 */
	transmissionMap: Texture | null;
	/**
	 * The thickness of the volume beneath the surface. The value is given in the
	 * coordinate space of the mesh. If the value is `0` the material is
	 * thin-walled. Otherwise the material is a volume boundary.
	 *
	 * @default 0
	 */
	thickness: number;
	/**
	 * A texture that defines the thickness, stored in the green channel. This will
	 * be multiplied by `thickness`.
	 *
	 * @default null
	 */
	thicknessMap: Texture | null;
	/**
	 * Density of the medium given as the average distance that light travels in
	 * the medium before interacting with a particle. The value is given in world
	 * space units, and must be greater than zero.
	 *
	 * @default Infinity
	 */
	attenuationDistance: number;
	/**
	 * The color that white light turns into due to absorption when reaching the
	 * attenuation distance.
	 *
	 * @default (1,1,1)
	 */
	attenuationColor: Color;
	/**
	 * A float that scales the amount of specular reflection for non-metals only.
	 * When set to zero, the model is effectively Lambertian. From `0.0` to `1.0`.
	 *
	 * @default 1
	 */
	specularIntensity: number;
	/**
	 * The alpha channel of this texture is multiplied against `specularIntensity`,
	 * for per-pixel control over specular intensity.
	 *
	 * @default null
	 */
	specularIntensityMap: Texture | null;
	/**
	 * Tints the specular reflection at normal incidence for non-metals only.
	 *
	 * @default (1,1,1)
	 */
	specularColor: Color;
	/**
	 * The RGB channels of this texture are multiplied against `specularColor`,
	 * for per-pixel control over specular color.
	 *
	 * @default null
	 */
	specularColorMap: Texture | null;
	set anisotropy(value: number);
	/**
	 * The anisotropy strength, from `0.0` to `1.0`.
	 *
	 * @default 0
	 */
	get anisotropy(): number;
	set clearcoat(value: number);
	/**
	 * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
	 * clear coat related properties to enable multilayer materials that have a
	 * thin translucent layer over the base layer.
	 *
	 * @default 0
	 */
	get clearcoat(): number;
	set iridescence(value: number);
	/**
	 * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
	 * the surface and the viewer, from `0.0` to `1.0`.
	 *
	 * @default 0
	 */
	get iridescence(): number;
	set dispersion(value: number);
	/**
	 * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
	 * through a relatively clear volume. Any value zero or larger is valid, the typical range of
	 * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
	 *
	 * @default 0
	 */
	get dispersion(): number;
	set sheen(value: number);
	/**
	 * The intensity of the sheen layer, from `0.0` to `1.0`.
	 *
	 * @default 0
	 */
	get sheen(): number;
	set transmission(value: number);
	/**
	 * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
	 *
	 * Thin, transparent or semitransparent, plastic or glass materials remain
	 * largely reflective even if they are fully transmissive. The transmission
	 * property can be used to model these materials.
	 *
	 * When transmission is non-zero, `opacity` should be  set to `1`.
	 *
	 * @default 0
	 */
	get transmission(): number;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshPhysicalMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshPhysicalMaterialProperties>> {
}
declare class MeshPhysicalMaterial extends MeshStandardMaterial {
	constructor(parameters?: MeshPhysicalMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshPhysicalMaterial: boolean;
	setValues(values?: MeshPhysicalMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshPhysicalMaterial extends MeshPhysicalMaterialProperties {
}
export interface MeshToonMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (1,1,1)
	 */
	color: Color;
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
	 * color is modulated by the diffuse `color`.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * Gradient map for toon shading. It's required to set
	 * {@link Texture#minFilter} and {@link Texture#magFilter} to {@linkNearestFilter}
	 * when using this type of texture.
	 *
	 * @default null
	 */
	gradientMap: Texture | null;
	/**
	 * The light map. Requires a second set of UVs.
	 *
	 * @default null
	 */
	lightMap: Texture | null;
	/**
	 * Intensity of the baked light.
	 *
	 * @default 1
	 */
	lightMapIntensity: number;
	/**
	 * The red channel of this texture is used as the ambient occlusion map.
	 * Requires a second set of UVs.
	 *
	 * @default null
	 */
	aoMap: Texture | null;
	/**
	 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
	 * disables ambient occlusion. Where intensity is `1` and the AO map's
	 * red channel is also `1`, ambient light is fully occluded on a surface.
	 *
	 * @default 1
	 */
	aoMapIntensity: number;
	/**
	 * Emissive (light) color of the material, essentially a solid color
	 * unaffected by other lighting.
	 *
	 * @default (0,0,0)
	 */
	emissive: Color;
	/**
	 * Intensity of the emissive light. Modulates the emissive color.
	 *
	 * @default 1
	 */
	emissiveIntensity: number;
	/**
	 * Set emissive (glow) map. The emissive map color is modulated by the
	 * emissive color and the emissive intensity. If you have an emissive map,
	 * be sure to set the emissive color to something other than black.
	 *
	 * @default null
	 */
	emissiveMap: Texture | null;
	/**
	 * The texture to create a bump map. The black and white values map to the
	 * perceived depth in relation to the lights. Bump doesn't actually affect
	 * the geometry of the object, only the lighting. If a normal map is defined
	 * this will be ignored.
	 *
	 * @default null
	 */
	bumpMap: Texture | null;
	/**
	 * How much the bump map affects the material. Typical range is `[0,1]`.
	 *
	 * @default 1
	 */
	bumpScale: number;
	/**
	 * The texture to create a normal map. The RGB values affect the surface
	 * normal for each pixel fragment and change the way the color is lit. Normal
	 * maps do not change the actual shape of the surface, only the lighting. In
	 * case the material has a normal map authored using the left handed
	 * convention, the `y` component of `normalScale` should be negated to compensate
	 * for the different handedness.
	 *
	 * @default null
	 */
	normalMap: Texture | null;
	/**
	 * The type of normal map.
	 *
	 * @default TangentSpaceNormalMap
	 */
	normalMapType: NormalMapTypes;
	/**
	 * How much the normal map affects the material. Typical value range is `[0,1]`.
	 *
	 * @default (1,1)
	 */
	normalScale: Vector2;
	/**
	 * The displacement map affects the position of the mesh's vertices. Unlike
	 * other maps which only affect the light and shade of the material the
	 * displaced vertices can cast shadows, block other objects, and otherwise
	 * act as real geometry. The displacement texture is an image where the value
	 * of each pixel (white being the highest) is mapped against, and
	 * repositions, the vertices of the mesh.
	 *
	 * @default null
	 */
	displacementMap: Texture | null;
	/**
	 * How much the displacement map affects the mesh (where black is no
	 * displacement, and white is maximum displacement). Without a displacement
	 * map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementScale: number;
	/**
	 * The offset of the displacement map's values on the mesh's vertices.
	 * The bias is added to the scaled sample of the displacement map.
	 * Without a displacement map set, this value is not applied.
	 *
	 * @default 0
	 */
	displacementBias: number;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * Renders the geometry as a wireframe.
	 *
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * Controls the thickness of the wireframe.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Defines appearance of wireframe ends.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinecap: "round" | "bevel" | "miter";
	/**
	 * Defines appearance of wireframe joints.
	 *
	 * Can only be used with {@link SVGRenderer}.
	 *
	 * @default 'round'
	 */
	wireframeLinejoin: "round" | "bevel" | "miter";
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshToonMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MeshToonMaterialProperties>> {
}
declare class MeshToonMaterial extends Material {
	/**
	 * Constructs a new mesh toon material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: MeshToonMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMeshToonMaterial: boolean;
	setValues(values?: MeshToonMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MeshToonMaterial extends MeshToonMaterialProperties {
}
export interface PointsMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (1,1,1)
	 */
	color: Color;
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
	 * color is modulated by the diffuse `color`.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * Defines the size of the points in pixels.
	 *
	 * Might be capped if the value exceeds hardware dependent parameters like [gl.ALIASED_POINT_SIZE_RANGE](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParamete).
	 *
	 * @default 1
	 */
	size: number;
	/**
	 * Specifies whether size of individual points is attenuated by the camera depth (perspective camera only).
	 *
	 * @default true
	 */
	sizeAttenuation: boolean;
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface PointsMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<PointsMaterialProperties>> {
}
declare class PointsMaterial extends Material {
	/**
	 * Constructs a new points material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: PointsMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isPointsMaterial: boolean;
	setValues(values?: PointsMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface PointsMaterial extends PointsMaterialProperties {
}
declare class Uniform<T = any> {
	/**
	 * Create a new instance of {@link THREE.Uniform | Uniform}
	 * @param value An object containing the value to set up the uniform. It's type must be one of the Uniform Types described above.
	 */
	constructor(value: T);
	/**
	 * Current value of the uniform.
	 */
	value: T;
	/**
	 * Returns a clone of this uniform.
	 * @remarks
	 * If the uniform's {@link value} property is an {@link Object | Object} with a `clone()` method, this is used,
	 * otherwise the value is copied by assignment Array values are **shared** between cloned {@link THREE.UniformUniform | Uniform}s.
	 */
	clone(): Uniform<T>;
}
declare class UniformsGroup extends EventDispatcher<{
	dispose: {};
}> {
	constructor();
	readonly isUniformsGroup: true;
	id: number;
	usage: Usage;
	uniforms: Array<Uniform | Uniform[]>;
	add(uniform: Uniform | Uniform[]): this;
	remove(uniform: Uniform | Uniform[]): this;
	setName(name: string): this;
	setUsage(value: Usage): this;
	dispose(): this;
	copy(source: UniformsGroup): this;
	clone(): UniformsGroup;
}
// eslint-disable-next-line @typescript-eslint/naming-convention
export interface IUniform<TValue = any> {
	value: TValue;
}
declare const UniformsLib: {
	common: {
		diffuse: IUniform<Color>;
		opacity: IUniform<number>;
		map: IUniform<unknown>;
		mapTransform: IUniform<Matrix3>;
		alphaMap: IUniform<unknown>;
		alphaMapTransform: IUniform<Matrix3>;
		alphaTest: IUniform<number>;
	};
	specularmap: {
		specularMap: IUniform<unknown>;
		specularMapTransform: IUniform<Matrix3>;
	};
	envmap: {
		envMap: IUniform<unknown>;
		envMapRotation: IUniform<Matrix3>;
		flipEnvMap: IUniform<number>;
		reflectivity: IUniform<number>;
		ior: IUniform<number>;
		refractRatio: IUniform<number>;
	};
	aomap: {
		aoMap: IUniform<unknown>;
		aoMapIntensity: IUniform<number>;
		aoMapTransform: IUniform<Matrix3>;
	};
	lightmap: {
		lightMap: IUniform<number>;
		lightMapIntensity: IUniform<number>;
		lightMapTransform: IUniform<Matrix3>;
	};
	bumpmap: {
		bumpMap: IUniform<unknown>;
		bumpMapTransform: IUniform<Matrix3>;
		bumpScale: IUniform<number>;
	};
	normalmap: {
		normalMap: IUniform<unknown>;
		normalMapTransform: IUniform<Matrix3>;
		normalScale: IUniform<Vector2>;
	};
	displacementmap: {
		displacementMap: IUniform<unknown>;
		displacementMapTransform: IUniform<Matrix3>;
		displacementScale: IUniform<number>;
		displacementBias: IUniform<number>;
	};
	emissivemap: {
		emissiveMap: IUniform<unknown>;
		emissiveMapTransform: IUniform<Matrix3>;
	};
	metalnessmap: {
		metalnessMap: IUniform<unknown>;
		metalnessMapTransform: IUniform<Matrix3>;
	};
	roughnessmap: {
		roughnessMap: IUniform<unknown>;
		roughnessMapTransform: IUniform<Matrix3>;
	};
	gradientmap: {
		gradientMap: IUniform<unknown>;
	};
	fog: {
		fogDensity: IUniform<number>;
		fogNear: IUniform<number>;
		fogFar: IUniform<number>;
		fogColor: IUniform<Color>;
	};
	lights: {
		ambientLightColor: IUniform<unknown[]>;
		lightProbe: IUniform<unknown[]>;
		directionalLights: {
			value: unknown[];
			properties: {
				direction: {};
				color: {};
			};
		};
		directionalLightShadows: {
			value: unknown[];
			properties: {
				shadowIntensity: number;
				shadowBias: {};
				shadowNormalBias: {};
				shadowRadius: {};
				shadowMapSize: {};
			};
		};
		directionalShadowMap: IUniform<unknown[]>;
		directionalShadowMatrix: IUniform<unknown[]>;
		spotLights: {
			value: unknown[];
			properties: {
				color: {};
				position: {};
				direction: {};
				distance: {};
				coneCos: {};
				penumbraCos: {};
				decay: {};
			};
		};
		spotLightShadows: {
			value: unknown[];
			properties: {
				shadowIntensity: number;
				shadowBias: {};
				shadowNormalBias: {};
				shadowRadius: {};
				shadowMapSize: {};
			};
		};
		spotLightMap: IUniform<unknown[]>;
		spotShadowMap: IUniform<unknown[]>;
		spotLightMatrix: IUniform<unknown[]>;
		pointLights: {
			value: unknown[];
			properties: {
				color: {};
				position: {};
				decay: {};
				distance: {};
			};
		};
		pointLightShadows: {
			value: unknown[];
			properties: {
				shadowIntensity: number;
				shadowBias: {};
				shadowNormalBias: {};
				shadowRadius: {};
				shadowMapSize: {};
				shadowCameraNear: {};
				shadowCameraFar: {};
			};
		};
		pointShadowMap: IUniform<unknown[]>;
		pointShadowMatrix: IUniform<unknown[]>;
		hemisphereLights: {
			value: unknown[];
			properties: {
				direction: {};
				skycolor: {};
				groundColor: {};
			};
		};
		rectAreaLights: {
			value: unknown[];
			properties: {
				color: {};
				position: {};
				width: {};
				height: {};
			};
		};
		ltc_1: IUniform<unknown>;
		ltc_2: IUniform<unknown>;
	};
	points: {
		diffuse: IUniform<Color>;
		opacity: IUniform<number>;
		size: IUniform<number>;
		scale: IUniform<number>;
		map: IUniform<unknown>;
		alphaMap: IUniform<unknown>;
		alphaTest: IUniform<number>;
		uvTransform: IUniform<Matrix3>;
	};
	sprite: {
		diffuse: IUniform<Color>;
		opacity: IUniform<number>;
		center: IUniform<Vector2>;
		rotation: IUniform<number>;
		map: IUniform<unknown>;
		mapTransform: IUniform<Matrix3>;
		alphaMap: IUniform<unknown>;
		alphaTest: IUniform<number>;
	};
};
export interface ShaderMaterialProperties extends MaterialProperties {
	/**
	 * Defines custom constants using `#define` directives within the GLSL code
	 * for both the vertex shader and the fragment shader; each key/value pair
	 * yields another directive.
	 * ```js
	 * defines: {
	 * 	FOO: 15,
	 * 	BAR: true
	 * }
	 * ```
	 * Yields the lines:
	 * ```
	 * #define FOO 15
	 * #define BAR true
	 * ```
	 */
	defines: Record<string, unknown>;
	/**
	 * An object of the form:
	 * ```js
	 * {
	 * 	"uniform1": { value: 1.0 },
	 * 	"uniform2": { value: 2 }
	 * }
	 * ```
	 * specifying the uniforms to be passed to the shader code; keys are uniform
	 * names, values are definitions of the form
	 * ```
	 * {
	 * 	value: 1.0
	 * }
	 * ```
	 * where `value` is the value of the uniform. Names must match the name of
	 * the uniform, as defined in the GLSL code. Note that uniforms are refreshed
	 * on every frame, so updating the value of the uniform will immediately
	 * update the value available to the GLSL code.
	 */
	uniforms: {
		[uniform: string]: IUniform;
	};
	/**
	 * An array holding uniforms groups for configuring UBOs.
	 */
	uniformsGroups: Array<UniformsGroup>;
	/**
	 * Vertex shader GLSL code. This is the actual code for the shader.
	 */
	vertexShader: string;
	/**
	 * Fragment shader GLSL code. This is the actual code for the shader.
	 */
	fragmentShader: string;
	/**
	 * Controls line thickness or lines.
	 *
	 * WebGL and WebGPU ignore this setting and always render line primitives with a
	 * width of one pixel.
	 *
	 * @default 1
	 */
	linewidth: number;
	/**
	 * Renders the geometry as a wireframe.
	 *
	 * @default false
	 */
	wireframe: boolean;
	/**
	 * Controls the thickness of the wireframe.
	 *
	 * WebGL and WebGPU ignore this property and always render
	 * 1 pixel wide lines.
	 *
	 * @default 1
	 */
	wireframeLinewidth: number;
	/**
	 * Defines whether the material color is affected by global fog settings; `true`
	 * to pass fog uniforms to the shader.
	 *
	 * Setting this property to `true` requires the definition of fog uniforms. It is
	 * recommended to use `UniformsUtils.merge()` to combine the custom shader uniforms
	 * with predefined fog uniforms.
	 *
	 * ```js
	 * const material = new ShaderMaterial( {
	 *     uniforms: UniformsUtils.merge( [ UniformsLib[ 'fog' ], shaderUniforms ] );
	 *     vertexShader: vertexShader,
	 *     fragmentShader: fragmentShader,
	 *     fog: true
	 * } );
	 * ```
	 *
	 * @default false
	 */
	fog: boolean;
	/**
	 * Defines whether this material uses lighting; `true` to pass uniform data
	 * related to lighting to this shader.
	 *
	 * @default false
	 */
	lights: boolean;
	/**
	 * Defines whether this material supports clipping; `true` to let the renderer
	 * pass the clippingPlanes uniform.
	 *
	 * @default false
	 */
	clipping: boolean;
	/**
	 * This object allows to enable certain WebGL 2 extensions.
	 *
	 * - clipCullDistance: set to `true` to use vertex shader clipping
	 * - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID
	 */
	extensions: {
		clipCullDistance: boolean;
		multiDraw: boolean;
	};
	/**
	 * When the rendered geometry doesn't include these attributes but the
	 * material does, these default values will be passed to the shaders. This
	 * avoids errors when buffer data is missing.
	 *
	 * - color: [ 1, 1, 1 ]
	 * - uv: [ 0, 0 ]
	 * - uv1: [ 0, 0 ]
	 */
	defaultAttributeValues: {
		color: [
			number,
			number,
			number
		];
		uv: [
			number,
			number
		];
		uv1: [
			number,
			number
		];
	};
	/**
	 * If set, this calls [gl.bindAttribLocation](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation)
	 * to bind a generic vertex index to an attribute variable.
	 *
	 * @default undefined
	 */
	index0AttributeName: string | undefined;
	/**
	 * Can be used to force a uniform update while changing uniforms in
	 * {@link Object3D#onBeforeRender}.
	 *
	 * @default false
	 */
	uniformsNeedUpdate: boolean;
	/**
	 * Defines the GLSL version of custom shader code.
	 *
	 * @default null
	 */
	glslVersion: GLSLVersion | null;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface ShaderMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<ShaderMaterialProperties>> {
}
export type ShaderMaterialUniformJSON = {
	type: "t";
	value: string;
} | {
	type: "c";
	value: number;
} | {
	type: "v2";
	value: Vector2Tuple;
} | {
	type: "v3";
	value: Vector3Tuple;
} | {
	type: "v4";
	value: Vector4Tuple;
} | {
	type: "m3";
	value: Matrix3Tuple;
} | {
	type: "m4";
	value: Matrix4Tuple;
} | {
	value: unknown;
};
export interface ShaderMaterialJSON extends MaterialJSON {
	glslVersion: number | null;
	uniforms: Record<string, ShaderMaterialUniformJSON>;
	defines?: Record<string, unknown>;
	vertexShader: string;
	fragmentShader: string;
	lights: boolean;
	clipping: boolean;
	extensions?: Record<string, boolean>;
}
declare class ShaderMaterial extends Material {
	/**
	 * Constructs a new shader material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: ShaderMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isShaderMaterial: boolean;
	setValues(values?: ShaderMaterialParameters): void;
	toJSON(meta?: JSONMeta): ShaderMaterialJSON;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface ShaderMaterial extends ShaderMaterialProperties {
	defines: Record<string, unknown>;
}
declare class RawShaderMaterial extends ShaderMaterial {
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isRawShaderMaterial: boolean;
}
export interface ShadowMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (0,0,0)
	 */
	color: Color;
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface ShadowMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<ShadowMaterialProperties>> {
}
declare class ShadowMaterial extends Material {
	/**
	 * Constructs a new shadow material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: ShadowMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isShadowMaterial: boolean;
	setValues(values?: ShadowMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface ShadowMaterial extends ShadowMaterialProperties {
}
export interface SpriteMaterialProperties extends MaterialProperties {
	/**
	 * Color of the material.
	 *
	 * @default (1,1,1)
	 */
	color: Color;
	/**
	 * The color map. May optionally include an alpha channel, typically combined
	 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
	 * color is modulated by the diffuse `color`.
	 *
	 * @default null
	 */
	map: Texture | null;
	/**
	 * The alpha map is a grayscale texture that controls the opacity across the
	 * surface (black: fully transparent; white: fully opaque).
	 *
	 * Only the color of the texture is used, ignoring the alpha channel if one
	 * exists. For RGB and RGBA textures, the renderer will use the green channel
	 * when sampling this texture due to the extra bit of precision provided for
	 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
	 * luminance/alpha textures will also still work as expected.
	 *
	 * @default null
	 */
	alphaMap: Texture | null;
	/**
	 * The rotation of the sprite in radians.
	 *
	 * @default 0
	 */
	rotation: number;
	/**
	 * Specifies whether size of the sprite is attenuated by the camera depth (perspective camera only).
	 *
	 * @default true
	 */
	sizeAttenuation: boolean;
	/**
	 * Whether the material is affected by fog or not.
	 *
	 * @default true
	 */
	fog: boolean;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface SpriteMaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<SpriteMaterialProperties>> {
}
declare class SpriteMaterial extends Material {
	/**
	 * Constructs a new sprite material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor(parameters?: SpriteMaterialParameters);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isSpriteMaterial: boolean;
	setValues(values?: SpriteMaterialParameters): void;
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface SpriteMaterial extends SpriteMaterialProperties {
}
declare class Sprite<TEventMap extends Object3DEventMap = Object3DEventMap> extends Object3D<TEventMap> {
	/**
	 * Creates a new Sprite.
	 * @param material An instance of {@link THREE.SpriteMaterial | SpriteMaterial}. Default {@link THREE.SpriteMaterial | `new SpriteMaterial()`}, _with white color_.
	 */
	constructor(material?: SpriteMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link Sprite}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSprite: true;
	/**
	 * @override
	 * @defaultValue `Sprite`
	 */
	override readonly type: string | "Sprite";
	/**
	 * Whether the object gets rendered into shadow map.
	 * No effect in {@link Sprite}.
	 * @ignore
	 * @hidden
	 * @defaultValue `false`
	 */
	override castShadow: false;
	geometry: BufferGeometry;
	/**
	 * An instance of {@link THREE.SpriteMaterial | SpriteMaterial}, defining the object's appearance.
	 * @defaultValue {@link THREE.SpriteMaterial | `new SpriteMaterial()`}, _with white color_.
	 */
	material: SpriteMaterial;
	/**
	 * The sprite's anchor point, and the point around which the {@link Sprite} rotates.
	 * A value of (0.5, 0.5) corresponds to the midpoint of the sprite.
	 * A value of (0, 0) corresponds to the lower left corner of the sprite.
	 * @defaultValue {@link THREE.Vector2 | `new Vector2(0.5, 0.5)`}.
	 */
	center: Vector2;
	/**
	 * The number of instances of this sprite.
	 * Can only be used with {@link WebGPURenderer}.
	 *
	 * @default 1
	 */
	count: number;
}
declare class Frustum {
	constructor(p0?: Plane, p1?: Plane, p2?: Plane, p3?: Plane, p4?: Plane, p5?: Plane);
	/**
	 * Array of 6 vectors.
	 */
	planes: Plane[];
	set(p0: Plane, p1: Plane, p2: Plane, p3: Plane, p4: Plane, p5: Plane): Frustum;
	clone(): this;
	copy(frustum: Frustum): this;
	setFromProjectionMatrix(m: Matrix4, coordinateSystem?: CoordinateSystem, reversedDepth?: boolean): this;
	intersectsObject(object: Object3D): boolean;
	intersectsSprite(sprite: Sprite): boolean;
	intersectsSphere(sphere: Sphere): boolean;
	intersectsBox(box: Box3): boolean;
	containsPoint(point: Vector3): boolean;
}
declare class WebGLRenderTarget<TTexture extends Texture | Texture[] = Texture> extends RenderTarget<TTexture> {
	constructor(width?: number, height?: number, options?: RenderTargetOptions);
	readonly isWebGLRenderTarget: true;
}
export interface LightShadowJSON {
	intensity?: number;
	bias?: number;
	normalBias?: number;
	radius?: number;
	mapSize?: Vector2Tuple;
	camera: Omit<Object3DJSONObject, "matrix">;
}
declare class LightShadow<TCamera extends Camera = Camera> {
	/**
	 * Create a new instance of {@link LightShadow}
	 * @param camera The light's view of the world.
	 */
	constructor(camera: TCamera);
	/**
	 * The light's view of the world.
	 * @remark This is used to generate a depth map of the scene; objects behind other objects from the light's perspective will be in shadow.
	 */
	camera: TCamera;
	/**
	 * The intensity of the shadow. The default is `1`. Valid values are in the range `[0, 1]`.
	 */
	intensity: number;
	/**
	 * Shadow map bias, how much to add or subtract from the normalized depth when deciding whether a surface is in shadow.
	 * @remark The Very tiny adjustments here (in the order of 0.0001) may help reduce artifacts in shadows.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	bias: number;
	/**
	 * Defines how much the position used to query the shadow map is offset along the object normal.
	 * @remark The Increasing this value can be used to reduce shadow acne especially in large scenes where light shines onto geometry at a shallow angle.
	 * @remark The cost is that shadows may appear distorted.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	normalBias: number;
	/**
	 * Setting this to values greater than 1 will blur the edges of the shadow.toi
	 * @remark High values will cause unwanted banding effects in the shadows - a greater {@link LightShadow.mapSize | mapSize
	 *  will allow for a higher value to be used here before these effects become visible.
	 * @remark If {@link THREE.WebGLRenderer.shadowMap.type | WebGLRenderer.shadowMap.type} is set to {@link Renderer | PCFSoftShadowMap},
	 * radius has no effect and it is recommended to increase softness by decreasing {@link LightShadow.mapSize | mapSize} instead.
	 * @remark Note that this has no effect if the {@link THREE.WebGLRenderer.shadowMap | WebGLRenderer.shadowMap}.{@link THREE.WebGLShadowMap.type | type}
	 * is set to {@link THREE.BasicShadowMap | BasicShadowMap}.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	radius: number;
	/**
	 * The amount of samples to use when blurring a VSM shadow map.
	 * @remarks Expects a `Integer`
	 * @defaultValue `8`
	 */
	blurSamples: number;
	/**
	 * A {@link THREE.Vector2 | Vector2} defining the width and height of the shadow map.
	 * @remarks Higher values give better quality shadows at the cost of computation time.
	 * @remarks Values must be powers of 2, up to the {@link THREE.WebGLRenderer.capabilities | WebGLRenderer.capabilities}.maxTextureSize for a given device,
	 * although the width and height don't have to be the same (so, for example, (512, 1024) is valid).
	 * @defaultValue `new THREE.Vector2(512, 512)`
	 */
	mapSize: Vector2;
	/**
	 * The type of shadow texture. The default is `UnsignedByteType`.
	 *
	 * @default UnsignedByteType
	 */
	mapType: TextureDataType;
	/**
	 * The depth map generated using the internal camera; a location beyond a pixel's depth is in shadow. Computed internally during rendering.
	 * @defaultValue null
	 */
	map: WebGLRenderTarget | null;
	/**
	 * The distribution map generated using the internal camera; an occlusion is calculated based on the distribution of depths. Computed internally during rendering.
	 * @defaultValue null
	 */
	mapPass: WebGLRenderTarget | null;
	/**
	 * Model to shadow camera space, to compute location and depth in shadow map.
	 * Stored in a {@link Matrix4 | Matrix4}.
	 * @remarks This is computed internally during rendering.
	 * @defaultValue new THREE.Matrix4()
	 */
	matrix: Matrix4;
	/**
	 * Enables automatic updates of the light's shadow. If you do not require dynamic lighting / shadows, you may set this to `false`.
	 * @defaultValue `true`
	 */
	autoUpdate: boolean;
	/**
	 * When set to `true`, shadow maps will be updated in the next `render` call.
	 * If you have set {@link autoUpdate} to `false`, you will need to set this property to `true` and then make a render call to update the light's shadow.
	 * @defaultValue `false`
	 */
	needsUpdate: boolean;
	/**
	 * Used internally by the renderer to get the number of viewports that need to be rendered for this shadow.
	 */
	getViewportCount(): number;
	/**
	 * Copies value of all the properties from the {@link {@link LightShadow} | source} to this Light.
	 * @param source
	 */
	copy(source: LightShadow): this;
	/**
	 * Creates a new {@link LightShadow} with the same properties as this one.
	 */
	clone(recursive?: boolean): this;
	/**
	 * Serialize this LightShadow.
	 */
	toJSON(): LightShadowJSON;
	/**
	 * Gets the shadow cameras frustum
	 * @remarks
	 * Used internally by the renderer to cull objects.
	 */
	getFrustum(): Frustum;
	/**
	 * Update the matrices for the camera and shadow, used internally by the renderer.
	 * @param light The light for which the shadow is being rendered.
	 */
	updateMatrices(light: Light): void;
	getViewport(viewportIndex: number): Vector4;
	/**
	 * Used internally by the renderer to extend the shadow map to contain all viewports
	 */
	getFrameExtents(): Vector2;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
export interface LightJSON extends Object3DJSON {
	color: number;
	intensity: number;
}
export interface LightEventMap extends Object3DEventMap {
	dispose: {};
}
declare abstract class Light<TShadowSupport extends LightShadow | undefined = LightShadow | undefined> extends Object3D<LightEventMap> {
	/**
	 * Creates a new {@link Light}
	 * @remarks
	 * **Note** that this is not intended to be called directly (use one of derived classes instead).
	 * @param color Hexadecimal color of the light. Default `0xffffff` _(white)_.
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`.
	 */
	constructor(color?: ColorRepresentation, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link HemisphereLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `Light`
	 */
	override readonly type: string | "Light";
	/**
	 * Color of the light. \
	 * @defaultValue `new THREE.Color(0xffffff)` _(white)_.
	 */
	color: Color;
	/**
	 * The light's intensity, or strength.
	 * The units of intensity depend on the type of light.
	 * @defaultValue `1`
	 */
	intensity: number;
	/**
	 * A {@link THREE.LightShadow | LightShadow} used to calculate shadows for this light.
	 * @remarks Available only on Light's that support shadows.
	 */
	shadow: TShadowSupport;
	/**
	 * Copies value of all the properties from the {@link Light | source} to this instance.
	 * @param source
	 * @param recursive
	 */
	copy(source: this, recursive?: boolean): this;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
	toJSON(meta?: JSONMeta): LightJSON;
}
export interface FogJSON {
	type: string;
	name: string;
	color: number;
	near: number;
	far: number;
}
declare class Fog {
	/**
	 * The color parameter is passed to the {@link THREE.Color | Color} constructor to set the color property
	 * @remarks
	 * Color can be a hexadecimal integer or a CSS-style string.
	 * @param color
	 * @param near Expects a `Float`
	 * @param far Expects a `Float`
	 */
	constructor(color: ColorRepresentation, near?: number, far?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link Fog}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isFog: true;
	/**
	 * Optional name of the object
	 * @remarks _(doesn't need to be unique)_.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * Fog color.
	 * @remarks If set to black, far away objects will be rendered black.
	 */
	color: Color;
	/**
	 * The minimum distance to start applying fog.
	 * @remarks Objects that are less than **near** units from the active camera won't be affected by fog.
	 * @defaultValue `1`
	 * @remarks Expects a `Float`
	 */
	near: number;
	/**
	 * The maximum distance at which fog stops being calculated and applied.
	 * @remarks Objects that are more than **far** units away from the active camera won't be affected by fog.
	 * @defaultValue `1000`
	 * @remarks Expects a `Float`
	 */
	far: number;
	/**
	 * Returns a new {@link Fog} instance with the same parameters as this one.
	 */
	clone(): Fog;
	/**
	 * Return {@link Fog} data in JSON format.
	 */
	toJSON(): FogJSON;
}
export interface FogExp2JSON {
	type: string;
	name: string;
	color: number;
	density: number;
}
declare class FogExp2 {
	/**
	 * The color parameter is passed to the {@link THREE.Color | Color} constructor to set the color property
	 * @remarks Color can be a hexadecimal integer or a CSS-style string.
	 * @param color
	 * @param density Expects a `Float`
	 */
	constructor(color: ColorRepresentation, density?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link FogExp2}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isFogExp2: true;
	/**
	 * Optional name of the object
	 * @remarks _(doesn't need to be unique)_.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * Fog color.
	 * @remarks If set to black, far away objects will be rendered black.
	 */
	color: Color;
	/**
	 * Defines how fast the fog will grow dense.
	 * @defaultValue `0.00025`
	 * @remarks Expects a `Float`
	 */
	density: number;
	/**
	 * Returns a new {@link FogExp2} instance with the same parameters as this one.
	 */
	clone(): FogExp2;
	/**
	 * Return {@link FogExp2} data in JSON format.
	 */
	toJSON(): FogExp2JSON;
}
export interface SceneJSONObject extends Object3DJSONObject {
	fog?: FogJSON | FogExp2JSON;
	backgroundBlurriness?: number;
	backgroundIntensity?: number;
	backgroundRotation: EulerTuple;
	environmentIntensity?: number;
	environmentRotation: EulerTuple;
}
export interface SceneJSON extends Object3DJSON {
	object: SceneJSONObject;
}
declare class Scene<TEventMap extends Object3DEventMap = Object3DEventMap> extends Object3D<TEventMap> {
	/**
	 * Create a new {@link Scene} object.
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link Scene}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isScene: true;
	/**
	 * @defaultValue `Scene`
	 */
	type: "Scene";
	/**
	 * A {@link Fog | fog} instance defining the type of fog that affects everything rendered in the scene.
	 * @defaultValue `null`
	 */
	fog: Fog | FogExp2 | null;
	/**
	 * Sets the blurriness of the background. Only influences environment maps assigned to {@link THREE.Scene.background | Scene.background}.
	 * @defaultValue `0`
	 * @remarks Expects a `Float` between `0` and `1`.
	 */
	backgroundBlurriness: number;
	/**
	 * Attenuates the color of the background. Only applies to background textures.
	 * @defaultValue `1`
	 * @remarks Expects a `Float`
	 */
	backgroundIntensity: number;
	/**
	 * Forces everything in the {@link Scene} to be rendered with the defined material.
	 * @defaultValue `null`
	 */
	overrideMaterial: Material | null;
	/**
	 * Defines the background of the scene.
	 * @remarks Valid inputs are:
	 *  - A {@link THREE.Color | Color} for defining a uniform colored background.
	 *  - A {@link THREE.Texture | Texture} for defining a (flat) textured background.
	 *  - Texture cubes ({@link THREE.CubeTexture | CubeTexture}) or equirectangular textures for defining a skybox.</li>
	 * @defaultValue `null`
	 */
	background: Color | Texture | CubeTexture | null;
	/**
	 * The rotation of the background in radians. Only influences environment maps assigned to {@link .background}.
	 * Default is `(0,0,0)`.
	 */
	backgroundRotation: Euler;
	/**
	 * Sets the environment map for all physical materials in the scene.
	 * However, it's not possible to overwrite an existing texture assigned to {@link THREE.MeshStandardMaterial.envMap | MeshStandardMaterial.envMap}.
	 * @defaultValue `null`
	 */
	environment: Texture | null;
	/**
	 * Attenuates the color of the environment. Only influences environment maps assigned to {@link Scene.environment}.
	 * @default 1
	 */
	environmentIntensity: number;
	/**
	 * The rotation of the environment map in radians. Only influences physical materials in the scene when
	 * {@link .environment} is used. Default is `(0,0,0)`.
	 */
	environmentRotation: Euler;
	/**
	 * Convert the {@link Scene} to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 * @param meta Object containing metadata such as textures or images for the scene.
	 */
	toJSON(meta?: JSONMeta): SceneJSON;
}
declare class Box2 {
	constructor(min?: Vector2, max?: Vector2);
	/**
	 * @default new THREE.Vector2( + Infinity, + Infinity )
	 */
	min: Vector2;
	/**
	 * @default new THREE.Vector2( - Infinity, - Infinity )
	 */
	max: Vector2;
	set(min: Vector2, max: Vector2): Box2;
	setFromPoints(points: Vector2[]): Box2;
	setFromCenterAndSize(center: Vector2, size: Vector2): Box2;
	clone(): this;
	copy(box: Box2): this;
	makeEmpty(): Box2;
	isEmpty(): boolean;
	getCenter(target: Vector2): Vector2;
	getSize(target: Vector2): Vector2;
	expandByPoint(point: Vector2): Box2;
	expandByVector(vector: Vector2): Box2;
	expandByScalar(scalar: number): Box2;
	containsPoint(point: Vector2): boolean;
	containsBox(box: Box2): boolean;
	getParameter(point: Vector2, target: Vector2): Vector2;
	intersectsBox(box: Box2): boolean;
	clampPoint(point: Vector2, target: Vector2): Vector2;
	distanceToPoint(point: Vector2): number;
	intersect(box: Box2): Box2;
	union(box: Box2): Box2;
	translate(offset: Vector2): Box2;
	equals(box: Box2): boolean;
	/**
	 * @deprecated Use {@link Box2#isEmpty .isEmpty()} instead.
	 */
	empty(): any;
	/**
	 * @deprecated Use {@link Box2#intersectsBox .intersectsBox()} instead.
	 */
	isIntersectionBox(b: any): any;
}
export interface WebGLCapabilitiesParameters {
	/**
	 * shader precision. Can be "highp", "mediump" or "lowp".
	 */
	precision?: string | undefined;
	/**
	 * default is false.
	 */
	logarithmicDepthBuffer?: boolean | undefined;
	/**
	 * default is false.
	 */
	reversedDepthBuffer?: boolean | undefined;
}
declare class WebGLCapabilities {
	constructor(gl: WebGLRenderingContext, extensions: any, parameters: WebGLCapabilitiesParameters);
	readonly isWebGL2: boolean;
	getMaxAnisotropy: () => number;
	getMaxPrecision: (precision: string) => string;
	textureFormatReadable: (textureFormat: PixelFormat) => boolean;
	textureTypeReadable: (textureType: TextureDataType) => boolean;
	precision: string;
	logarithmicDepthBuffer: boolean;
	reversedDepthBuffer: boolean;
	maxTextures: number;
	maxVertexTextures: number;
	maxTextureSize: number;
	maxCubemapSize: number;
	maxAttributes: number;
	maxVertexUniforms: number;
	maxVaryings: number;
	maxFragmentUniforms: number;
	maxSamples: number;
	samples: number;
}
declare class WebGLExtensions {
	constructor(gl: WebGLRenderingContext);
	has(name: string): boolean;
	init(): void;
	get(name: string): any;
}
declare class WebGLProperties {
	constructor();
	has: (object: unknown) => boolean;
	get: (object: unknown) => unknown;
	remove: (object: unknown) => void;
	update: (object: unknown, key: unknown, value: unknown) => unknown;
	dispose: () => void;
}
declare class WebGLColorBuffer {
	setMask(colorMask: boolean): void;
	setLocked(lock: boolean): void;
	setClear(r: number, g: number, b: number, a: number, premultipliedAlpha: boolean): void;
	reset(): void;
}
declare class WebGLDepthBuffer {
	constructor();
	setReversed(value: boolean): void;
	getReversed(): boolean;
	setTest(depthTest: boolean): void;
	setMask(depthMask: boolean): void;
	setFunc(depthFunc: DepthModes): void;
	setLocked(lock: boolean): void;
	setClear(depth: number): void;
	reset(): void;
}
declare class WebGLStencilBuffer {
	constructor();
	setTest(stencilTest: boolean): void;
	setMask(stencilMask: number): void;
	setFunc(stencilFunc: number, stencilRef: number, stencilMask: number): void;
	setOp(stencilFail: number, stencilZFail: number, stencilZPass: number): void;
	setLocked(lock: boolean): void;
	setClear(stencil: number): void;
	reset(): void;
}
declare class WebGLState {
	constructor(gl: WebGLRenderingContext, extensions: WebGLExtensions);
	buffers: {
		color: WebGLColorBuffer;
		depth: WebGLDepthBuffer;
		stencil: WebGLStencilBuffer;
	};
	enable(id: number): void;
	disable(id: number): void;
	bindFramebuffer(target: number, framebuffer: WebGLFramebuffer | null): void;
	drawBuffers(renderTarget: WebGLRenderTarget | null, framebuffer: WebGLFramebuffer | null): void;
	useProgram(program: any): boolean;
	setBlending(blending: Blending, blendEquation?: BlendingEquation, blendSrc?: BlendingSrcFactor, blendDst?: BlendingDstFactor, blendEquationAlpha?: BlendingEquation, blendSrcAlpha?: BlendingSrcFactor, blendDstAlpha?: BlendingDstFactor, premultiplyAlpha?: boolean): void;
	setMaterial(material: Material, frontFaceCW: boolean, hardwareClippingPlanes: number): void;
	setFlipSided(flipSided: boolean): void;
	setCullFace(cullFace: CullFace): void;
	setLineWidth(width: number): void;
	setPolygonOffset(polygonoffset: boolean, factor?: number, units?: number): void;
	setScissorTest(scissorTest: boolean): void;
	activeTexture(webglSlot: number): void;
	bindTexture(webglType: number, webglTexture: any): void;
	unbindTexture(): void;
	// Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/compressedTexImage2D
	compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, data: ArrayBufferView): void;
	// Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
	texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: ArrayBufferView | null): void;
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, source: any): void;
	texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pixels: any): void;
	scissor(scissor: Vector4): void;
	viewport(viewport: Vector4): void;
	reset(): void;
}
declare class WebGLUtils {
	constructor(gl: WebGLRenderingContext | WebGL2RenderingContext, extensions: WebGLExtensions);
	convert(p: PixelFormat | CompressedPixelFormat | TextureDataType, colorSpace?: string): number | null;
}
declare class WebGLTextures {
	constructor(gl: WebGLRenderingContext, extensions: WebGLExtensions, state: WebGLState, properties: WebGLProperties, capabilities: WebGLCapabilities, utils: WebGLUtils, info: WebGLInfo);
	allocateTextureUnit(): void;
	resetTextureUnits(): void;
	setTexture2D(texture: any, slot: number): void;
	setTexture2DArray(texture: any, slot: number): void;
	setTexture3D(texture: any, slot: number): void;
	setTextureCube(texture: any, slot: number): void;
	setupRenderTarget(renderTarget: any): void;
	updateRenderTargetMipmap(renderTarget: any): void;
	updateMultisampleRenderTarget(renderTarget: any): void;
	safeSetTexture2D(texture: any, slot: number): void;
	safeSetTextureCube(texture: any, slot: number): void;
}
declare class WebGLUniforms {
	constructor(gl: WebGLRenderingContext, program: WebGLProgram$1);
	setValue(gl: WebGLRenderingContext, name: string, value: any, textures: WebGLTextures): void;
	setOptional(gl: WebGLRenderingContext, object: any, name: string): void;
	static upload(gl: WebGLRenderingContext, seq: any, values: any[], textures: WebGLTextures): void;
	static seqWithValue(seq: any, values: any[]): any[];
}
declare class WebGLProgram$1 {
	constructor(renderer: WebGLRenderer, cacheKey: string, parameters: object);
	name: string;
	id: number;
	cacheKey: string; // unique identifier for this program, used for looking up compiled programs from cache.
	/**
	 * @default 1
	 */
	usedTimes: number;
	program: any;
	vertexShader: WebGLShader;
	fragmentShader: WebGLShader;
	/**
	 * @deprecated Use {@link WebGLProgram#getUniforms getUniforms()} instead.
	 */
	uniforms: any;
	/**
	 * @deprecated Use {@link WebGLProgram#getAttributes getAttributes()} instead.
	 */
	attributes: any;
	getUniforms(): WebGLUniforms;
	getAttributes(): any;
	destroy(): void;
}
declare class WebGLInfo {
	constructor(gl: WebGLRenderingContext);
	/**
	 * @default true
	 */
	autoReset: boolean;
	/**
	 * @default { geometries: 0, textures: 0 }
	 */
	memory: {
		geometries: number;
		textures: number;
	};
	/**
	 * @default null
	 */
	programs: WebGLProgram$1[] | null;
	/**
	 * @default { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
	 */
	render: {
		calls: number;
		frame: number;
		lines: number;
		points: number;
		triangles: number;
	};
	update(count: number, mode: number, instanceCount: number): void;
	reset(): void;
}
export interface RenderItem {
	id: number;
	object: Object3D;
	geometry: BufferGeometry | null;
	material: Material;
	program: WebGLProgram$1;
	groupOrder: number;
	renderOrder: number;
	z: number;
	group: Group | null;
}
declare class WebGLRenderList {
	constructor(properties: WebGLProperties);
	/**
	 * @default []
	 */
	opaque: RenderItem[];
	/**
	 * @default []
	 */
	transparent: RenderItem[];
	/**
	 * @default []
	 */
	transmissive: RenderItem[];
	init(): void;
	push(object: Object3D, geometry: BufferGeometry | null, material: Material, groupOrder: number, z: number, group: Group | null): void;
	unshift(object: Object3D, geometry: BufferGeometry | null, material: Material, groupOrder: number, z: number, group: Group | null): void;
	sort(opaqueSort: (a: any, b: any) => number, transparentSort: (a: any, b: any) => number): void;
	finish(): void;
}
declare class WebGLRenderLists {
	constructor(properties: WebGLProperties);
	dispose(): void;
	get(scene: Scene, renderCallDepth: number): WebGLRenderList;
}
declare class WebGLObjects {
	constructor(gl: WebGLRenderingContext, geometries: any, attributes: any, info: any);
	update(object: any): any;
	dispose(): void;
}
declare class WebGLShadowMap {
	constructor(_renderer: WebGLRenderer, _objects: WebGLObjects, _capabilities: WebGLCapabilities);
	/**
	 * @default false
	 */
	enabled: boolean;
	/**
	 * @default true
	 */
	autoUpdate: boolean;
	/**
	 * @default false
	 */
	needsUpdate: boolean;
	/**
	 * @default THREE.PCFShadowMap
	 */
	type: ShadowMapType;
	render(shadowsArray: Light[], scene: Scene, camera: Camera): void;
	/**
	 * @deprecated Use {@link Material#shadowSide} instead.
	 */
	cullFace: any;
}
export interface PerspectiveCameraJSONObject extends Object3DJSONObject {
	fov: number;
	zoom: number;
	near: number;
	far: number;
	focus: number;
	aspect: number;
	view?: {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};
	filmGauge: number;
	filmOffset: number;
}
export interface PerspectiveCameraJSON extends Object3DJSON {
	object: PerspectiveCameraJSONObject;
}
declare class PerspectiveCamera extends Camera {
	/**
	 * Creates a new {@link PerspectiveCamera}.
	 * @remarks Together these define the camera's {@link https://en.wikipedia.org/wiki/Viewing_frustum | viewing frustum}.
	 * @param fov Camera frustum vertical field of view. Default `50`.
	 * @param aspect Camera frustum aspect ratio. Default `1`.
	 * @param near Camera frustum near plane. Default `0.1`.
	 * @param far Camera frustum far plane. Default `2000`.
	 */
	constructor(fov?: number, aspect?: number, near?: number, far?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link Camera}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isPerspectiveCamera: true;
	/**
	 * @override
	 * @defaultValue `PerspectiveCamera`
	 */
	override readonly type: string | "PerspectiveCamera";
	/**
	 * Gets or sets the zoom factor of the camera.
	 * @defaultValue `1`
	 */
	zoom: number;
	/**
	 * Camera frustum vertical field of view, from bottom to top of view, in degrees.
	 * @remarks Expects a `Float`
	 * @defaultValue `50`
	 */
	fov: number;
	/**
	 * Camera frustum aspect ratio, usually the canvas width / canvas height.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`, _(square canvas)_.
	 */
	aspect: number;
	/**
	 * Camera frustum near plane.
	 * @remarks The valid range is greater than `0` and less than the current value of the {@link far | .far} plane.
	 * @remarks Note that, unlike for the {@link THREE.OrthographicCamera | OrthographicCamera}, `0` is **not** a valid value for a {@link PerspectiveCamera |PerspectiveCamera's}. near plane.
	 * @defaultValue `0.1`
	 * @remarks Expects a `Float`
	 */
	near: number;
	/**
	 * Camera frustum far plane.
	 * @remarks Must be greater than the current value of {@link near | .near} plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `2000`
	 */
	far: number;
	/**
	 * Object distance used for stereoscopy and depth-of-field effects.
	 * @remarks This parameter does not influence the projection matrix unless a {@link THREE.StereoCamera | StereoCamera} is being used.
	 * @remarks Expects a `Float`
	 * @defaultValue `10`
	 */
	focus: number;
	/**
	 * Frustum window specification or null.
	 * This is set using the {@link setViewOffset | .setViewOffset} method and cleared using {@link clearViewOffset | .clearViewOffset}.
	 * @defaultValue `null`
	 */
	view: null | {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};
	/**
	 * Film size used for the larger axis.
	 * This parameter does not influence the projection matrix unless {@link filmOffset | .filmOffset} is set to a nonzero value.
	 * @remarks Expects a `Float`
	 * @defaultValue `35`, _millimeters_.
	 */
	filmGauge: number;
	/**
	 * Horizontal off-center offset in the same unit as {@link filmGauge | .filmGauge}.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	filmOffset: number;
	/**
	 * Returns the focal length of the current {@link .fov | fov} in respect to {@link filmGauge | .filmGauge}.
	 */
	getFocalLength(): number;
	/**
	 * Sets the FOV by focal length in respect to the current {@link filmGauge | .filmGauge}.
	 * @remarks By default, the focal length is specified for a `35mm` (full frame) camera.
	 * @param focalLength Expects a `Float`
	 */
	setFocalLength(focalLength: number): void;
	/**
	 * Returns the current vertical field of view angle in degrees considering {@link zoom | .zoom}.
	 */
	getEffectiveFOV(): number;
	/**
	 * Returns the width of the image on the film
	 * @remarks
	 * If {@link aspect | .aspect}. is greater than or equal to one (landscape format), the result equals {@link filmGauge | .filmGauge}.
	 */
	getFilmWidth(): number;
	/**
	 * Returns the height of the image on the film
	 * @remarks
	 * If {@link aspect | .aspect}. is less than or equal to one (portrait format), the result equals {@link filmGauge | .filmGauge}.
	 */
	getFilmHeight(): number;
	/**
	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
	 */
	getViewBounds(distance: number, minTarget: Vector2, maxTarget: Vector2): void;
	/**
	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Copies the result into the target Vector2, where x is width and y is height.
	 */
	getViewSize(distance: number, target: Vector2): Vector2;
	/**
	 * Sets an offset in a larger frustum.
	 * @remarks
	 * This is useful for multi-window or multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is _1920x1080_ and
	 * the monitors are in grid like this
	 * ```
	 * ┌───┬───┬───┐
	 * │ A │ B │ C │
	 * ├───┼───┼───┤
	 * │ D │ E │ F │
	 * └───┴───┴───┘
	 * ```
	 * then for each monitor you would call it like this
	 * ```typescript
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   // Monitor - A
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   // Monitor - B
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   // Monitor - C
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   // Monitor - D
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   // Monitor - E
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   // Monitor - F
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 * ```
	 * Note there is no reason monitors have to be the same size or in a grid.
	 * @param fullWidth Full width of multiview setup Expects a `Float`.
	 * @param fullHeight Full height of multiview setup Expects a `Float`.
	 * @param x Horizontal offset of subcamera Expects a `Float`.
	 * @param y Vertical offset of subcamera Expects a `Float`.
	 * @param width Width of subcamera Expects a `Float`.
	 * @param height Height of subcamera Expects a `Float`.
	 */
	setViewOffset(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number): void;
	/**
	 * Removes any offset set by the {@link setViewOffset | .setViewOffset} method.
	 */
	clearViewOffset(): void;
	/**
	 * Updates the camera projection matrix
	 * @remarks Must be called after any change of parameters.
	 */
	updateProjectionMatrix(): void;
	/**
	 * @deprecated Use {@link PerspectiveCamera.setFocalLength | .setFocalLength()} and {@link PerspectiveCamera.filmGauge | .filmGauge} instead.
	 */
	setLens(focalLength: number, frameHeight?: number): void;
	toJSON(meta?: JSONMeta): PerspectiveCameraJSON;
}
declare class ArrayCamera extends PerspectiveCamera {
	/**
	 * Read-only flag to check if a given object is of type {@link ArrayCamera}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isArrayCamera: true;
	/**
	 * Whether this camera is used with multiview rendering or not.
	 */
	isMultiViewCamera: boolean;
	/**
	 * An array of cameras.
	 * @defaultValue `[]`
	 */
	cameras: PerspectiveCamera[];
	index: number;
	/**
	 * An array of cameras.
	 */
	constructor(cameras?: PerspectiveCamera[]);
}
export interface MeshJSONObject extends Object3DJSONObject {
	geometry: string;
}
export interface MeshJSON extends Object3DJSON {
	object: MeshJSONObject;
}
declare class Mesh<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[], TEventMap extends Object3DEventMap = Object3DEventMap> extends Object3D<TEventMap> {
	/**
	 * Create a new instance of {@link Mesh}
	 * @param geometry An instance of {@link THREE.BufferGeometry | BufferGeometry}. Default {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material A single or an array of {@link THREE.Material | Material}. Default {@link THREE.MeshBasicMaterial | `new THREE.MeshBasicMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link Mesh}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isMesh: true;
	/**
	 * @override
	 * @defaultValue `Mesh`
	 */
	override readonly type: string | "Mesh";
	/**
	 * An instance of {@link THREE.BufferGeometry | BufferGeometry} (or derived classes), defining the object's structure.
	 * @defaultValue {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 */
	geometry: TGeometry;
	/**
	 * An instance of material derived from the {@link THREE.Material | Material} base class or an array of materials, defining the object's appearance.
	 * @defaultValue {@link THREE.MeshBasicMaterial | `new THREE.MeshBasicMaterial()`}.
	 */
	material: TMaterial;
	/**
	 * An array of weights typically from `0-1` that specify how much of the morph is applied.
	 * @defaultValue `undefined`, _but reset to a blank array by {@link updateMorphTargets | .updateMorphTargets()}._
	 */
	morphTargetInfluences?: number[] | undefined;
	/**
	 * A dictionary of morphTargets based on the `morphTarget.name` property.
	 * @defaultValue `undefined`, _but rebuilt by {@link updateMorphTargets | .updateMorphTargets()}._
	 */
	morphTargetDictionary?: {
		[key: string]: number;
	} | undefined;
	/**
	 * The number of instances of this mesh.
	 * Can only be used with {@link WebGPURenderer}.
	 *
	 * @default 1
	 */
	count: number;
	/**
	 * Updates the morphTargets to have no influence on the object
	 * @remarks Resets the {@link morphTargetInfluences} and {@link morphTargetDictionary} properties.
	 */
	updateMorphTargets(): void;
	/**
	 * Get the local-space position of the vertex at the given index,
	 * taking into account the current animation state of both morph targets and skinning.
	 * @param index Expects a `Integer`
	 * @param target
	 */
	getVertexPosition(index: number, target: Vector3): Vector3;
	toJSON(meta?: JSONMeta): MeshJSON;
}
declare class ExternalTexture extends Texture<null> {
	sourceTexture: WebGLTexture | GPUTexture | null;
	readonly isExternalTexture: true;
	constructor(sourceTexture?: WebGLTexture | GPUTexture | null);
}
export type XRControllerEventType = XRSessionEventType | XRInputSourceEventType | "disconnected" | "connected";
declare class XRJointSpace$1 extends Group {
	readonly jointRadius: number | undefined;
}
export type XRHandJoints = Record<XRHandJoint, XRJointSpace$1>;
export interface XRHandInputState {
	pinching: boolean;
}
export interface WebXRSpaceEventMap extends Object3DEventMap {
	select: {
		data: XRInputSource;
	};
	selectstart: {
		data: XRInputSource;
	};
	selectend: {
		data: XRInputSource;
	};
	squeeze: {
		data: XRInputSource;
	};
	squeezestart: {
		data: XRInputSource;
	};
	squeezeend: {
		data: XRInputSource;
	};
	connected: {
		data: XRInputSource;
	};
	disconnected: {
		data: XRInputSource;
	};
	pinchend: {
		handedness: XRHandedness;
		target: WebXRController;
	}; // This Event break the THREE.EventDispatcher contract, replacing the target to the wrong instance.
	pinchstart: {
		handedness: XRHandedness;
		target: WebXRController;
	}; // This Event break the THREE.EventDispatcher contract, replacing the target to the wrong instance.
	move: {};
}
declare class XRHandSpace extends Group<WebXRSpaceEventMap> {
	readonly joints: Partial<XRHandJoints>;
	readonly inputState: XRHandInputState;
}
declare class XRTargetRaySpace extends Group<WebXRSpaceEventMap> {
	hasLinearVelocity: boolean;
	readonly linearVelocity: Vector3;
	hasAngularVelocity: boolean;
	readonly angularVelocity: Vector3;
}
declare class XRGripSpace extends Group<WebXRSpaceEventMap> {
	hasLinearVelocity: boolean;
	readonly linearVelocity: Vector3;
	hasAngularVelocity: boolean;
	readonly angularVelocity: Vector3;
}
declare class WebXRController {
	constructor();
	getHandSpace(): XRHandSpace;
	getTargetRaySpace(): XRTargetRaySpace;
	getGripSpace(): XRGripSpace;
	dispatchEvent(event: {
		type: XRControllerEventType;
		data?: XRInputSource;
	}): this;
	connect(inputSource: XRInputSource): this;
	disconnect(inputSource: XRInputSource): this;
	update(inputSource: XRInputSource, frame: XRFrame, referenceSpace: XRReferenceSpace): this;
}
export type WebXRCamera = PerspectiveCamera & {
	viewport: Vector4;
};
export type WebXRArrayCamera = Omit<ArrayCamera, "cameras"> & {
	cameras: [
		WebXRCamera,
		WebXRCamera
	];
};
export interface WebXRManagerEventMap {
	sessionstart: {};
	sessionend: {};
	planeadded: {
		data: XRPlane;
	};
	planeremoved: {
		data: XRPlane;
	};
	planechanged: {
		data: XRPlane;
	};
	planesdetected: {
		data: XRPlaneSet;
	};
}
declare class WebXRManager extends EventDispatcher<WebXRManagerEventMap> {
	/**
	 * @default true
	 */
	cameraAutoUpdate: boolean;
	/**
	 * @default false
	 */
	enabled: boolean;
	/**
	 * @default false
	 */
	isPresenting: boolean;
	constructor(renderer: WebGLRenderer, gl: WebGLRenderingContext);
	getController: (index: number) => XRTargetRaySpace;
	getControllerGrip: (index: number) => XRGripSpace;
	getHand: (index: number) => XRHandSpace;
	setFramebufferScaleFactor: (value: number) => void;
	setReferenceSpaceType: (value: XRReferenceSpaceType) => void;
	getReferenceSpace: () => XRReferenceSpace | null;
	setReferenceSpace: (value: XRReferenceSpace) => void;
	getBaseLayer: () => XRWebGLLayer | XRProjectionLayer;
	getBinding: () => XRWebGLBinding;
	getFrame: () => XRFrame;
	getSession: () => XRSession | null;
	setSession: (value: XRSession | null) => Promise<void>;
	getEnvironmentBlendMode: () => XREnvironmentBlendMode | undefined;
	getDepthTexture: () => ExternalTexture | null;
	updateCamera: (camera: PerspectiveCamera) => void;
	getCamera: () => WebXRArrayCamera;
	getFoveation: () => number | undefined;
	setFoveation: (value: number) => void;
	hasDepthSensing: () => boolean;
	getDepthSensingMesh: () => Mesh | null;
	getCameraTexture: (xrCamera: WebXRCamera) => ExternalTexture | undefined;
	setAnimationLoop: (callback: XRFrameRequestCallback | null) => void;
	dispose: () => void;
}
export interface WebGLRendererParameters extends WebGLCapabilitiesParameters {
	/**
	 * A Canvas where the renderer draws its output.
	 */
	canvas?: HTMLCanvasElement | OffscreenCanvas$1 | undefined;
	/**
	 * A WebGL Rendering Context.
	 * (https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)
	 * Default is null
	 */
	context?: WebGLRenderingContext | undefined;
	/**
	 * default is false.
	 */
	alpha?: boolean | undefined;
	/**
	 * default is true.
	 */
	premultipliedAlpha?: boolean | undefined;
	/**
	 * default is false.
	 */
	antialias?: boolean | undefined;
	/**
	 * default is false.
	 */
	stencil?: boolean | undefined;
	/**
	 * default is false.
	 */
	preserveDrawingBuffer?: boolean | undefined;
	/**
	 * Can be "high-performance", "low-power" or "default"
	 */
	powerPreference?: WebGLPowerPreference | undefined;
	/**
	 * default is true.
	 */
	depth?: boolean | undefined;
	/**
	 * default is false.
	 */
	failIfMajorPerformanceCaveat?: boolean | undefined;
	/**
	 * @default UnsignedByteType
	 */
	outputBufferType?: TextureDataType | undefined;
}
export interface WebGLDebug {
	/**
	 * Enables error checking and reporting when shader programs are being compiled.
	 */
	checkShaderErrors: boolean;
	/**
	 * A callback function that can be used for custom error reporting. The callback receives the WebGL context, an
	 * instance of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
	 * Assigning a custom function disables the default error reporting.
	 * @default `null`
	 */
	onShaderError: ((gl: WebGLRenderingContext, program: WebGLProgram$1, glVertexShader: WebGLShader, glFragmentShader: WebGLShader) => void) | null;
}
export interface Effect {
	setSize(width: number, height: number): void;
	render(renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget, readBuffer: WebGLRenderTarget, deltaTime: number, maskActive: boolean): void;
}
declare class WebGLRenderer {
	/**
	 * parameters is an optional object with properties defining the renderer's behavior.
	 * The constructor also accepts no parameters at all.
	 * In all cases, it will assume sane defaults when parameters are missing.
	 */
	constructor(parameters?: WebGLRendererParameters);
	/**
	 * A Canvas where the renderer draws its output.
	 * This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.
	 * @default document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' )
	 */
	domElement: HTMLCanvasElement;
	/**
	 * Defines whether the renderer should automatically clear its output before rendering.
	 * @default true
	 */
	autoClear: boolean;
	/**
	 * If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.
	 * @default true
	 */
	autoClearColor: boolean;
	/**
	 * If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.
	 * @default true
	 */
	autoClearDepth: boolean;
	/**
	 * If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.
	 * @default true
	 */
	autoClearStencil: boolean;
	/**
	 * Debug configurations.
	 * @default { checkShaderErrors: true }
	 */
	debug: WebGLDebug;
	/**
	 * Defines whether the renderer should sort objects. Default is true.
	 * @default true
	 */
	sortObjects: boolean;
	/**
	 * @default []
	 */
	clippingPlanes: Plane[];
	/**
	 * @default false
	 */
	localClippingEnabled: boolean;
	extensions: WebGLExtensions;
	/**
	 * Color space used for output to HTMLCanvasElement. Supported values are
	 * {@link SRGBColorSpace} and {@link LinearSRGBColorSpace}.
	 * @default THREE.SRGBColorSpace.
	 */
	get outputColorSpace(): string;
	set outputColorSpace(colorSpace: string);
	get coordinateSystem(): typeof WebGLCoordinateSystem;
	/**
	 * @default THREE.NoToneMapping
	 */
	toneMapping: ToneMapping;
	/**
	 * @default 1
	 */
	toneMappingExposure: number;
	/**
	 * The normalized resolution scale for the transmission render target, measured in percentage of viewport
	 * dimensions. Lowering this value can result in significant improvements to {@link MeshPhysicalMaterial}
	 * transmission performance. Default is `1`.
	 */
	transmissionResolutionScale: number;
	info: WebGLInfo;
	shadowMap: WebGLShadowMap;
	capabilities: WebGLCapabilities;
	properties: WebGLProperties;
	renderLists: WebGLRenderLists;
	state: WebGLState;
	xr: WebXRManager;
	/**
	 * Return the WebGL context.
	 */
	getContext(): WebGLRenderingContext | WebGL2RenderingContext;
	getContextAttributes(): any;
	forceContextLoss(): void;
	forceContextRestore(): void;
	/**
	 * @deprecated Use {@link WebGLCapabilities#getMaxAnisotropy .capabilities.getMaxAnisotropy()} instead.
	 */
	getMaxAnisotropy(): number;
	/**
	 * @deprecated Use {@link WebGLCapabilities#precision .capabilities.precision} instead.
	 */
	getPrecision(): string;
	getPixelRatio(): number;
	setPixelRatio(value: number): void;
	getSize(target: Vector2): Vector2;
	/**
	 * Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).
	 */
	setSize(width: number, height: number, updateStyle?: boolean): void;
	getDrawingBufferSize(target: Vector2): Vector2;
	setDrawingBufferSize(width: number, height: number, pixelRatio: number): void;
	setEffects(effects: Effect[] | null): void;
	getCurrentViewport(target: Vector4): Vector4;
	/**
	 * Copies the viewport into target.
	 */
	getViewport(target: Vector4): Vector4;
	/**
	 * Sets the viewport to render from (x, y) to (x + width, y + height).
	 * (x, y) is the lower-left corner of the region.
	 */
	setViewport(x: Vector4 | number, y?: number, width?: number, height?: number): void;
	/**
	 * Copies the scissor area into target.
	 */
	getScissor(target: Vector4): Vector4;
	/**
	 * Sets the scissor area from (x, y) to (x + width, y + height).
	 */
	setScissor(x: Vector4 | number, y?: number, width?: number, height?: number): void;
	/**
	 * Returns true if scissor test is enabled; returns false otherwise.
	 */
	getScissorTest(): boolean;
	/**
	 * Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.
	 */
	setScissorTest(enable: boolean): void;
	/**
	 * Sets the custom opaque sort function for the WebGLRenderLists. Pass null to use the default painterSortStable function.
	 */
	setOpaqueSort(method: ((a: any, b: any) => number) | null): void;
	/**
	 * Sets the custom transparent sort function for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.
	 */
	setTransparentSort(method: ((a: any, b: any) => number) | null): void;
	/**
	 * Returns a THREE.Color instance with the current clear color.
	 */
	getClearColor(target: Color): Color;
	/**
	 * Sets the clear color, using color for the color and alpha for the opacity.
	 */
	setClearColor(color: ColorRepresentation, alpha?: number): void;
	/**
	 * Returns a float with the current clear alpha. Ranges from 0 to 1.
	 */
	getClearAlpha(): number;
	setClearAlpha(alpha: number): void;
	/**
	 * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
	 * Arguments default to true
	 */
	clear(color?: boolean, depth?: boolean, stencil?: boolean): void;
	clearColor(): void;
	clearDepth(): void;
	clearStencil(): void;
	clearTarget(renderTarget: WebGLRenderTarget, color: boolean, depth: boolean, stencil: boolean): void;
	/**
	 * @deprecated Use {@link WebGLState#reset .state.reset()} instead.
	 */
	resetGLState(): void;
	dispose(): void;
	renderBufferDirect(camera: Camera, scene: Scene, geometry: BufferGeometry, material: Material, object: Object3D, geometryGroup: any): void;
	/**
	 * A build in function that can be used instead of requestAnimationFrame. For WebXR projects this function must be used.
	 * @param callback The function will be called every available frame. If `null` is passed it will stop any already ongoing animation.
	 */
	setAnimationLoop(callback: XRFrameRequestCallback | null): void;
	/**
	 * @deprecated Use {@link WebGLRenderer#setAnimationLoop .setAnimationLoop()} instead.
	 */
	animate(callback: () => void): void;
	/**
	 * Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first
	 * rendering. If you want to add a 3D object to an existing scene, use the third optional parameter for applying the
	 * target scene.
	 * Note that the (target) scene's lighting should be configured before calling this method.
	 */
	compile: (scene: Object3D, camera: Camera, targetScene?: Scene | null) => Set<Material>;
	/**
	 * Asynchronous version of {@link compile}(). The method returns a Promise that resolves when the given scene can be
	 * rendered without unnecessary stalling due to shader compilation.
	 * This method makes use of the KHR_parallel_shader_compile WebGL extension.
	 */
	compileAsync: (scene: Object3D, camera: Camera, targetScene?: Scene | null) => Promise<Object3D>;
	/**
	 * Render a scene or an object using a camera.
	 * The render is done to a previously specified {@link WebGLRenderTarget#renderTarget .renderTarget} set by calling
	 * {@link WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.
	 *
	 * By default render buffers are cleared before rendering but you can prevent this by setting the property
	 * {@link WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared
	 * you can set either the {@link WebGLRenderer#autoClearColor autoClearColor},
	 * {@link WebGLRenderer#autoClearStencil autoClearStencil} or {@link WebGLRenderer#autoClearDepth autoClearDepth}
	 * properties to false. To forcibly clear one ore more buffers call {@link WebGLRenderer#clear .clear}.
	 */
	render(scene: Object3D, camera: Camera): void;
	/**
	 * Returns the current active cube face.
	 */
	getActiveCubeFace(): number;
	/**
	 * Returns the current active mipmap level.
	 */
	getActiveMipmapLevel(): number;
	/**
	 * Returns the current render target. If no render target is set, null is returned.
	 */
	getRenderTarget(): WebGLRenderTarget | null;
	/**
	 * @deprecated Use {@link WebGLRenderer#getRenderTarget .getRenderTarget()} instead.
	 */
	getCurrentRenderTarget(): WebGLRenderTarget | null;
	/**
	 * Sets the active render target.
	 *
	 * @param renderTarget The {@link WebGLRenderTarget renderTarget} that needs to be activated. When `null` is given, the canvas is set as the active render target instead.
	 * @param activeCubeFace Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of {@link WebGLCubeRenderTarget}.
	 * @param activeMipmapLevel Specifies the active mipmap level.
	 */
	setRenderTarget(renderTarget: WebGLRenderTarget | WebGLRenderTarget<Texture[]> | null, activeCubeFace?: number, activeMipmapLevel?: number): void;
	readRenderTargetPixels(renderTarget: WebGLRenderTarget | WebGLRenderTarget<Texture[]>, x: number, y: number, width: number, height: number, buffer: TypedArray, activeCubeFaceIndex?: number, textureIndex?: number): void;
	readRenderTargetPixelsAsync(renderTarget: WebGLRenderTarget | WebGLRenderTarget<Texture[]>, x: number, y: number, width: number, height: number, buffer: TypedArray, activeCubeFaceIndex?: number, textureIndex?: number): Promise<TypedArray>;
	/**
	 * Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.
	 * This region is defined by the size of the destination texture's mip level, offset by the input position.
	 *
	 * @param texture Specifies the destination texture.
	 * @param position Specifies the pixel offset from which to copy out of the framebuffer.
	 * @param level Specifies the destination mipmap level of the texture.
	 */
	copyFramebufferToTexture(texture: Texture, position?: Vector2 | null, level?: number): void;
	/**
	 * Copies the pixels of a texture in the bounds [srcRegion]{@link Box3} in the destination texture starting from the
	 * given position. 2D Texture, 3D Textures, or a mix of the two can be used as source and destination texture
	 * arguments for copying between layers of 3d textures
	 *
	 * The `depthTexture` and `texture` property of render targets are supported as well.
	 *
	 * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are
	 * initialized e.g. via {@link .initRenderTarget}().
	 *
	 * @param srcTexture Specifies the source texture.
	 * @param dstTexture Specifies the destination texture.
	 * @param srcRegion Specifies the bounds
	 * @param dstPosition Specifies the pixel offset into the dstTexture where the copy will occur.
	 * @param srcLevel Specifies the source mipmap level of the texture.
	 * @param dstLevel Specifies the destination mipmap level of the texture.
	 */
	copyTextureToTexture(srcTexture: Texture, dstTexture: Texture, srcRegion?: Box2 | Box3 | null, dstPosition?: Vector2 | Vector3 | null, srcLevel?: number, dstLevel?: number): void;
	/**
	 * Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data can be copied
	 * into it using {@link WebGLRenderer.copyTextureToTexture} before it has been rendered to.
	 * @param target
	 */
	initRenderTarget(target: WebGLRenderTarget): void;
	/**
	 * Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).
	 *
	 * @param texture The texture to Initialize.
	 */
	initTexture(texture: Texture): void;
	/**
	 * Can be used to reset the internal WebGL state.
	 */
	resetState(): void;
	/**
	 * @deprecated Use {@link WebGLRenderer#xr .xr} instead.
	 */
	vr: boolean;
	/**
	 * @deprecated Use {@link WebGLShadowMap#enabled .shadowMap.enabled} instead.
	 */
	shadowMapEnabled: boolean;
	/**
	 * @deprecated Use {@link WebGLShadowMap#type .shadowMap.type} instead.
	 */
	shadowMapType: ShadowMapType;
	/**
	 * @deprecated Use {@link WebGLShadowMap#cullFace .shadowMap.cullFace} instead.
	 */
	shadowMapCullFace: CullFace;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_float' )} instead.
	 */
	supportsFloatTextures(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_half_float' )} instead.
	 */
	supportsHalfFloatTextures(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_standard_derivatives' )} instead.
	 */
	supportsStandardDerivatives(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_s3tc' )} instead.
	 */
	supportsCompressedTextureS3TC(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_pvrtc' )} instead.
	 */
	supportsCompressedTexturePVRTC(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'EXT_blend_minmax' )} instead.
	 */
	supportsBlendMinMax(): any;
	/**
	 * @deprecated Use {@link WebGLCapabilities#vertexTextures .capabilities.vertexTextures} instead.
	 */
	supportsVertexTextures(): any;
	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'ANGLE_instanced_arrays' )} instead.
	 */
	supportsInstancedArrays(): any;
	/**
	 * @deprecated Use {@link WebGLRenderer#setScissorTest .setScissorTest()} instead.
	 */
	enableScissorTest(boolean: any): any;
}
declare class WebGLAttributes {
	constructor(gl: WebGLRenderingContext | WebGL2RenderingContext);
	get(attribute: BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute): {
		buffer: WebGLBuffer;
		type: number;
		bytesPerElement: number;
		version: number;
		size: number;
	} | undefined;
	remove(attribute: BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute): void;
	update(attribute: BufferAttribute | InterleavedBufferAttribute | GLBufferAttribute, bufferType: number): void;
}
declare class WebGLBindingStates {
	constructor(gl: WebGLRenderingContext, attributes: WebGLAttributes);
	setup(object: Object3D, material: Material, program: WebGLProgram$1, geometry: BufferGeometry, index: BufferAttribute): void;
	reset(): void;
	resetDefaultState(): void;
	dispose(): void;
	releaseStatesOfGeometry(): void;
	releaseStatesOfProgram(): void;
	initAttributes(): void;
	enableAttribute(attribute: number): void;
	disableUnusedAttributes(): void;
}
declare class WebGLClipping {
	constructor(properties: WebGLProperties);
	uniform: {
		value: any;
		needsUpdate: boolean;
	};
	/**
	 * @default 0
	 */
	numPlanes: number;
	/**
	 * @default 0
	 */
	numIntersection: number;
	init(planes: any[], enableLocalClipping: boolean): boolean;
	beginShadows(): void;
	endShadows(): void;
	setGlobalState(planes: Plane[], camera: Camera): void;
	setState(material: Material, camera: Camera, useCache: boolean): void;
}
declare class WebGLCubeMaps {
	constructor(renderer: WebGLRenderer);
	get(texture: any): any;
	dispose(): void;
}
export interface WebGLLightsState {
	version: number;
	hash: {
		directionalLength: number;
		pointLength: number;
		spotLength: number;
		rectAreaLength: number;
		hemiLength: number;
		numDirectionalShadows: number;
		numPointShadows: number;
		numSpotShadows: number;
		numSpotMaps: number;
		numLightProbes: number;
	};
	ambient: number[];
	probe: any[];
	directional: any[];
	directionalShadow: any[];
	directionalShadowMap: any[];
	directionalShadowMatrix: any[];
	spot: any[];
	spotShadow: any[];
	spotShadowMap: any[];
	spotShadowMatrix: any[];
	rectArea: any[];
	point: any[];
	pointShadow: any[];
	pointShadowMap: any[];
	pointShadowMatrix: any[];
	hemi: any[];
	numSpotLightShadowsWithMaps: number;
	numLightProbes: number;
}
declare class WebGLLights {
	constructor(extensions: WebGLExtensions);
	state: WebGLLightsState;
	get(light: any): any;
	setup(lights: any): void;
	setupView(lights: any, camera: any): void;
}
export interface WebGLProgramParameters {
	shaderID: string;
	shaderType: string;
	shaderName: string;
	vertexShader: string;
	fragmentShader: string;
	defines: {
		[define: string]: string | number | boolean;
	} | undefined;
	customVertexShaderID: string | undefined;
	customFragmentShaderID: string | undefined;
	isRawShaderMaterial: boolean;
	glslVersion: GLSLVersion | null | undefined;
	precision: "lowp" | "mediump" | "highp";
	batching: boolean;
	batchingColor: boolean;
	instancing: boolean;
	instancingColor: boolean;
	instancingMorph: boolean;
	outputColorSpace: string;
	alphaToCoverage: boolean;
	map: boolean;
	matcap: boolean;
	envMap: boolean;
	envMapMode: Mapping | false;
	envMapCubeUVHeight: number | null;
	aoMap: boolean;
	lightMap: boolean;
	bumpMap: boolean;
	normalMap: boolean;
	displacementMap: boolean;
	emissiveMap: boolean;
	normalMapObjectSpace: boolean;
	normalMapTangentSpace: boolean;
	metalnessMap: boolean;
	roughnessMap: boolean;
	anisotropy: boolean;
	anisotropyMap: boolean;
	clearcoat: boolean;
	clearcoatMap: boolean;
	clearcoatNormalMap: boolean;
	clearcoatRoughnessMap: boolean;
	dispersion: boolean;
	iridescence: boolean;
	iridescenceMap: boolean;
	iridescenceThicknessMap: boolean;
	sheen: boolean;
	sheenColorMap: boolean;
	sheenRoughnessMap: boolean;
	specularMap: boolean;
	specularColorMap: boolean;
	specularIntensityMap: boolean;
	transmission: boolean;
	transmissionMap: boolean;
	thicknessMap: boolean;
	gradientMap: boolean;
	opaque: boolean;
	alphaMap: boolean;
	alphaTest: boolean;
	alphaHash: boolean;
	combine: Combine | undefined;
	//
	mapUv: string | false;
	aoMapUv: string | false;
	lightMapUv: string | false;
	bumpMapUv: string | false;
	normalMapUv: string | false;
	displacementMapUv: string | false;
	emissiveMapUv: string | false;
	metalnessMapUv: string | false;
	roughnessMapUv: string | false;
	anisotropyMapUv: string | false;
	clearcoatMapUv: string | false;
	clearcoatNormalMapUv: string | false;
	clearcoatRoughnessMapUv: string | false;
	iridescenceMapUv: string | false;
	iridescenceThicknessMapUv: string | false;
	sheenColorMapUv: string | false;
	sheenRoughnessMapUv: string | false;
	specularMapUv: string | false;
	specularColorMapUv: string | false;
	specularIntensityMapUv: string | false;
	transmissionMapUv: string | false;
	thicknessMapUv: string | false;
	alphaMapUv: string | false;
	//
	vertexTangents: boolean;
	vertexColors: boolean;
	vertexAlphas: boolean;
	vertexUv1s: boolean;
	vertexUv2s: boolean;
	vertexUv3s: boolean;
	pointsUvs: boolean;
	fog: boolean;
	useFog: boolean;
	fogExp2: boolean;
	flatShading: boolean;
	sizeAttenuation: boolean;
	logarithmicDepthBuffer: boolean;
	reverseDepthBuffer: boolean;
	skinning: boolean;
	morphTargets: boolean;
	morphNormals: boolean;
	morphColors: boolean;
	morphTargetsCount: number;
	morphTextureStride: number;
	numDirLights: number;
	numPointLights: number;
	numSpotLights: number;
	numSpotLightMaps: number;
	numRectAreaLights: number;
	numHemiLights: number;
	numDirLightShadows: number;
	numPointLightShadows: number;
	numSpotLightShadows: number;
	numSpotLightShadowsWithMaps: number;
	numLightProbes: number;
	numClippingPlanes: number;
	numClipIntersection: number;
	dithering: boolean;
	shadowMapEnabled: boolean;
	shadowMapType: ShadowMapType;
	toneMapping: ToneMapping;
	decodeVideoTexture: boolean;
	decodeVideoTextureEmissive: boolean;
	premultipliedAlpha: boolean;
	doubleSided: boolean;
	flipSided: boolean;
	useDepthPacking: boolean;
	depthPacking: DepthPackingStrategies | 0;
	index0AttributeName: string | undefined;
	extensionClipCullDistance: boolean;
	extensionMultiDraw: boolean;
	rendererExtensionParallelShaderCompile: boolean;
	customProgramCacheKey: string;
}
export interface WebGLProgramParametersWithUniforms extends WebGLProgramParameters {
	uniforms: {
		[uniform: string]: IUniform;
	};
}
declare class WebGLPrograms {
	constructor(renderer: WebGLRenderer, cubemaps: WebGLCubeMaps, extensions: WebGLExtensions, capabilities: WebGLCapabilities, bindingStates: WebGLBindingStates, clipping: WebGLClipping);
	programs: WebGLProgram$1[];
	getParameters(material: Material, lights: WebGLLightsState, shadows: Light[], scene: Scene, object: Object3D): WebGLProgramParameters;
	getProgramCacheKey(parameters: WebGLProgramParameters): string;
	getUniforms(material: Material): {
		[uniform: string]: IUniform;
	};
	acquireProgram(parameters: WebGLProgramParametersWithUniforms, cacheKey: string): WebGLProgram$1;
	releaseProgram(program: WebGLProgram$1): void;
}
export interface MaterialProperties {
	/**
	 * The name of the material.
	 */
	name: string;
	/**
	 * Defines the blending type of the material.
	 *
	 * It must be set to `CustomBlending` if custom blending properties like
	 * {@link Material#blendSrc}, {@link Material#blendDst} or {@link Material#blendEquation}
	 * should have any effect.
	 *
	 * @default NormalBlending
	 */
	blending: Blending;
	/**
	 * Defines which side of faces will be rendered - front, back or both.
	 *
	 * @default FrontSide
	 */
	side: Side;
	/**
	 * If set to `true`, vertex colors should be used.
	 *
	 * The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
	 * four (RGBA) component color buffer attribute is used.
	 *
	 * @default false
	 */
	vertexColors: boolean;
	/**
	 * Defines how transparent the material is.
	 * A value of `0.0` indicates fully transparent, `1.0` is fully opaque.
	 *
	 * If the {@link Material#transparent} is not set to `true`,
	 * the material will remain fully opaque and this value will only affect its color.
	 *
	 * @default 1
	 */
	opacity: number;
	/**
	 * Defines whether this material is transparent. This has an effect on
	 * rendering as transparent objects need special treatment and are rendered
	 * after non-transparent objects.
	 *
	 * When set to true, the extent to which the material is transparent is
	 * controlled by {@link Material#opacity}.
	 *
	 * @default false
	 */
	transparent: boolean;
	/**
	 * Enables alpha hashed transparency, an alternative to {@link Material#transparent} or
	 * {@link Material#alphaTest}. The material will not be rendered if opacity is lower than
	 * a random threshold. Randomization introduces some grain or noise, but approximates alpha
	 * blending without the associated problems of sorting. Using TAA can reduce the resulting noise.
	 *
	 * @default false
	 */
	alphaHash: boolean;
	/**
	 * Defines the blending source factor.
	 *
	 * @default SrcAlphaFactor
	 */
	blendSrc: BlendingSrcFactor;
	/**
	 * Defines the blending destination factor.
	 *
	 * @default OneMinusSrcAlphaFactor
	 */
	blendDst: BlendingDstFactor;
	/**
	 * Defines the blending equation.
	 *
	 * @default AddEquation
	 */
	blendEquation: BlendingEquation;
	/**
	 * Defines the blending source alpha factor.
	 *
	 * @default null
	 */
	blendSrcAlpha: BlendingSrcFactor | null;
	/**
	 * Defines the blending destination alpha factor.
	 *
	 * @default null
	 */
	blendDstAlpha: BlendingDstFactor | null;
	/**
	 * Defines the blending equation of the alpha channel.
	 *
	 * @default null
	 */
	blendEquationAlpha: BlendingEquation | null;
	/**
	 * Represents the RGB values of the constant blend color.
	 *
	 * This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.
	 *
	 * @default (0,0,0)
	 */
	blendColor: Color;
	/**
	 * Represents the alpha value of the constant blend color.
	 *
	 * This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.
	 *
	 * @default 0
	 */
	blendAlpha: number;
	/**
	 * Defines the depth function.
	 *
	 * @default LessEqualDepth
	 */
	depthFunc: DepthModes;
	/**
	 * Whether to have depth test enabled when rendering this material.
	 * When the depth test is disabled, the depth write will also be implicitly disabled.
	 *
	 * @default true
	 */
	depthTest: boolean;
	/**
	 * Whether rendering this material has any effect on the depth buffer.
	 *
	 * When drawing 2D overlays it can be useful to disable the depth writing in
	 * order to layer several things together without creating z-index artifacts.
	 *
	 * @default true
	 */
	depthWrite: boolean;
	/**
	 * The bit mask to use when writing to the stencil buffer.
	 *
	 * @default 0xff
	 */
	stencilWriteMask: number;
	/**
	 * The stencil comparison function to use.
	 *
	 * @default AlwaysStencilFunc
	 */
	stencilFunc: StencilFunc;
	/**
	 * The value to use when performing stencil comparisons or stencil operations.
	 *
	 * @default 0
	 */
	stencilRef: number;
	/**
	 * The bit mask to use when comparing against the stencil buffer.
	 *
	 * @default 0xff
	 */
	stencilFuncMask: number;
	/**
	 * Which stencil operation to perform when the comparison function returns `false`.
	 *
	 * @default KeepStencilOp
	 */
	stencilFail: StencilOp;
	/**
	 * Which stencil operation to perform when the comparison function returns
	 * `true` but the depth test fails.
	 *
	 * @default KeepStencilOp
	 */
	stencilZFail: StencilOp;
	/**
	 * Which stencil operation to perform when the comparison function returns
	 * `true` and the depth test passes.
	 *
	 * @default KeepStencilOp
	 */
	stencilZPass: StencilOp;
	/**
	 * Whether stencil operations are performed against the stencil buffer. In
	 * order to perform writes or comparisons against the stencil buffer this
	 * value must be `true`.
	 *
	 * @default false
	 */
	stencilWrite: boolean;
	/**
	 * User-defined clipping planes specified as THREE.Plane objects in world
	 * space. These planes apply to the objects this material is attached to.
	 * Points in space whose signed distance to the plane is negative are clipped
	 * (not rendered). This requires {@link WebGLRenderer#localClippingEnabled} to
	 * be `true`.
	 *
	 * @default null
	 */
	clippingPlanes: Array<Plane> | null;
	/**
	 * Changes the behavior of clipping planes so that only their intersection is
	 * clipped, rather than their union.
	 *
	 * @default false
	 */
	clipIntersection: boolean;
	/**
	 * Defines whether to clip shadows according to the clipping planes specified
	 * on this material.
	 *
	 * @default false
	 */
	clipShadows: boolean;
	/**
	 * Defines which side of faces cast shadows. If `null`, the side casting shadows
	 * is determined as follows:
	 *
	 * - When {@link Material#side} is set to `FrontSide`, the back side cast shadows.
	 * - When {@link Material#side} is set to `BackSide`, the front side cast shadows.
	 * - When {@link Material#side} is set to `DoubleSide`, both sides cast shadows.
	 *
	 * @default null
	 */
	shadowSide: Side | null;
	/**
	 * Whether to render the material's color.
	 *
	 * This can be used in conjunction with {@link Object3D#renderOder} to create invisible
	 * objects that occlude other objects.
	 *
	 * @default true
	 */
	colorWrite: boolean;
	/**
	 * Override the renderer's default precision for this material.
	 *
	 * @default null
	 */
	precision: ("highp" | "mediump" | "lowp") | null;
	/**
	 * Whether to use polygon offset or not. When enabled, each fragment's depth value will
	 * be offset after it is interpolated from the depth values of the appropriate vertices.
	 * The offset is added before the depth test is performed and before the value is written
	 * into the depth buffer.
	 *
	 * Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
	 * rendering solids with highlighted edges.
	 *
	 * @default false
	 */
	polygonOffset: boolean;
	/**
	 * Specifies a scale factor that is used to create a variable depth offset for each polygon.
	 *
	 * @default 0
	 */
	polygonOffsetFactor: number;
	/**
	 * Is multiplied by an implementation-specific value to create a constant depth offset.
	 *
	 * @default 0
	 */
	polygonOffsetUnits: number;
	/**
	 * Whether to apply dithering to the color to remove the appearance of banding.
	 *
	 * @default false
	 */
	dithering: boolean;
	/**
	 * Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
	 * (meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
	 * will smooth aliasing on clip plane edges and alphaTest-clipped edges.
	 *
	 * @default false
	 */
	alphaToCoverage: boolean;
	/**
	 * Whether to premultiply the alpha (transparency) value.
	 *
	 * @default false
	 */
	premultipliedAlpha: boolean;
	/**
	 * Whether double-sided, transparent objects should be rendered with a single pass or not.
	 *
	 * The engine renders double-sided, transparent objects with two draw calls (back faces first,
	 * then front faces) to mitigate transparency artifacts. There are scenarios however where this
	 * approach produces no quality gains but still doubles draw calls e.g. when rendering flat
	 * vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
	 * disable the two pass rendering to avoid performance issues.
	 *
	 * @default false
	 */
	forceSinglePass: boolean;
	/**
	 * Whether it's possible to override the material with {@link Scene#overrideMaterial} or not.
	 *
	 * @default true
	 */
	allowOverride: boolean;
	/**
	 * Defines whether 3D objects using this material are visible.
	 *
	 * @default true
	 */
	visible: boolean;
	/**
	 * Defines whether this material is tone mapped according to the renderer's tone mapping setting.
	 *
	 * It is ignored when rendering to a render target or using post processing or when using
	 * `WebGPURenderer`. In all these cases, all materials are honored by tone mapping.
	 *
	 * @default true
	 */
	toneMapped: boolean;
	/**
	 * An object that can be used to store custom data about the Material. It
	 * should not hold references to functions as these will not be cloned.
	 */
	userData: Record<string, any>;
	set alphaTest(value: number);
	/**
	 * Sets the alpha value to be used when running an alpha test. The material
	 * will not be rendered if the opacity is lower than this value.
	 *
	 * @default 0
	 */
	get alphaTest(): number;
}
export type MapColorPropertiesToColorRepresentations<T> = {
	[P in keyof T]: T[P] extends Color ? ColorRepresentation : T[P];
};
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface MaterialParameters extends Partial<MapColorPropertiesToColorRepresentations<MaterialProperties>> {
}
export interface MaterialJSON {
	metadata: {
		version: number;
		type: string;
		generator: string;
	};
	uuid: string;
	type: string;
	name?: string;
	color?: number;
	roughness?: number;
	metalness?: number;
	sheen?: number;
	sheenColor?: number;
	sheenRoughness?: number;
	emissive?: number;
	emissiveIntensity?: number;
	specular?: number;
	specularIntensity?: number;
	specularColor?: number;
	shininess?: number;
	clearcoat?: number;
	clearcoatRoughness?: number;
	clearcoatMap?: string;
	clearcoatRoughnessMap?: string;
	clearcoatNormalMap?: string;
	clearcoatNormalScale?: Vector2Tuple;
	dispersion?: number;
	iridescence?: number;
	iridescenceIOR?: number;
	iridescenceThicknessRange?: number;
	iridescenceMap?: string;
	iridescenceThicknessMap?: string;
	anisotropy?: number;
	anisotropyRotation?: number;
	anisotropyMap?: string;
	map?: string;
	matcap?: string;
	alphaMap?: string;
	lightMap?: string;
	lightMapIntensity?: number;
	aoMap?: string;
	aoMapIntensity?: number;
	bumpMap?: string;
	bumpScale?: number;
	normalMap?: string;
	normalMapType?: NormalMapTypes;
	normalScale?: Vector2Tuple;
	displacementMap?: string;
	displacementScale?: number;
	displacementBias?: number;
	roughnessMap?: string;
	metalnessMap?: string;
	emissiveMap?: string;
	specularMap?: string;
	specularIntensityMap?: string;
	specularColorMap?: string;
	envMap?: string;
	combine?: Combine;
	envMapRotation?: EulerTuple;
	envMapIntensity?: number;
	reflectivity?: number;
	refractionRatio?: number;
	gradientMap?: string;
	transmission?: number;
	transmissionMap?: string;
	thickness?: number;
	thicknessMap?: string;
	attenuationDistance?: number;
	attenuationColor?: number;
	size?: number;
	shadowSide?: number;
	sizeAttenuation?: boolean;
	blending?: Blending;
	side?: Side;
	vertexColors?: boolean;
	opacity?: number;
	transparent?: boolean;
	blendSrc?: BlendingSrcFactor;
	blendDst?: BlendingDstFactor;
	blendEquation?: BlendingEquation;
	blendSrcAlpha?: number | null;
	blendDstAlpha?: number | null;
	blendEquationAlpha?: number | null;
	blendColor?: number;
	blendAlpha?: number;
	depthFunc?: DepthModes;
	depthTest?: boolean;
	depthWrite?: boolean;
	colorWrite?: boolean;
	stencilWriteMask?: number;
	stencilFunc?: StencilFunc;
	stencilRef?: number;
	stencilFuncMask?: number;
	stencilFail?: StencilOp;
	stencilZFail?: StencilOp;
	stencilZPass?: StencilOp;
	stencilWrite?: boolean;
	rotation?: number;
	polygonOffset?: boolean;
	polygonOffsetFactor?: number;
	polygonOffsetUnits?: number;
	linewidth?: number;
	dashSize?: number;
	gapSize?: number;
	scale?: number;
	dithering?: boolean;
	alphaTest?: number;
	alphaHash?: boolean;
	alphaToCoverage?: boolean;
	premultipliedAlpha?: boolean;
	forceSinglePass?: boolean;
	wireframe?: boolean;
	wireframeLinewidth?: number;
	wireframeLinecap?: string;
	wireframeLinejoin?: string;
	flatShading?: boolean;
	visible?: boolean;
	toneMapped?: boolean;
	fog?: boolean;
	userData?: Record<string, unknown>;
	textures?: Array<Omit<TextureJSON, "metadata">>;
	images?: SourceJSON[];
}
declare class Material extends EventDispatcher<{
	dispose: {};
}> {
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isMaterial: boolean;
	/**
	 * The UUID of the material.
	 */
	readonly uuid: string;
	/**
	 * The type property is used for detecting the object type
	 * in context of serialization/deserialization.
	 */
	type: string;
	/**
	 * This starts at `0` and counts how many times {@link Material#needsUpdate} is set to `true`.
	 *
	 * @default 0
	 */
	readonly version: number;
	defines?: Record<string, unknown> | undefined;
	/**
	 * An optional callback that is executed immediately before the material is used to render a 3D object.
	 *
	 * This method can only be used when rendering with {@link WebGLRenderer}.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {Scene} scene - The scene.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Object3D} object - The 3D object.
	 * @param {Object} group - The geometry group data.
	 */
	onBeforeRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, object: Object3D, group: Group): void;
	/**
	 * An optional callback that is executed immediately before the shader
	 * program is compiled. This function is called with the shader source code
	 * as a parameter. Useful for the modification of built-in materials.
	 *
	 * This method can only be used when rendering with {@link WebGLRenderer}. The
	 * recommended approach when customizing materials is to use `WebGPURenderer` with the new
	 * Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).
	 *
	 * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
	 * @param {WebGLRenderer} renderer - A reference to the renderer.
	 */
	onBeforeCompile(parameters: WebGLProgramParametersWithUniforms, renderer: WebGLRenderer): void;
	/**
	 * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
	 * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
	 * shader or recompile the shader for this material as needed.
	 *
	 * This method can only be used when rendering with {@link WebGLRenderer}.
	 *
	 * @return {string} The custom program cache key.
	 */
	customProgramCacheKey(): string;
	/**
	 * This method can be used to set default values from parameter objects.
	 * It is a generic implementation so it can be used with different types
	 * of materials.
	 *
	 * @param {Object} [values] - The material values to set.
	 */
	setValues(values?: MaterialParameters): void;
	/**
	 * Serializes the material into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized material.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON(meta?: JSONMeta): MaterialJSON;
	/**
	 * Returns a new material with copied values from this instance.
	 *
	 * @return {Material} A clone of this instance.
	 */
	clone(): this;
	/**
	 * Copies the values of the given material to this instance.
	 *
	 * @param {Material} source - The material to copy.
	 * @return {Material} A reference to this instance.
	 */
	copy(source: Material): this;
	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires Material#dispose
	 */
	dispose(): void;
	/**
	 * Setting this property to `true` indicates the engine the material
	 * needs to be recompiled.
	 *
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate(value: boolean);
}
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface Material extends MaterialProperties {
}
declare class DataTexture extends Texture<DataTextureImageData> {
	/**
	 * @param data {@link https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView | ArrayBufferView} of the texture. Default `null`.
	 * @param width Width of the texture. Default `1`.
	 * @param height Height of the texture. Default `1`.
	 * @param format See {@link Texture.format | .format}. Default {@link THREE.RGBAFormat}
	 * @param type See {@link Texture.type | .type}. Default {@link THREE.UnsignedByteType}
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link THREE.Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link THREE.NearestFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link THREE.NearestFilter}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link THREE.Texture.DEFAULT_ANISOTROPY}
	 * @param colorSpace See {@link Texture.colorSpace | .colorSpace}. Default {@link NoColorSpace}
	 */
	constructor(data?: TypedArray | null, width?: number, height?: number, format?: PixelFormat, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, anisotropy?: number, colorSpace?: string);
	/**
	 * Read-only flag to check if a given object is of type {@link DataTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDataTexture: true;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
	/**
	 * @override
	 * @defaultValue `1`
	 */
	unpackAlignment: number;
}
export interface DataTextureImageData {
	data: TypedArray | null;
	width: number;
	height: number;
}
export interface SkeletonJSON {
	metadata: {
		version: number;
		type: string;
		generator: string;
	};
	bones: string[];
	boneInverses: Matrix4Tuple[];
	uuid: string;
}
declare class Skeleton {
	/**
	 * Creates a new Skeleton.
	 * @param bones The array of {@link THREE.Bone | bones}. Default `[]`.
	 * @param boneInverses An array of {@link THREE.Matrix4 | Matrix4s}. Default `[]`.
	 */
	constructor(bones?: Bone[], boneInverses?: Matrix4[]);
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * The array of {@link THREE.Bone | Bones}.
	 * @remarks Note this is a copy of the original array, not a reference, so you can modify the original array without effecting this one.
	 */
	bones: Bone[];
	/**
	 * An array of {@link Matrix4 | Matrix4s} that represent the inverse of the {@link THREE.Matrix4 | matrixWorld} of the individual bones.
	 */
	boneInverses: Matrix4[];
	/**
	 * The array buffer holding the bone data when using a vertex texture.
	 */
	boneMatrices: Float32Array | null;
	previousBoneMatrices: Float32Array | null;
	/**
	 * The {@link THREE.DataTexture | DataTexture} holding the bone data when using a vertex texture.
	 */
	boneTexture: DataTexture | null;
	frame: number;
	init(): void;
	/**
	 * Generates the {@link boneInverses} array if not provided in the constructor.
	 */
	calculateInverses(): void;
	/**
	 * Computes an instance of {@link THREE.DataTexture | DataTexture} in order to pass the bone data more efficiently to the shader
	 * @remarks
	 * The texture is assigned to {@link boneTexture}.
	 */
	computeBoneTexture(): this;
	/**
	 * Returns the skeleton to the base pose.
	 */
	pose(): void;
	/**
	 * Updates the {@link boneMatrices} and {@link boneTexture} after changing the bones
	 * @remarks
	 * This is called automatically by the {@link THREE.WebGLRenderer | WebGLRenderer} if the {@link Skeleton} is used with a {@link THREE.SkinnedMesh | SkinnedMesh}.
	 */
	update(): void;
	/**
	 * Returns a clone of this {@link Skeleton} object.
	 */
	clone(): Skeleton;
	/**
	 * Searches through the skeleton's bone array and returns the first with a matching name.
	 * @param name String to match to the Bone's {@link THREE.Bone.name | .name} property.
	 */
	getBoneByName(name: string): undefined | Bone;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
	toJSON(): SkeletonJSON;
	fromJSON(json: SkeletonJSON, bones: Record<string, Bone>): void;
}
declare class Ray {
	constructor(origin?: Vector3, direction?: Vector3);
	/**
	 * @default new THREE.Vector3()
	 */
	origin: Vector3;
	/**
	 * @default new THREE.Vector3( 0, 0, - 1 )
	 */
	direction: Vector3;
	set(origin: Vector3, direction: Vector3): Ray;
	clone(): this;
	copy(ray: Ray): this;
	at(t: number, target: Vector3): Vector3;
	lookAt(v: Vector3): Ray;
	recast(t: number): Ray;
	closestPointToPoint(point: Vector3, target: Vector3): Vector3;
	distanceToPoint(point: Vector3): number;
	distanceSqToPoint(point: Vector3): number;
	distanceSqToSegment(v0: Vector3, v1: Vector3, optionalPointOnRay?: Vector3, optionalPointOnSegment?: Vector3): number;
	intersectSphere(sphere: Sphere, target: Vector3): Vector3 | null;
	intersectsSphere(sphere: Sphere): boolean;
	distanceToPlane(plane: Plane): number;
	intersectPlane(plane: Plane, target: Vector3): Vector3 | null;
	intersectsPlane(plane: Plane): boolean;
	intersectBox(box: Box3, target: Vector3): Vector3 | null;
	intersectsBox(box: Box3): boolean;
	intersectTriangle(a: Vector3, b: Vector3, c: Vector3, backfaceCulling: boolean, target: Vector3): Vector3 | null;
	applyMatrix4(matrix4: Matrix4): Ray;
	equals(ray: Ray): boolean;
	/**
	 * @deprecated Use {@link Ray#intersectsBox .intersectsBox()} instead.
	 */
	isIntersectionBox(b: any): any;
	/**
	 * @deprecated Use {@link Ray#intersectsPlane .intersectsPlane()} instead.
	 */
	isIntersectionPlane(p: any): any;
	/**
	 * @deprecated Use {@link Ray#intersectsSphere .intersectsSphere()} instead.
	 */
	isIntersectionSphere(s: any): any;
}
export interface Face {
	a: number;
	b: number;
	c: number;
	normal: Vector3;
	materialIndex: number;
}
export interface Intersection<TIntersected extends Object3D = Object3D> {
	/** Distance between the origin of the ray and the intersection */
	distance: number;
	/**
	 * Some objects (f.e. {@link Points}) provide the distance of the intersection to the nearest point on the ray. For
	 * other objects it will be `undefined`
	 */
	distanceToRay?: number | undefined;
	/** Point of intersection, in world coordinates */
	point: Vector3;
	index?: number | undefined;
	/** Intersected face */
	face?: Face | null | undefined;
	/** Index of the intersected face */
	faceIndex?: number | null | undefined;
	barycoord?: Vector3 | null;
	/** The intersected object */
	object: TIntersected;
	uv?: Vector2 | undefined;
	uv1?: Vector2 | undefined;
	normal?: Vector3;
	/** The index number of the instance where the ray intersects the {@link THREE.InstancedMesh | InstancedMesh } */
	instanceId?: number | undefined;
	pointOnLine?: Vector3;
	batchId?: number;
}
export interface RaycasterParameters {
	Mesh: any;
	Line: {
		threshold: number;
	};
	Line2?: {
		threshold: number;
	};
	LOD: any;
	Points: {
		threshold: number;
	};
	Sprite: any;
}
declare class Raycaster {
	/**
	 * This creates a new {@link Raycaster} object.
	 * @param origin The origin vector where the ray casts from. Default `new Vector3()`
	 * @param direction The direction vector that gives direction to the ray. Should be normalized. Default `new Vector3(0, 0, -1)`
	 * @param near All results returned are further away than near. Near can't be negative. Expects a `Float`. Default `0`
	 * @param far All results returned are closer than far. Far can't be lower than near. Expects a `Float`. Default `Infinity`
	 */
	constructor(origin?: Vector3, direction?: Vector3, near?: number, far?: number);
	/**
	 * The {@link THREE.RaycasterRay | Ray} used for the raycasting.
	 */
	ray: Ray;
	/**
	 * The near factor of the raycaster. This value indicates which objects can be discarded based on the distance.
	 * This value shouldn't be negative and should be smaller than the far property.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	near: number;
	/**
	 * The far factor of the raycaster. This value indicates which objects can be discarded based on the distance.
	 * This value shouldn't be negative and should be larger than the near property.
	 * @remarks Expects a `Float`
	 * @defaultValue `Infinity`
	 */
	far: number;
	/**
	 * The camera to use when raycasting against view-dependent objects such as billboarded objects like {@link THREE.Sprites | Sprites}.
	 * This field can be set manually or is set when calling  {@link setFromCamera}.
	 * @defaultValue `null`
	 */
	camera: Camera;
	/**
	 * Used by {@link Raycaster} to selectively ignore 3D objects when performing intersection tests.
	 * The following code example ensures that only 3D objects on layer `1` will be honored by the instance of Raycaster.
	 * ```
	 * raycaster.layers.set( 1 );
	 * object.layers.enable( 1 );
	 * ```
	 * @defaultValue `new THREE.Layers()` - See {@link THREE.Layers | Layers}.
	 */
	layers: Layers;
	/**
	 * An data object where threshold is the precision of the {@link Raycaster} when intersecting objects, in world units.
	 * @defaultValue `{ Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }`
	 */
	params: RaycasterParameters;
	/**
	 * Updates the ray with a new origin and direction
	 * @remarks
	 * Please note that this method only copies the values from the arguments.
	 * @param origin The origin vector where the ray casts from.
	 * @param direction The normalized direction vector that gives direction to the ray.
	 */
	set(origin: Vector3, direction: Vector3): void;
	/**
	 * Updates the ray with a new origin and direction.
	 * @param coords 2D coordinates of the mouse, in normalized device coordinates (NDC)---X and Y components should be between -1 and 1.
	 * @param camera camera from which the ray should originate
	 */
	setFromCamera(coords: Vector2, camera: Camera): void;
	/**
	 * Updates the ray with a new origin and direction.
	 * @param controller The controller to copy the position and direction from.
	 */
	setFromXRController(controller: XRTargetRaySpace): this;
	/**
	 * Checks all intersection between the ray and the object with or without the descendants
	 * @remarks Intersections are returned sorted by distance, closest first
	 * @remarks {@link Raycaster} delegates to the {@link Object3D.raycast | raycast} method of the passed object, when evaluating whether the ray intersects the object or not
	 * This allows {@link THREE.Mesh | meshes} to respond differently to ray casting than {@link THREE.Line | lines} and {@link THREE.Points | pointclouds}.
	 * **Note** that for meshes, faces must be pointed towards the origin of the {@link Raycaster.ray | ray} in order to be detected;
	 * intersections of the ray passing through the back of a face will not be detected
	 * To raycast against both faces of an object, you'll want to set the {@link Mesh.material | material}'s {@link Material.side | side} property to `THREE.DoubleSide`.
	 * @see {@link intersectObjects | .intersectObjects()}.
	 * @param object The object to check for intersection with the ray.
	 * @param recursive If true, it also checks all descendants. Otherwise it only checks intersection with the object. Default `true`
	 * @param optionalTarget Target to set the result. Otherwise a new {@link Array | Array} is instantiated.
	 * If set, you must clear this array prior to each call (i.e., array.length = 0;). Default `[]`
	 * @returns An array of intersections is returned.
	 */
	intersectObject<TIntersected extends Object3D>(object: Object3D, recursive?: boolean, optionalTarget?: Array<Intersection<TIntersected>>): Array<Intersection<TIntersected>>;
	/**
	 * Checks all intersection between the ray and the objects with or without the descendants
	 * @remarks Intersections are returned sorted by distance, closest first
	 * @remarks Intersections are of the same form as those returned by {@link intersectObject | .intersectObject()}.
	 * @remarks {@link Raycaster} delegates to the {@link Object3D.raycast | raycast} method of the passed object, when evaluating whether the ray intersects the object or not
	 * This allows {@link THREE.Mesh | meshes} to respond differently to ray casting than {@link THREE.Line | lines} and {@link THREE.Points | pointclouds}.
	 * **Note** that for meshes, faces must be pointed towards the origin of the {@link Raycaster.ray | ray} in order to be detected;
	 * intersections of the ray passing through the back of a face will not be detected
	 * To raycast against both faces of an object, you'll want to set the {@link Mesh.material | material}'s {@link Material.side | side} property to `THREE.DoubleSide`.
	 * @see {@link intersectObject | .intersectObject()}.
	 * @param objects The objects to check for intersection with the ray.
	 * @param recursive If true, it also checks all descendants of the objects. Otherwise it only checks intersection with the objects. Default `true`
	 * @param optionalTarget Target to set the result. Otherwise a new {@link Array | Array} is instantiated.
	 * If set, you must clear this array prior to each call (i.e., array.length = 0;). Default `[]`
	 * @returns An array of intersections is returned.
	 */
	intersectObjects<TIntersected extends Object3D>(objects: Object3D[], recursive?: boolean, optionalTarget?: Array<Intersection<TIntersected>>): Array<Intersection<TIntersected>>;
}
export interface Object3DJSONObject {
	uuid: string;
	type: string;
	name?: string;
	castShadow?: boolean;
	receiveShadow?: boolean;
	visible?: boolean;
	frustumCulled?: boolean;
	renderOrder?: number;
	userData?: Record<string, unknown>;
	layers: number;
	matrix: Matrix4Tuple;
	up: Vector3Tuple;
	matrixAutoUpdate?: boolean;
	material?: string | string[];
	children?: string[];
	animations?: string[];
}
export interface Object3DJSON {
	metadata?: {
		version: number;
		type: string;
		generator: string;
	};
	object: Object3DJSONObject;
}
export interface JSONMeta {
	geometries: Record<string, BufferGeometryJSON>;
	materials: Record<string, MaterialJSON>;
	textures: Record<string, TextureJSON>;
	images: Record<string, SourceJSON>;
	shapes: Record<string, ShapeJSON>;
	skeletons: Record<string, SkeletonJSON>;
	animations: Record<string, AnimationClipJSON>;
	nodes: Record<string, unknown>;
}
export interface Object3DEventMap {
	/**
	 * Fires when the object has been added to its parent object.
	 */
	added: {};
	/**
	 * Fires when the object has been removed from its parent object.
	 */
	removed: {};
	/**
	 * Fires when a new child object has been added.
	 */
	childadded: {
		child: Object3D;
	};
	/**
	 * Fires when a new child object has been removed.
	 */
	childremoved: {
		child: Object3D;
	};
}
declare class Object3D<TEventMap extends Object3DEventMap = Object3DEventMap> extends EventDispatcher<TEventMap> {
	/**
	 * This creates a new {@link Object3D} object.
	 */
	constructor();
	/**
	 * Flag to check if a given object is of type {@link Object3D}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isObject3D: true;
	/**
	 * Unique number for this {@link Object3D} instance.
	 * @remarks Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.
	 * Expects a `Integer`
	 */
	readonly id: number;
	/**
	 * {@link http://en.wikipedia.org/wiki/Universally_unique_identifier | UUID} of this object instance.
	 * @remarks This gets automatically assigned and shouldn't be edited.
	 */
	uuid: string;
	/**
	 * Optional name of the object
	 * @remarks _(doesn't need to be unique)_.
	 * @defaultValue `""`
	 */
	name: string;
	/**
	 * A Read-only _string_ to check `this` object type.
	 * @remarks This can be used to find a specific type of Object3D in a scene.
	 * Sub-classes will update this value.
	 * @defaultValue `Object3D`
	 */
	readonly type: string;
	/**
	 * Object's parent in the {@link https://en.wikipedia.org/wiki/Scene_graph | scene graph}.
	 * @remarks An object can have at most one parent.
	 * @defaultValue `null`
	 */
	parent: Object3D | null;
	/**
	 * Array with object's children.
	 * @see {@link THREE.Object3DGroup | Group} for info on manually grouping objects.
	 * @defaultValue `[]`
	 */
	children: Object3D[];
	/**
	 * This is used by the {@link lookAt | lookAt} method, for example, to determine the orientation of the result.
	 * @defaultValue {@link DEFAULT_UP | Object3D.DEFAULT_UP} - that is `(0, 1, 0)`.
	 */
	up: Vector3;
	/**
	 * Object's local position.
	 * @defaultValue `new THREE.Vector3()` - that is `(0, 0, 0)`.
	 */
	readonly position: Vector3;
	/**
	 * Object's local rotation ({@link https://en.wikipedia.org/wiki/Euler_angles | Euler angles}), in radians.
	 * @defaultValue `new THREE.Euler()` - that is `(0, 0, 0, Euler.DEFAULT_ORDER)`.
	 */
	readonly rotation: Euler;
	/**
	 * Object's local rotation as a {@link THREE.Quaternion | Quaternion}.
	 * @defaultValue `new THREE.Quaternion()` - that is `(0,  0, 0, 1)`.
	 */
	readonly quaternion: Quaternion;
	/**
	 * The object's local scale.
	 * @defaultValue `new THREE.Vector3( 1, 1, 1 )`
	 */
	readonly scale: Vector3;
	/**
	 * @defaultValue `new THREE.Matrix4()`
	 */
	readonly modelViewMatrix: Matrix4;
	/**
	 * @defaultValue `new THREE.Matrix3()`
	 */
	readonly normalMatrix: Matrix3;
	/**
	 * The local transform matrix.
	 * @defaultValue `new THREE.Matrix4()`
	 */
	matrix: Matrix4;
	/**
	 * The global transform of the object.
	 * @remarks If the {@link Object3D} has no parent, then it's identical to the local transform {@link THREE.Object3D.matrix | .matrix}.
	 * @defaultValue `new THREE.Matrix4()`
	 */
	matrixWorld: Matrix4;
	/**
	 * When this is set, it calculates the matrix of position, (rotation or quaternion) and
	 * scale every frame and also recalculates the matrixWorld property.
	 * @defaultValue {@link DEFAULT_MATRIX_AUTO_UPDATE} - that is `(true)`.
	 */
	matrixAutoUpdate: boolean;
	/**
	 * If set, then the renderer checks every frame if the object and its children need matrix updates.
	 * When it isn't, then you have to maintain all matrices in the object and its children yourself.
	 * @defaultValue {@link DEFAULT_MATRIX_WORLD_AUTO_UPDATE} - that is `(true)`.
	 */
	matrixWorldAutoUpdate: boolean;
	/**
	 * When this is set, it calculates the matrixWorld in that frame and resets this property to false.
	 * @defaultValue `false`
	 */
	matrixWorldNeedsUpdate: boolean;
	/**
	 * The layer membership of the object.
	 * @remarks The object is only visible if it has at least one layer in common with the {@link THREE.Object3DCamera | Camera} in use.
	 * This property can also be used to filter out unwanted objects in ray-intersection tests when using {@link THREE.Raycaster | Raycaster}.
	 * @defaultValue `new THREE.Layers()`
	 */
	layers: Layers;
	/**
	 * Object gets rendered if `true`.
	 * @defaultValue `true`
	 */
	visible: boolean;
	/**
	 * Whether the object gets rendered into shadow map.
	 * @defaultValue `false`
	 */
	castShadow: boolean;
	/**
	 * Whether the material receives shadows.
	 * @defaultValue `false`
	 */
	receiveShadow: boolean;
	/**
	 * When this is set, it checks every frame if the object is in the frustum of the camera before rendering the object.
	 * If set to `false` the object gets rendered every frame even if it is not in the frustum of the camera.
	 * @defaultValue `true`
	 */
	frustumCulled: boolean;
	/**
	 * This value allows the default rendering order of {@link https://en.wikipedia.org/wiki/Scene_graph | scene graph}
	 * objects to be overridden although opaque and transparent objects remain sorted independently.
	 * @remarks When this property is set for an instance of {@link Group | Group}, all descendants objects will be sorted and rendered together.
	 * Sorting is from lowest to highest renderOrder.
	 * @defaultValue `0`
	 */
	renderOrder: number;
	/**
	 * Array with object's animation clips.
	 * @defaultValue `[]`
	 */
	animations: AnimationClip[];
	/**
	 * An object that can be used to store custom data about the {@link Object3D}.
	 * @remarks It should not hold references to _functions_ as these **will not** be cloned.
	 * @default `{}`
	 */
	userData: Record<string, any>;
	/**
	 * Custom depth material to be used when rendering to the depth map.
	 * @remarks Can only be used in context of meshes.
	 * When shadow-casting with a {@link THREE.DirectionalLight | DirectionalLight} or {@link THREE.SpotLight | SpotLight},
	 * if you are modifying vertex positions in the vertex shader you must specify a customDepthMaterial for proper shadows.
	 * @defaultValue `undefined`
	 */
	customDepthMaterial?: Material | undefined;
	/**
	 * Same as {@link customDepthMaterial}, but used with {@link THREE.Object3DPointLight | PointLight}.
	 * @defaultValue `undefined`
	 */
	customDistanceMaterial?: Material | undefined;
	/**
	 * An optional callback that is executed immediately before a 3D object is rendered to a shadow map.
	 * @remarks This function is called with the following parameters: renderer, scene, camera, shadowCamera, geometry,
	 * depthMaterial, group.
	 * Please notice that this callback is only executed for `renderable` 3D objects. Meaning 3D objects which
	 * define their visual appearance with geometries and materials like instances of {@link Mesh}, {@link Line},
	 * {@link Points} or {@link Sprite}. Instances of {@link Object3D}, {@link Group} or {@link Bone} are not renderable
	 * and thus this callback is not executed for such objects.
	 */
	onBeforeShadow(renderer: WebGLRenderer, scene: Scene, camera: Camera, shadowCamera: Camera, geometry: BufferGeometry, depthMaterial: Material, group: Group): void;
	/**
	 * An optional callback that is executed immediately after a 3D object is rendered to a shadow map.
	 * @remarks This function is called with the following parameters: renderer, scene, camera, shadowCamera, geometry,
	 * depthMaterial, group.
	 * Please notice that this callback is only executed for `renderable` 3D objects. Meaning 3D objects which
	 * define their visual appearance with geometries and materials like instances of {@link Mesh}, {@link Line},
	 * {@link Points} or {@link Sprite}. Instances of {@link Object3D}, {@link Group} or {@link Bone} are not renderable
	 * and thus this callback is not executed for such objects.
	 */
	onAfterShadow(renderer: WebGLRenderer, scene: Scene, camera: Camera, shadowCamera: Camera, geometry: BufferGeometry, depthMaterial: Material, group: Group): void;
	/**
	 * An optional callback that is executed immediately before a 3D object is rendered.
	 * @remarks This function is called with the following parameters: renderer, scene, camera, geometry, material, group.
	 * Please notice that this callback is only executed for `renderable` 3D objects. Meaning 3D objects which
	 * define their visual appearance with geometries and materials like instances of {@link Mesh}, {@link Line},
	 * {@link Points} or {@link Sprite}. Instances of {@link Object3D}, {@link Group} or {@link Bone} are not renderable
	 * and thus this callback is not executed for such objects.
	 */
	onBeforeRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: Group): void;
	/**
	 * An optional callback that is executed immediately after a 3D object is rendered.
	 * @remarks This function is called with the following parameters: renderer, scene, camera, geometry, material, group.
	 * Please notice that this callback is only executed for `renderable` 3D objects. Meaning 3D objects which
	 * define their visual appearance with geometries and materials like instances of {@link Mesh}, {@link Line},
	 * {@link Points} or {@link Sprite}. Instances of {@link Object3D}, {@link Group} or {@link Bone} are not renderable
	 * and thus this callback is not executed for such objects.
	 */
	onAfterRender(renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: Group): void;
	/**
	 * The default {@link up} direction for objects, also used as the default position for {@link THREE.DirectionalLight | DirectionalLight},
	 * {@link THREE.HemisphereLight | HemisphereLight} and {@link THREE.Spotlight | Spotlight} (which creates lights shining from the top down).
	 * @defaultValue `new THREE.Vector3( 0, 1, 0)`
	 */
	static DEFAULT_UP: Vector3;
	/**
	 * The default setting for {@link matrixAutoUpdate} for newly created Object3Ds.
	 * @defaultValue `true`
	 */
	static DEFAULT_MATRIX_AUTO_UPDATE: boolean;
	/**
	 * The default setting for {@link matrixWorldAutoUpdate} for newly created Object3Ds.
	 * @defaultValue `true`
	 */
	static DEFAULT_MATRIX_WORLD_AUTO_UPDATE: boolean;
	/**
	 * Applies the matrix transform to the object and updates the object's position, rotation and scale.
	 * @param matrix
	 */
	applyMatrix4(matrix: Matrix4): void;
	/**
	 * Applies the rotation represented by the quaternion to the object.
	 * @param quaternion
	 */
	applyQuaternion(quaternion: Quaternion): this;
	/**
	 * Calls {@link THREE.Quaternion.setFromAxisAngle | setFromAxisAngle}({@link axis}, {@link angle}) on the {@link quaternion | .quaternion}.
	 * @param axis A normalized vector in object space.
	 * @param angle Angle in radians. Expects a `Float`
	 */
	setRotationFromAxisAngle(axis: Vector3, angle: number): void;
	/**
	 * Calls {@link THREE.Quaternion.setFromEuler | setFromEuler}({@link euler}) on the {@link quaternion | .quaternion}.
	 * @param euler Euler angle specifying rotation amount.
	 */
	setRotationFromEuler(euler: Euler): void;
	/**
	 * Calls {@link THREE.Quaternion.setFromRotationMatrix | setFromRotationMatrix}({@link m}) on the {@link quaternion | .quaternion}.
	 * @remarks Note that this assumes that the upper 3x3 of m is a pure rotation matrix (i.e, unscaled).
	 * @param m Rotate the quaternion by the rotation component of the matrix.
	 */
	setRotationFromMatrix(m: Matrix4): void;
	/**
	 * Copy the given {@link THREE.Quaternion | Quaternion} into {@link quaternion | .quaternion}.
	 * @param q Normalized Quaternion.
	 */
	setRotationFromQuaternion(q: Quaternion): void;
	/**
	 * Rotate an object along an axis in object space.
	 * @remarks The axis is assumed to be normalized.
	 * @param axis A normalized vector in object space.
	 * @param angle The angle in radians. Expects a `Float`
	 */
	rotateOnAxis(axis: Vector3, angle: number): this;
	/**
	 * Rotate an object along an axis in world space.
	 * @remarks The axis is assumed to be normalized
	 * Method Assumes no rotated parent.
	 * @param axis A normalized vector in world space.
	 * @param angle The angle in radians. Expects a `Float`
	 */
	rotateOnWorldAxis(axis: Vector3, angle: number): this;
	/**
	 * Rotates the object around _x_ axis in local space.
	 * @param rad The angle to rotate in radians. Expects a `Float`
	 */
	rotateX(angle: number): this;
	/**
	 * Rotates the object around _y_ axis in local space.
	 * @param rad The angle to rotate in radians. Expects a `Float`
	 */
	rotateY(angle: number): this;
	/**
	 * Rotates the object around _z_ axis in local space.
	 * @param rad The angle to rotate in radians. Expects a `Float`
	 */
	rotateZ(angle: number): this;
	/**
	 * Translate an object by distance along an axis in object space
	 * @remarks The axis is assumed to be normalized.
	 * @param axis A normalized vector in object space.
	 * @param distance The distance to translate. Expects a `Float`
	 */
	translateOnAxis(axis: Vector3, distance: number): this;
	/**
	 * Translates object along x axis in object space by {@link distance} units.
	 * @param distance Expects a `Float`
	 */
	translateX(distance: number): this;
	/**
	 * Translates object along _y_ axis in object space by {@link distance} units.
	 * @param distance Expects a `Float`
	 */
	translateY(distance: number): this;
	/**
	 * Translates object along _z_ axis in object space by {@link distance} units.
	 * @param distance Expects a `Float`
	 */
	translateZ(distance: number): this;
	/**
	 * Converts the vector from this object's local space to world space.
	 * @param vector A vector representing a position in this object's local space.
	 */
	localToWorld(vector: Vector3): Vector3;
	/**
	 * Converts the vector from world space to this object's local space.
	 * @param vector A vector representing a position in world space.
	 */
	worldToLocal(vector: Vector3): Vector3;
	/**
	 * Rotates the object to face a point in world space.
	 * @remarks This method does not support objects having non-uniformly-scaled parent(s).
	 * @param vector A vector representing a position in world space to look at.
	 */
	lookAt(vector: Vector3): void;
	/**
	 * Rotates the object to face a point in world space.
	 * @remarks This method does not support objects having non-uniformly-scaled parent(s).
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 * @param z Expects a `Float`
	 */
	lookAt(x: number, y: number, z: number): void;
	/**
	 * Adds another {@link Object3D} as child of this {@link Object3D}.
	 * @remarks An arbitrary number of objects may be added
	 * Any current parent on an {@link object} passed in here will be removed, since an {@link Object3D} can have at most one parent.
	 * @see {@link attach}
	 * @see {@link THREE.Group | Group} for info on manually grouping objects.
	 * @param object
	 */
	add(...object: Object3D[]): this;
	/**
	 * Removes a {@link Object3D} as child of this {@link Object3D}.
	 * @remarks An arbitrary number of objects may be removed.
	 * @see {@link THREE.Group | Group} for info on manually grouping objects.
	 * @param object
	 */
	remove(...object: Object3D[]): this;
	/**
	 * Removes this object from its current parent.
	 */
	removeFromParent(): this;
	/**
	 * Removes all child objects.
	 */
	clear(): this;
	/**
	 * Adds a {@link Object3D} as a child of this, while maintaining the object's world transform.
	 * @remarks Note: This method does not support scene graphs having non-uniformly-scaled nodes(s).
	 * @see {@link add}
	 * @param object
	 */
	attach(object: Object3D): this;
	/**
	 * Searches through an object and its children, starting with the object itself, and returns the first with a matching id.
	 * @remarks Note that ids are assigned in chronological order: 1, 2, 3, ..., incrementing by one for each new object.
	 * @see {@link id}
	 * @param id Unique number of the object instance. Expects a `Integer`
	 */
	getObjectById(id: number): Object3D | undefined;
	/**
	 * Searches through an object and its children, starting with the object itself, and returns the first with a matching name.
	 * @remarks Note that for most objects the name is an empty string by default
	 * You will have to set it manually to make use of this method.
	 * @param name String to match to the children's Object3D.name property.
	 */
	getObjectByName(name: string): Object3D | undefined;
	/**
	 * Searches through an object and its children, starting with the object itself,
	 * and returns the first with a property that matches the value given.
	 *
	 * @param name - the property name to search for.
	 * @param value - value of the given property.
	 */
	getObjectByProperty(name: string, value: any): Object3D | undefined;
	/**
	 * Searches through an object and its children, starting with the object itself,
	 * and returns the first with a property that matches the value given.
	 * @param name The property name to search for.
	 * @param value Value of the given property.
	 * @param optionalTarget target to set the result. Otherwise a new Array is instantiated. If set, you must clear
	 * this array prior to each call (i.e., array.length = 0;).
	 */
	getObjectsByProperty(name: string, value: any, optionalTarget?: Object3D[]): Object3D[];
	/**
	 * Returns a vector representing the position of the object in world space.
	 * @param target The result will be copied into this Vector3.
	 */
	getWorldPosition(target: Vector3): Vector3;
	/**
	 * Returns a quaternion representing the rotation of the object in world space.
	 * @param target The result will be copied into this Quaternion.
	 */
	getWorldQuaternion(target: Quaternion): Quaternion;
	/**
	 * Returns a vector of the scaling factors applied to the object for each axis in world space.
	 * @param target The result will be copied into this Vector3.
	 */
	getWorldScale(target: Vector3): Vector3;
	/**
	 * Returns a vector representing the direction of object's positive z-axis in world space.
	 * @param target The result will be copied into this Vector3.
	 */
	getWorldDirection(target: Vector3): Vector3;
	/**
	 * Abstract (empty) method to get intersections between a casted ray and this object
	 * @remarks Subclasses such as {@link THREE.Mesh | Mesh}, {@link THREE.Line | Line}, and {@link THREE.Points | Points} implement this method in order to use raycasting.
	 * @see {@link THREE.Raycaster | Raycaster}
	 * @param raycaster
	 * @param intersects
	 * @defaultValue `() => {}`
	 */
	raycast(raycaster: Raycaster, intersects: Intersection[]): void;
	/**
	 * Executes the callback on this object and all descendants.
	 * @remarks Note: Modifying the scene graph inside the callback is discouraged.
	 * @param callback A function with as first argument an {@link Object3D} object.
	 */
	traverse(callback: (object: Object3D) => any): void;
	/**
	 * Like traverse, but the callback will only be executed for visible objects
	 * @remarks Descendants of invisible objects are not traversed.
	 * Note: Modifying the scene graph inside the callback is discouraged.
	 * @param callback A function with as first argument an {@link Object3D} object.
	 */
	traverseVisible(callback: (object: Object3D) => any): void;
	/**
	 * Executes the callback on all ancestors.
	 * @remarks Note: Modifying the scene graph inside the callback is discouraged.
	 * @param callback A function with as first argument an {@link Object3D} object.
	 */
	traverseAncestors(callback: (object: Object3D) => any): void;
	/**
	 * Updates local transform.
	 */
	updateMatrix(): void;
	/**
	 * Updates the global transform of the object.
	 * And will update the object descendants if {@link matrixWorldNeedsUpdate | .matrixWorldNeedsUpdate} is set to true or if the {@link force} parameter is set to `true`.
	 * @param force A boolean that can be used to bypass {@link matrixWorldAutoUpdate | .matrixWorldAutoUpdate}, to recalculate the world matrix of the object and descendants on the current frame.
	 * Useful if you cannot wait for the renderer to update it on the next frame, assuming {@link matrixWorldAutoUpdate | .matrixWorldAutoUpdate} set to `true`.
	 */
	updateMatrixWorld(force?: boolean): void;
	/**
	 * Updates the global transform of the object.
	 * @param updateParents Recursively updates global transform of ancestors.
	 * @param updateChildren Recursively updates global transform of descendants.
	 */
	updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
	/**
	 * Convert the object to three.js {@link https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4 | JSON Object/Scene format}.
	 * @param meta Object containing metadata such as materials, textures or images for the object.
	 */
	toJSON(meta?: JSONMeta): Object3DJSON;
	/**
	 * Returns a clone of `this` object and optionally all descendants.
	 * @param recursive If true, descendants of the object are also cloned. Default `true`
	 */
	clone(recursive?: boolean): this;
	/**
	 * Copies the given object into this object.
	 * @remarks Event listeners and user-defined callbacks ({@link .onAfterRender} and {@link .onBeforeRender}) are not copied.
	 * @param object
	 * @param recursive If set to `true`, descendants of the object are copied next to the existing ones. If set to
	 * `false`, descendants are left unchanged. Default is `true`.
	 */
	copy(object: Object3D, recursive?: boolean): this;
}
declare class AnimationObjectGroup {
	/**
	 * Constructs a new animation group.
	 *
	 * @param {...Object3D} arguments - An arbitrary number of 3D objects that share the same animation state.
	 */
	constructor(...args: Object3D[]);
	/**
	 * This flag can be used for type testing.
	 *
	 * @default true
	 */
	readonly isAnimationObjectGroup: true;
	/**
	 * The UUID of the 3D object.
	 */
	readonly uuid: string;
	/**
	 * Adds an arbitrary number of objects to this animation group.
	 *
	 * @param {...Object3D} arguments - The 3D objects to add.
	 */
	add(...args: Object3D[]): void;
	/**
	 * Removes an arbitrary number of objects to this animation group
	 *
	 * @param {...Object3D} arguments - The 3D objects to remove.
	 */
	remove(...args: Object3D[]): void;
	/**
	 * Deallocates all memory resources for the passed 3D objects of this animation group.
	 *
	 * @param {...Object3D} arguments - The 3D objects to uncache.
	 */
	uncache(...args: Object3D[]): void;
}
export interface ParseTrackNameResults {
	nodeName: string;
	objectName: string;
	objectIndex: string;
	propertyName: string;
	propertyIndex: string;
}
declare class PropertyBinding {
	/**
	 * Factory method for creating a property binding from the given parameters.
	 *
	 * @static
	 * @param {Object} root - The root node.
	 * @param {string} path - The path.
	 * @param {?Object} [parsedPath] - The parsed path.
	 * @return {PropertyBinding|Composite} The created property binding or composite.
	 */
	static create(root: object, path: string, parsedPath?: object | null): PropertyBinding | Composite;
	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name - Node name to be sanitized.
	 * @return {string} The sanitized node name.
	 */
	static sanitizeNodeName(name: string): string;
	/**
	 * Parses the given track name (an object path to an animated property) and
	 * returns an object with information about the path. Matches strings in the following forms:
	 *
	 * - nodeName.property
	 * - nodeName.property[accessor]
	 * - nodeName.material.property[accessor]
	 * - uuid.property[accessor]
	 * - uuid.objectName[objectIndex].propertyName[propertyIndex]
	 * - parentName/nodeName.property
	 * - parentName/parentName/nodeName.property[index]
	 * - .bone[Armature.DEF_cog].position
	 * - scene:helium_balloon_model:helium_balloon_model.position
	 *
	 * @static
	 * @param {string} trackName - The track name to parse.
	 * @return {Object} The parsed track name as an object.
	 */
	static parseTrackName(trackName: string): ParseTrackNameResults;
	/**
	 * Searches for a node in the hierarchy of the given root object by the given
	 * node name.
	 *
	 * @static
	 * @param {Object} root - The root object.
	 * @param {string|number} nodeName - The name of the node.
	 * @return {?Object} The found node. Returns `null` if no object was found.
	 */
	static findNode(root: object, nodeName: string | number): object | null;
	/**
	 * Constructs a new property binding.
	 *
	 * @param {Object} rootNode - The root node.
	 * @param {string} path - The path.
	 * @param {?Object} [parsedPath] - The parsed path.
	 */
	constructor(rootNode: Object3D | Skeleton, path: string, parsedPath?: object | null);
	/**
	 * The object path to the animated property.
	 */
	path: string;
	/**
	 * An object holding information about the path.
	 */
	parsedPath: object;
	/**
	 * The object owns the animated property.
	 */
	node: object | null;
	/**
	 * The root node.
	 */
	rootNode: Object3D | Skeleton;
	/**
	 * Creates a getter / setter pair for the property tracked by this binding.
	 */
	bind(): void;
	/**
	 * Unbinds the property.
	 */
	unbind(): void;
}
declare namespace PropertyBinding {
	export { Composite };
}
declare class Composite {
}
declare class PropertyMixer {
	/**
	 * Constructs a new property mixer.
	 *
	 * @param {PropertyBinding} binding - The property binding.
	 * @param {string} typeName - The keyframe track type name.
	 * @param {number} valueSize - The keyframe track value size.
	 */
	constructor(binding: PropertyBinding, typeName: string, valueSize: number);
	/**
	 * The property binding.
	 */
	binding: PropertyBinding;
	/**
	 * The keyframe track value size.
	 */
	valueSize: number;
	/**
	 * TODO
	 *
	 * @default 0
	 */
	cumulativeWeight: number;
	/**
	 * TODO
	 *
	 * @default 0
	 */
	cumulativeWeightAdditive: number;
	/**
	 * TODO
	 *
	 * @default 0
	 */
	useCount: number;
	/**
	 * TODO
	 *
	 * @default 0
	 */
	referenceCount: number;
	/**
	 * Accumulates data in the `incoming` region into `accu<i>`.
	 *
	 * @param {number} accuIndex - The accumulation index.
	 * @param {number} weight - The weight.
	 */
	accumulate(accuIndex: number, weight: number): void;
	/**
	 * Accumulates data in the `incoming` region into `add`.
	 *
	 * @param {number} weight - The weight.
	 */
	accumulateAdditive(weight: number): void;
	/**
	 * Applies the state of `accu<i>` to the binding when accus differ.
	 *
	 * @param {number} accuIndex - The accumulation index.
	 */
	apply(accuIndex: number): void;
	/**
	 * Remembers the state of the bound property and copy it to both accus.
	 */
	saveOriginalState(): void;
	/**
	 * Applies the state previously taken via {@link PropertyMixer#saveOriginalState} to the binding.
	 */
	restoreOriginalState(): void;
}
export interface AnimationMixerEventMap {
	loop: {
		action: AnimationAction;
		loopDelta: number;
	};
	finished: {
		action: AnimationAction;
		direction: number;
	};
}
export interface MixerControlInterpolant extends LinearInterpolant {
	__cacheIndex: number;
}
export interface AnimationMixerStats {
	actions: {
		readonly total: number;
		readonly inUse: number;
	};
	bindings: {
		readonly total: number;
		readonly inUse: number;
	};
	controlInterpolants: {
		readonly total: number;
		readonly inUse: number;
	};
}
declare class AnimationMixer extends EventDispatcher<AnimationMixerEventMap> {
	/**
	 * Constructs a new animation mixer.
	 *
	 * @param {Object3D} root - The object whose animations shall be played by this mixer.
	 */
	constructor(root: Object3D | AnimationObjectGroup);
	/**
	 * The global mixer time (in seconds; starting with `0` on the mixer's creation).
	 *
	 * @default 0
	 */
	time: number;
	protected _root: Object3D | AnimationObjectGroup;
	protected _actions: AnimationAction[];
	protected _nActiveActions: number;
	protected _bindings: PropertyMixer[];
	protected _nActiveBindings: number;
	protected _controlInterpolants: MixerControlInterpolant[];
	protected _nActiveControlInterpolants: number;
	protected _bindingsByRootAndName: {
		[rootUuid: string]: {
			[trackName: string]: PropertyMixer;
		};
	};
	protected _actionsByClip: {
		[clipUuid: string]: {
			knownActions: AnimationAction[];
			actionByRoot: {
				[rootUuid: string]: AnimationAction;
			};
		};
	};
	protected _accuIndex: number;
	/**
	 * A scaling factor for the global time.
	 *
	 * Note: Setting this member to `0` and later back to `1` is a
	 * possibility to pause/unpause all actions that are controlled by this
	 * mixer.
	 *
	 * @default 1
	 */
	timeScale: number;
	/**
	 * The AnimationMixer stats track the actions of the mixer.
	 */
	stats: AnimationMixerStats;
	/**
	 * Returns an instance of {@link AnimationAction} for the passed clip.
	 *
	 * If an action fitting the clip and root parameters doesn't yet exist, it
	 * will be created by this method. Calling this method several times with the
	 * same clip and root parameters always returns the same action.
	 *
	 * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
	 * @param {Object3D} [optionalRoot] - An alternative root object.
	 * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
	 * @return {?AnimationAction} The animation action.
	 */
	clipAction(clip: AnimationClip, optionalRoot?: Object3D | AnimationObjectGroup, blendMode?: AnimationBlendMode): AnimationAction;
	clipAction(clip: AnimationClip | string, optionalRoot?: Object3D | AnimationObjectGroup, blendMode?: AnimationBlendMode): AnimationAction | null;
	/**
	 * Returns an existing animation action for the passed clip.
	 *
	 * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
	 * @param {Object3D} [optionalRoot] - An alternative root object.
	 * @return {?AnimationAction} The animation action. Returns `null` if no action was found.
	 */
	existingAction(clip: AnimationClip | string, optionalRoot?: Object3D | AnimationObjectGroup): AnimationAction | null;
	/**
	 * Deactivates all previously scheduled actions on this mixer.
	 *
	 * @return {AnimationMixer} A reference to this animation mixer.
	 */
	stopAllAction(): AnimationMixer;
	/**
	 * Advances the global mixer time and updates the animation.
	 *
	 * This is usually done in the render loop by passing the delta
	 * time from {@link Clock} or {@link Timer}.
	 *
	 * @param {number} deltaTime - The delta time in seconds.
	 * @return {AnimationMixer} A reference to this animation mixer.
	 */
	update(deltaTime: number): AnimationMixer;
	/**
	 * Sets the global mixer to a specific time and updates the animation accordingly.
	 *
	 * This is useful when you need to jump to an exact time in an animation. The
	 * input parameter will be scaled by {@link AnimationMixer#timeScale}
	 *
	 * @param {number} time - The time to set in seconds.
	 * @return {AnimationMixer} A reference to this animation mixer.
	 */
	setTime(time: number): AnimationMixer;
	/**
	 * Returns this mixer's root object.
	 *
	 * @return {Object3D} The mixer's root object.
	 */
	getRoot(): Object3D | AnimationObjectGroup;
	/**
	 * Deallocates all memory resources for a clip. Before using this method make
	 * sure to call {@link AnimationAction#stop} for all related actions.
	 *
	 * @param {AnimationClip} clip - The clip to uncache.
	 */
	uncacheClip(clip: AnimationClip): void;
	/**
	 * Deallocates all memory resources for a root object. Before using this
	 * method make sure to call {@link AnimationAction#stop} for all related
	 * actions or alternatively {@link AnimationMixer#stopAllAction} when the
	 * mixer operates on a single root.
	 *
	 * @param {Object3D} root - The root object to uncache.
	 */
	uncacheRoot(root: Object3D | AnimationObjectGroup): void;
	/**
	 * Deallocates all memory resources for an action. The action is identified by the
	 * given clip and an optional root object. Before using this method make
	 * sure to call {@link AnimationAction#stop} to deactivate the action.
	 *
	 * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
	 * @param {Object3D} [optionalRoot] - An alternative root object.
	 */
	uncacheAction(clip: AnimationClip | string, optionalRoot?: Object3D | AnimationObjectGroup): void;
}
declare class AnimationAction {
	/**
	 * Constructs a new animation action.
	 *
	 * @param {AnimationMixer} mixer - The mixer that is controlled by this action.
	 * @param {AnimationClip} clip - The animation clip that holds the actual keyframes.
	 * @param {?Object3D} [localRoot=null] - The root object on which this action is performed.
	 * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
	 */
	constructor(mixer: AnimationMixer, clip: AnimationClip, localRoot?: Object3D | null, blendMode?: AnimationBlendMode);
	/**
	 * Defines how the animation is blended/combined when two or more animations
	 * are simultaneously played.
	 */
	blendMode: AnimationBlendMode;
	/**
	 * The loop mode, set via {@link AnimationAction#setLoop}.
	 *
	 * @default LoopRepeat
	 */
	loop: AnimationActionLoopStyles;
	/**
	 * The local time of this action (in seconds, starting with `0`).
	 *
	 * The value gets clamped or wrapped to `[0,clip.duration]` (according to the
	 * loop state).
	 *
	 * @default Infinity
	 */
	time: number;
	/**
	 * Scaling factor for the {@link AnimationAction#time}. A value of `0` causes the
	 * animation to pause. Negative values cause the animation to play backwards.
	 *
	 * @default 1
	 */
	timeScale: number;
	/**
	 * The degree of influence of this action (in the interval `[0, 1]`). Values
	 * between `0` (no impact) and `1` (full impact) can be used to blend between
	 * several actions.
	 *
	 * @default 1
	 */
	weight: number;
	/**
	 * The number of repetitions of the performed clip over the course of this action.
	 * Can be set via {@link AnimationAction#setLoop}.
	 *
	 * Setting this number has no effect if {@link AnimationAction#loop} is set to
	 * `THREE:LoopOnce`.
	 *
	 * @default Infinity
	 */
	repetitions: number;
	/**
	 * If set to `true`, the playback of the action is paused.
	 *
	 * @default false
	 */
	paused: boolean;
	/**
	 * If set to `false`, the action is disabled so it has no impact.
	 *
	 * When the action is re-enabled, the animation continues from its current
	 * time (setting `enabled` to `false` doesn't reset the action).
	 *
	 * @default true
	 */
	enabled: boolean;
	/**
	 * If set to true the animation will automatically be paused on its last frame.
	 *
	 * If set to false, {@link AnimationAction#enabled} will automatically be switched
	 * to `false` when the last loop of the action has finished, so that this action has
	 * no further impact.
	 *
	 * Note: This member has no impact if the action is interrupted (it
	 * has only an effect if its last loop has really finished).
	 *
	 * @default false
	 */
	clampWhenFinished: boolean;
	/**
	 * Enables smooth interpolation without separate clips for start, loop and end.
	 *
	 * @default true
	 */
	zeroSlopeAtStart: boolean;
	/**
	 * Enables smooth interpolation without separate clips for start, loop and end.
	 *
	 * @default true
	 */
	zeroSlopeAtEnd: boolean;
	/**
	 * Starts the playback of the animation.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	play(): AnimationAction;
	/**
	 * Stops the playback of the animation.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	stop(): AnimationAction;
	/**
	 * Resets the playback of the animation.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	reset(): AnimationAction;
	/**
	 * Returns `true` if the animation is running.
	 *
	 * @return {boolean} Whether the animation is running or not.
	 */
	isRunning(): boolean;
	/**
	 * Returns `true` when {@link AnimationAction#play} has been called.
	 *
	 * @return {boolean} Whether the animation is scheduled or not.
	 */
	isScheduled(): boolean;
	/**
	 * Defines the time when the animation should start.
	 *
	 * @param {number} time - The start time in seconds.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	startAt(time: number): AnimationAction;
	/**
	 * Configures the loop settings for this action.
	 *
	 * @param {(LoopRepeat|LoopOnce|LoopPingPong)} mode - The loop mode.
	 * @param {number} repetitions - The number of repetitions.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	setLoop(mode: AnimationActionLoopStyles, repetitions: number): AnimationAction;
	/**
	 * Sets the effective weight of this action.
	 *
	 * An action has no effect and thus an effective weight of zero when the
	 * action is disabled.
	 *
	 * @param {number} weight - The weight to set.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	setEffectiveWeight(weight: number): AnimationAction;
	/**
	 * Returns the effective weight of this action.
	 *
	 * @return {number} The effective weight.
	 */
	getEffectiveWeight(): number;
	/**
	 * Fades the animation in by increasing its weight gradually from `0` to `1`,
	 * within the passed time interval.
	 *
	 * @param {number} duration - The duration of the fade.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	fadeIn(duration: number): AnimationAction;
	/**
	 * Fades the animation out by decreasing its weight gradually from `1` to `0`,
	 * within the passed time interval.
	 *
	 * @param {number} duration - The duration of the fade.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	fadeOut(duration: number): AnimationAction;
	/**
	 * Causes this action to fade in and the given action to fade out,
	 * within the passed time interval.
	 *
	 * @param {AnimationAction} fadeOutAction - The animation action to fade out.
	 * @param {number} duration - The duration of the fade.
	 * @param {boolean} [warp=false] - Whether warping should be used or not.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	crossFadeFrom(fadeOutAction: AnimationAction, duration: number, warp?: boolean): AnimationAction;
	/**
	 * Causes this action to fade out and the given action to fade in,
	 * within the passed time interval.
	 *
	 * @param {AnimationAction} fadeInAction - The animation action to fade in.
	 * @param {number} duration - The duration of the fade.
	 * @param {boolean} [warp=false] - Whether warping should be used or not.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	crossFadeTo(fadeInAction: AnimationAction, duration: number, warp?: boolean): AnimationAction;
	/**
	 * Stops any fading which is applied to this action.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	stopFading(): AnimationAction;
	/**
	 * Sets the effective time scale of this action.
	 *
	 * An action has no effect and thus an effective time scale of zero when the
	 * action is paused.
	 *
	 * @param {number} timeScale - The time scale to set.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	setEffectiveTimeScale(timeScale: number): AnimationAction;
	/**
	 * Returns the effective time scale of this action.
	 *
	 * @return {number} The effective time scale.
	 */
	getEffectiveTimeScale(): number;
	/**
	 * Sets the duration for a single loop of this action.
	 *
	 * @param {number} duration - The duration to set.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	setDuration(duration: number): AnimationAction;
	/**
	 * Synchronizes this action with the passed other action.
	 *
	 * @param {AnimationAction} action - The action to sync with.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	syncWith(action: AnimationAction): AnimationAction;
	/**
	 * Decelerates this animation's speed to `0` within the passed time interval.
	 *
	 * @param {number} duration - The duration.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	halt(duration: number): AnimationAction;
	/**
	 * Changes the playback speed, within the passed time interval, by modifying
	 * {@link AnimationAction#timeScale} gradually from `startTimeScale` to
	 * `endTimeScale`.
	 *
	 * @param {number} startTimeScale - The start time scale.
	 * @param {number} endTimeScale - The end time scale.
	 * @param {number} duration - The duration.
	 * @return {AnimationAction} A reference to this animation action.
	 */
	warp(startTimeScale: number, endTimeScale: number, duration: number): AnimationAction;
	/**
	 * Stops any scheduled warping which is applied to this action.
	 *
	 * @return {AnimationAction} A reference to this animation action.
	 */
	stopWarping(): AnimationAction;
	/**
	 * Returns the animation mixer of this animation action.
	 *
	 * @return {AnimationMixer} The animation mixer.
	 */
	getMixer(): AnimationMixer;
	/**
	 * Returns the animation clip of this animation action.
	 *
	 * @return {AnimationClip} The animation clip.
	 */
	getClip(): AnimationClip;
	/**
	 * Returns the root object of this animation action.
	 *
	 * @return {Object3D} The root object.
	 */
	getRoot(): Object3D;
	_scheduleFading(duration: number, weightNow: number, weightThen: number): this;
}
declare function createCanvasElement(): HTMLCanvasElement;
declare function setConsoleFunction(fn: (type: "log" | "warn" | "error", message: string, ...params: unknown[]) => void): void;
declare function getConsoleFunction(): (type: "log" | "warn" | "error", message: string, ...params: unknown[]) => void;
declare function log(...params: unknown[]): void;
declare function warn(...params: unknown[]): void;
declare function error(...params: unknown[]): void;
declare function warnOnce(...params: unknown[]): void;
declare class AnimationUtils {
	/**
	 * Converts an array to a specific type
	 *
	 * @static
	 * @param {TypedArray|Array} array - The array to convert.
	 * @param {TypedArray.constructor} type - The constructor of a type array.
	 * @return {TypedArray} The converted array
	 */
	static convertArray(array: TypedArray | number[], type: TypedArrayConstructor): TypedArray | number[];
	/**
	 * Returns `true` if the given object is a typed array.
	 *
	 * @static
	 * @param {any} object - The object to check.
	 * @return {boolean} Whether the given object is a typed array.
	 */
	static isTypedArray(object: unknown): boolean;
	/**
	 * Returns an array by which times and values can be sorted.
	 *
	 * @static
	 * @param {Array<number>} times - The keyframe time values.
	 * @return {Array<number>} The array.
	 */
	static getKeyframeOrder(times: Array<number>): Array<number>;
	/**
	 * Sorts the given array by the previously computed order via `getKeyframeOrder()`.
	 *
	 * @static
	 * @param {Array<number>} values - The values to sort.
	 * @param {number} stride - The stride.
	 * @param {Array<number>} order - The sort order.
	 * @return {Array<number>} The sorted values.
	 */
	static sortedArray(values: Array<number>, stride: number, order: Array<number>): Array<number>;
	/**
	 * Used for parsing AOS keyframe formats.
	 *
	 * @static
	 * @param {Array<number>} jsonKeys - A list of JSON keyframes.
	 * @param {Array<number>} times - This array will be filled with keyframe times by this method.
	 * @param {Array<number>} values - This array will be filled with keyframe values by this method.
	 * @param {string} valuePropertyName - The name of the property to use.
	 */
	static flattenJSON(jsonKeys: Array<number>, times: Array<number>, values: Array<number>, valuePropertyName: string): void;
	/**
	 * Creates a new clip, containing only the segment of the original clip between the given frames.
	 *
	 * @static
	 * @param {AnimationClip} sourceClip - The values to sort.
	 * @param {string} name - The name of the clip.
	 * @param {number} startFrame - The start frame.
	 * @param {number} endFrame - The end frame.
	 * @param {number} [fps=30] - The FPS.
	 * @return {AnimationClip} The new sub clip.
	 */
	static subclip(sourceClip: AnimationClip, name: string, startFrame: number, endFrame: number, fps?: number): AnimationClip;
	/**
	 * Converts the keyframes of the given animation clip to an additive format.
	 *
	 * @static
	 * @param {AnimationClip} targetClip - The clip to make additive.
	 * @param {number} [referenceFrame=0] - The reference frame.
	 * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.
	 * @param {number} [fps=30] - The FPS.
	 * @return {AnimationClip} The updated clip which is now additive.
	 */
	static makeClipAdditive(targetClip: AnimationClip, referenceFrame?: number, referenceClip?: AnimationClip, fps?: number): AnimationClip;
}
declare class BooleanKeyframeTrack extends KeyframeTrack {
	/**
	 * Constructs a new boolean keyframe track.
	 *
	 * This keyframe track type has no `interpolation` parameter because the
	 * interpolation is always discrete.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<boolean>} values - A list of keyframe values.
	 */
	constructor(name: string, times: ArrayLike<number>, values: ArrayLike<boolean>);
}
declare class ColorKeyframeTrack extends KeyframeTrack {
	/**
	 * Constructs a new color keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor(name: string, times: ArrayLike<number>, values: ArrayLike<number>, interpolation?: InterpolationModes);
}
declare class NumberKeyframeTrack extends KeyframeTrack {
	/**
	 * Constructs a new number keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor(name: string, times: ArrayLike<number>, values: ArrayLike<number>, interpolation?: InterpolationModes);
}
declare class QuaternionKeyframeTrack extends KeyframeTrack {
	/**
	 * Constructs a new Quaternion keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor(name: string, times: ArrayLike<number>, values: ArrayLike<number>, interpolation?: InterpolationModes);
}
declare class StringKeyframeTrack extends KeyframeTrack {
	/**
	 * Constructs a new string keyframe track.
	 *
	 * This keyframe track type has no `interpolation` parameter because the
	 * interpolation is always discrete.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<string>} values - A list of keyframe values.
	 */
	constructor(name: string, times: ArrayLike<number>, values: ArrayLike<string>);
}
declare class VectorKeyframeTrack extends KeyframeTrack {
	/**
	 * Constructs a new vector keyframe track.
	 *
	 * @param {string} name - The keyframe track's name.
	 * @param {Array<number>} times - A list of keyframe times.
	 * @param {Array<number>} values - A list of keyframe values.
	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
	 */
	constructor(name: string, times: ArrayLike<number>, values: ArrayLike<number>, interpolation?: InterpolationModes);
}
declare namespace AudioContext$1 {
	/**
	 * Return the value of the variable `context` in the outer scope, if defined, otherwise set it to a new {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext | AudioContext}.
	 */
	function getContext(): AudioContext;
	/**
	 * Set the variable `context` in the outer scope to `value`.
	 * @param value
	 */
	function setContext(context: AudioContext): void;
}
declare class AudioListener$1 extends Object3D {
	/**
	 * Create a new AudioListener.
	 */
	constructor();
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `AudioListener`
	 */
	readonly type: string | "AudioListener";
	/**
	 * The {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext | AudioContext} of the {@link {@link AudioListener} | listener} given in the constructor.
	 */
	context: AudioContext;
	/**
	 * A {@link https://developer.mozilla.org/en-US/docs/Web/API/GainNode | GainNode} created using
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createGain | AudioContext.createGain()}.
	 */
	gain: GainNode;
	/**
	 * @defaultValue `null`
	 */
	filter: AudioNode;
	/**
	 * Time delta value for audio entities. Use in context of {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/linearRampToValueAtTime | AudioParam.linearRampToValueAtTimeDefault()}.
	 * @defaultValue `0`
	 */
	timeDelta: number;
	/**
	 * Return the {@link AudioListener.gain | gainNode}.
	 */
	getInput(): GainNode;
	/**
	 * Set the {@link AudioListener.filter | filter} property to `null`.
	 */
	removeFilter(): this;
	/**
	 * Returns the value of the {@link AudioListener.filter | filter} property.
	 */
	getFilter(): AudioNode;
	/**
	 * Set the {@link AudioListener.filter | filter} property to `value`.
	 * @param value
	 */
	setFilter(value: AudioNode): this;
	/**
	 * Return the volume.
	 */
	getMasterVolume(): number;
	/**
	 * Set the volume.
	 * @param value
	 */
	setMasterVolume(value: number): this;
}
declare class Audio$1<NodeType extends AudioNode = GainNode> extends Object3D {
	/**
	 * Create a new instance of {@link Audio}
	 * @param listener (required) {@link AudioListener | AudioListener} instance.
	 */
	constructor(listener: AudioListener$1);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `Audio`
	 */
	readonly type: string | "Audio";
	/**
	 * A reference to the listener object of this audio.
	 */
	listener: AudioListener$1;
	/**
	 * The {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext | AudioContext} of the {@link AudioListener | listener} given in the constructor.
	 */
	context: AudioContext;
	/**
	 * A {@link https://developer.mozilla.org/en-US/docs/Web/API/GainNode | GainNode} created using
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createGain | AudioContext.createGain}().
	 */
	gain: GainNode;
	/**
	 * Whether to start playback automatically.
	 * @defaultValue `false`
	 */
	autoplay: boolean;
	buffer: AudioBuffer | null;
	/**
	 * Modify pitch, measured in cents. +/- 100 is a semitone. +/- 1200 is an octave.
	 * @defaultValue `0`
	 */
	detune: number;
	/**
	 * @default false
	 */
	loop: boolean;
	/**
	 * @default 0
	 */
	loopStart: number;
	/**
	 * @default 0
	 */
	loopEnd: number;
	/**
	 * An offset to the time within the {@link Audio} buffer that playback should begin.
	 * Same as the {@link Audio.offset | offset} parameter of {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/start | AudioBufferSourceNode.start()}.
	 * @defaultValue `0`
	 */
	offset: number;
	/**
	 * Overrides the duration of the audio. Same as the {@link Audio.duration | duration} parameter of
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/start | AudioBufferSourceNode.start()}.
	 * @defaultValue `undefined` _to play the whole buffer_.
	 */
	duration: number | undefined;
	/**
	 * Speed of playback.
	 * @defaultValue `1`
	 */
	playbackRate: number;
	/**
	 * Whether the {@link Audio} is currently playing.
	 * @defaultValue `false`
	 */
	isPlaying: boolean;
	/**
	 * Whether playback can be controlled using the {@link Audio.play | play}(), {@link Audio.pause | pause}() etc. methods.
	 * @defaultValue `true`
	 */
	hasPlaybackControl: boolean;
	/**
	 * Type of the {@link Audio} source.
	 * @defaultValue 'empty'.
	 */
	sourceType: string;
	/**
	 * An {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode | AudioBufferSourceNode} created using
	 * {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createBufferSource | AudioContext.createBufferSource()}.
	 */
	source: AudioScheduledSourceNode | null;
	/**
	 * Represents an array of {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioNode | AudioNodes}.
	 * Can be used to apply a variety of low-order filters to create more complex sound effects.
	 * In most cases, the array contains instances of {@link https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode | BiquadFilterNodes}.
	 * Filters are set via {@link THREE.Audio.setFilter | Audio.setFilter} or {@link THREE.Audio.setFilters | Audio.setFilters}.
	 * @defaultValue `[]`
	 */
	filters: AudioNode[];
	/**
	 * Return the {@link Audio.gain | gainNode}.
	 */
	getOutput(): NodeType;
	/**
	 * Setup the {@link Audio.source | source} to the audioBuffer, and sets {@link Audio.sourceType | sourceType} to 'audioNode'.
	 * @remarks Also sets {@link Audio.hasPlaybackControl | hasPlaybackControl} to false.
	 */
	setNodeSource(audioNode: AudioScheduledSourceNode): this;
	/**
	 * Applies the given object of type {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement | HTMLMediaElement} as the source of this audio.
	 * @remarks Also sets {@link Audio.hasPlaybackControl | hasPlaybackControl} to false.
	 */
	setMediaElementSource(mediaElement: HTMLMediaElement): this;
	/**
	 * Applies the given object of type {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaStream | MediaStream} as the source of this audio.
	 * @remarks Also sets {@link Audio.hasPlaybackControl | hasPlaybackControl} to false.
	 */
	setMediaStreamSource(mediaStream: MediaStream): this;
	/**
	 * Setup the {@link Audio.source | source} to the audioBuffer, and sets {@link Audio.sourceType | sourceType} to 'buffer'.
	 * @remarks If {@link Audio.autoplay | autoplay}, also starts playback.
	 */
	setBuffer(audioBuffer: AudioBuffer): this;
	/**
	 * If {@link Audio.hasPlaybackControl | hasPlaybackControl} is true, starts playback.
	 */
	play(delay?: number): this;
	/**
	 * If {@link Audio.hasPlaybackControl | hasPlaybackControl} is true, pauses playback.
	 */
	pause(): this;
	/**
	 * If {@link Audio.hasPlaybackControl | hasPlaybackControl} is enabled, stops playback.
	 * @param delay (optional) - The delay, in seconds, at which the audio should start playing.
	 */
	stop(delay?: number): this;
	/**
	 * Called automatically when playback finished.
	 */
	onEnded(): void;
	/**
	 * Connect to the {@link THREE.Audio.source | Audio.source}
	 * @remarks This is used internally on initialisation and when setting / removing filters.
	 */
	connect(): this;
	/**
	 * Disconnect from the {@link THREE.Audio.source | Audio.source}
	 * @remarks This is used internally when setting / removing filters.
	 */
	disconnect(): this;
	/**
	 * Returns the detuning of oscillation in cents.
	 */
	getDetune(): number;
	/**
	 * Defines the detuning of oscillation in cents.
	 * @param value Expects a `Float`
	 */
	setDetune(value: number): this;
	/**
	 * Returns the first element of the {@link Audio.filters | filters} array.
	 */
	getFilter(): AudioNode;
	/**
	 * Applies a single filter node to the audio.
	 */
	setFilter(filter: AudioNode): this;
	/**
	 * Returns the {@link Audio.filters | filters} array.
	 */
	getFilters(): AudioNode[];
	/**
	 * Applies an array of filter nodes to the audio.
	 * @param value Arrays of filters.
	 */
	setFilters(value: AudioNode[]): this;
	/**
	 * Return the value of {@link Audio.playbackRate | playbackRate}.
	 */
	getPlaybackRate(): number;
	/**
	 * If {@link Audio.hasPlaybackControl | hasPlaybackControl} is enabled, set the {@link Audio.playbackRate | playbackRate} to `value`.
	 * @param value Expects a `Float`
	 */
	setPlaybackRate(value: number): this;
	/**
	 * Return the value of {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/loop | source.loop} (whether playback should loop).
	 */
	getLoop(): boolean;
	/**
	 * Set {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/loop | source.loop} to `value` (whether playback should loop).
	 * @param value
	 */
	setLoop(value: boolean): this;
	/**
	 * Set {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/loopStart | source.loopStart} to `value`.
	 * @param value Expects a `Float`
	 */
	setLoopStart(value: number): this;
	/**
	 * Set {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/loopEnd | source.loopEnd} to `value`.
	 * @param value Expects a `Float`
	 */
	setLoopEnd(value: number): this;
	/**
	 * Return the current volume.
	 */
	getVolume(): number;
	/**
	 * Set the volume.
	 * @param value Expects a `Float`
	 */
	setVolume(value: number): this;
}
declare class AudioAnalyser {
	/**
	 * Create a new {@link {@link AudioAnalyser} | AudioAnalyser}.
	 * @param audio
	 * @param fftSize See {@link https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize | AnalyserNode.fftSize }. Expects a `unsigned integer`. Default `2048`.
	 */
	constructor(audio: Audio$1<AudioNode>, fftSize?: number);
	/**
	 * An {@link https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode | AnalyserNode} used to analyze audio.
	 */
	analyser: AnalyserNode;
	/**
	 * A Uint8Array with size determined by {@link https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/frequencyBinCount | analyser.frequencyBinCount} used to hold analysis data.
	 */
	data: Uint8Array;
	/**
	 * Uses the Web Audio's {@link https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData | getByteFrequencyData} method
	 */
	getFrequencyData(): Uint8Array;
	/**
	 * Get the average of the frequencies returned by the {@link AudioAnalyser.getFrequencyData | getFrequencyData} method.
	 */
	getAverageFrequency(): number;
}
declare class PositionalAudio extends Audio$1<PannerNode> {
	/**
	 * Create a new instance of {@link PositionalAudio}
	 * @param listener (required) {@link AudioListener | AudioListener} instance.
	 */
	constructor(listener: AudioListener$1);
	/**
	 * The PositionalAudio's {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode | PannerNode}.
	 */
	panner: PannerNode;
	/**
	 * Returns the {@link PositionalAudio.panner | panner}.
	 */
	getOutput(): PannerNode;
	/**
	 * Returns the value of {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/refDistance | panner.refDistance}.
	 */
	getRefDistance(): number;
	/**
	 * Sets the value of {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/refDistance | panner.refDistance}.
	 * @param value Expects a `Float`
	 */
	setRefDistance(value: number): this;
	/**
	 * Returns the value of {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/rolloffFactor | panner.rolloffFactor}.
	 */
	getRolloffFactor(): number;
	/**
	 * Sets the value of {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/rolloffFactor | panner.rolloffFactor}.
	 * @param value Expects a `Float`
	 */
	setRolloffFactor(value: number): this;
	/**
	 * Returns the value of {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel | panner.distanceModel}.
	 */
	getDistanceModel(): string;
	/**
	 * Sets the value of {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel | panner.distanceModel}.
	 * @param value
	 */
	setDistanceModel(value: string): this;
	/**
	 * Returns the value of {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/maxDistance | panner.maxDistance}.
	 */
	getMaxDistance(): number;
	/**
	 * Sets the value of {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/maxDistance | panner.maxDistance}.
	 * @param value Expects a `Float`
	 */
	setMaxDistance(value: number): this;
	/**
	 * This method can be used in order to transform an omnidirectional sound into a {@link https://developer.mozilla.org/en-US/docs/Web/API/PannerNode | directional sound}.
	 * @param coneInnerAngle Expects a `Float`
	 * @param coneOuterAngle Expects a `Float`
	 * @param coneOuterGain Expects a `Float`
	 */
	setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): this;
}
declare class WebGLCubeRenderTarget extends WebGLRenderTarget {
	constructor(size?: number, options?: RenderTargetOptions);
	textures: CubeTexture[];
	get texture(): CubeTexture;
	set texture(value: CubeTexture);
	fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture): this;
	clear(renderer: WebGLRenderer, color: boolean, depth: boolean, stencil: boolean): void;
}
export interface CubeCameraRenderer {
	coordinateSystem: CoordinateSystem;
	getRenderTarget(): RenderTarget | null;
	getActiveCubeFace(): number;
	getActiveMipmapLevel(): number;
	xr: {
		enabled: boolean;
	};
	setRenderTarget(renderTarget: WebGLCubeRenderTarget | null, activeCubeFace?: number, activeMipmapLevel?: number): void;
	render(scene: Object3D, camera: Camera): void;
}
declare class CubeCamera extends Object3D {
	/**
	 * Constructs a {@link CubeCamera} that contains 6 {@link PerspectiveCamera | PerspectiveCameras} that render to a {@link THREE.WebGLCubeRenderTarget | WebGLCubeRenderTarget}.
	 * @param near The near clipping distance.
	 * @param far The far clipping distance.
	 * @param renderTarget The destination cube render target.
	 */
	constructor(near: number, far: number, renderTarget: WebGLCubeRenderTarget);
	/**
	 * @override
	 * @defaultValue `CubeCamera`
	 */
	override readonly type: string | "CubeCamera";
	/**
	 * The destination cube render target.
	 */
	renderTarget: WebGLCubeRenderTarget;
	coordinateSystem: CoordinateSystem;
	activeMipmapLevel: number;
	updateCoordinateSystem(): void;
	/**
	 * Call this to update the {@link CubeCamera.renderTarget | renderTarget}.
	 * @param renderer The current WebGL renderer
	 * @param scene The current scene
	 */
	update(renderer: CubeCameraRenderer, scene: Object3D): void;
}
export interface OrthographicCameraJSONObject extends Object3DJSONObject {
	zoom: number;
	left: number;
	right: number;
	top: number;
	bottom: number;
	near: number;
	far: number;
	view?: {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};
}
export interface OrthographicCameraJSON extends Object3DJSON {
	object: OrthographicCameraJSONObject;
}
declare class OrthographicCamera extends Camera {
	/**
	 * Creates a new {@link OrthographicCamera}.
	 * @remarks Together these define the camera's {@link https://en.wikipedia.org/wiki/Viewing_frustum | viewing frustum}.
	 * @param left Camera frustum left plane. Default `-1`.
	 * @param right Camera frustum right plane. Default `1`.
	 * @param top Camera frustum top plane. Default `1`.
	 * @param bottom Camera frustum bottom plane. Default `-1`.
	 * @param near Camera frustum near plane. Default `0.1`.
	 * @param far Camera frustum far plane. Default `2000`.
	 */
	constructor(left?: number, right?: number, top?: number, bottom?: number, near?: number, far?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link OrthographicCamera}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isOrthographicCamera: true;
	/**
	 * @override
	 * @defaultValue `OrthographicCamera`
	 */
	override readonly type: string | "OrthographicCamera";
	/**
	 * Gets or sets the zoom factor of the camera.
	 * @defaultValue `1`
	 */
	zoom: number;
	/**
	 * Set by {@link setViewOffset | .setViewOffset()}.
	 * @defaultValue `null`
	 */
	view: null | {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};
	/**
	 * Camera frustum left plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `-1`
	 */
	left: number;
	/**
	 * Camera frustum right plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	right: number;
	/**
	 * Camera frustum top plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	top: number;
	/**
	 * Camera frustum bottom plane.
	 * @remarks Expects a `Float`.
	 * @defaultValue `-1`
	 */
	bottom: number;
	/**
	 * Camera frustum near plane.`.
	 * @remarks The valid range is between `0` and the current value of the {@link far | .far} plane.
	 * @remarks Note that, unlike for the {@link THREE.PerspectiveCamera | PerspectiveCamera}, `0` is a valid value for an {@link THREE.OrthographicCamera | OrthographicCamera's} near plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `0.1`
	 */
	near: number;
	/**
	 * Camera frustum far plane.
	 * @remarks Must be greater than the current value of {@link near | .near} plane.
	 * @remarks Expects a `Float`
	 * @defaultValue `2000`
	 */
	far: number;
	/**
	 * Updates the camera projection matrix
	 * @remarks Must be called after any change of parameters.
	 */
	updateProjectionMatrix(): void;
	/**
	 * Sets an offset in a larger {@link https://en.wikipedia.org/wiki/Viewing_frustum | viewing frustum}
	 * @remarks
	 * This is useful for multi-window or multi-monitor/multi-machine setups
	 * For an example on how to use it see {@link PerspectiveCamera.setViewOffset | PerspectiveCamera}.
	 * @see {@link THREE.PerspectiveCamera.setViewOffset | PerspectiveCamera}.
	 * @param fullWidth Full width of multiview setup Expects a `Float`.
	 * @param fullHeight Full height of multiview setup Expects a `Float`.
	 * @param x Horizontal offset of subcamera Expects a `Float`.
	 * @param y Vertical offset of subcamera Expects a `Float`.
	 * @param width Width of subcamera Expects a `Float`.
	 * @param height Height of subcamera Expects a `Float`.
	 */
	setViewOffset(fullWidth: number, fullHeight: number, offsetX: number, offsetY: number, width: number, height: number): void;
	/**
	 * Removes any offset set by the {@link setViewOffset | .setViewOffset} method.
	 */
	clearViewOffset(): void;
	toJSON(meta?: JSONMeta): OrthographicCameraJSON;
}
declare class StereoCamera extends Camera {
	constructor();
	type: "StereoCamera";
	/**
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	aspect: number;
	/**
	 * @remarks Expects a `Float`
	 * @defaultValue `0.064`
	 */
	eyeSep: number;
	/**
	 * The Left camera.
	 * A {@link PerspectiveCamera } added to {@link THREE.PerspectiveCamera.layers | layer 1}
	 * @remarks Objects to be rendered by the **left** camera must also be added to this layer.
	 */
	cameraL: PerspectiveCamera;
	/**
	 * The Right camera.
	 * A {@link PerspectiveCamera } added to {@link THREE.PerspectiveCamera.layers | layer 2}
	 * @remarks Objects to be rendered by the **right** camera must also be added to this layer.
	 */
	cameraR: PerspectiveCamera;
	/**
	 * Update the stereo cameras based on the camera passed in.
	 * @param camera
	 */
	update(camera: PerspectiveCamera): void;
}
declare class Clock {
	/**
	 * Create a new instance of {@link THREE.Clock | Clock}
	 * @param autoStart - Whether to automatically start the clock when {@link getDelta | .getDelta()} is called for the first time. Default `true`
	 */
	constructor(autoStart?: boolean);
	/**
	 * If set, starts the clock automatically when {@link getDelta | .getDelta()} is called for the first time.
	 * @defaultValue `true`
	 */
	autoStart: boolean;
	/**
	 * Holds the time at which the clock's {@link start | .start()} method was last called.
	 * @defaultValue `0`
	 */
	startTime: number;
	/**
	 * Holds the time at which the clock's {@link start | .start()}, {@link getElapsedTime | .getElapsedTime()} or {@link getDelta | .getDelta()} methods were last called.
	 * @defaultValue `0`
	 */
	oldTime: number;
	/**
	 * Keeps track of the total time that the clock has been running.
	 * @defaultValue `0`
	 */
	elapsedTime: number;
	/**
	 * Whether the clock is running or not.
	 * @defaultValue `false`
	 */
	running: boolean;
	/**
	 * Starts clock.
	 * @remarks
	 * Also sets the {@link startTime | .startTime} and {@link oldTime | .oldTime} to the current time,
	 * sets {@link elapsedTime | .elapsedTime} to `0` and {@link running | .running} to `true`.
	 */
	start(): void;
	/**
	 * Stops clock and sets {@link oldTime | oldTime} to the current time.
	 */
	stop(): void;
	/**
	 * Get the seconds passed since the clock started and sets {@link oldTime | .oldTime} to the current time.
	 * @remarks
	 * If {@link autoStart | .autoStart} is `true` and the clock is not running, also starts the clock.
	 */
	getElapsedTime(): number;
	/**
	 * Get the seconds passed since the time {@link oldTime | .oldTime} was set and sets {@link oldTime | .oldTime} to the current time.
	 * @remarks
	 * If {@link autoStart | .autoStart} is `true` and the clock is not running, also starts the clock.
	 */
	getDelta(): number;
}
declare class InstancedBufferAttribute extends BufferAttribute {
	/**
	 * Create a new instance of {@link THREE.InstancedBufferAttribute | InstancedBufferAttribute}
	 * @param array
	 * @param itemSize
	 * @param normalized
	 * @param meshPerAttribute
	 */
	constructor(array: TypedArray, itemSize: number, normalized?: boolean, meshPerAttribute?: number);
	/**
	 * Defines how often a value of this buffer attribute should be repeated.
	 * A value of one means that each value of the instanced attribute is used for a single instance.
	 * A value of two means that each value is used for two consecutive instances (and so on).
	 * @defaultValue `1`
	 */
	meshPerAttribute: number;
	/**
	 * Read-only flag to check if a given object is of type {@link InstancedBufferAttribute}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isInstancedBufferAttribute: true;
}
declare class InstancedBufferGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link InstancedBufferGeometry}
	 */
	constructor();
	/**
	 * @defaultValue `InstancedBufferGeometry`
	 */
	type: string;
	/**
	 * Read-only flag to check if a given object is of type {@link InstancedBufferGeometry}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isInstancedBufferGeometry: true;
	/**
	 * @defaultValue `Infinity`
	 */
	instanceCount: number;
	/**
	 * Copies the given {@link InstancedBufferGeometry} to this instance.
	 * @param source
	 * @override
	 */
	copy(source: InstancedBufferGeometry): this;
}
declare class InstancedInterleavedBuffer extends InterleavedBuffer {
	/**
	 * Create a new instance of {@link InstancedInterleavedBuffer}
	 * @param array
	 * @param itemSize
	 * @param meshPerAttribute
	 */
	constructor(array: TypedArray, stride: number, meshPerAttribute?: number);
	/**
	 * @defaultValue `1`
	 */
	meshPerAttribute: number;
}
declare class RenderTarget3D extends RenderTarget {
	readonly isRenderTarget3D: true;
	constructor(width?: number, height?: number, depth?: number, options?: RenderTargetOptions);
}
declare class Timer {
	constructor();
	/**
	 * Connects the timer to the given document. Calling this method is not mandatory to use the timer but enables the
	 * usage of the Page Visibility API to avoid large time delta values.
	 */
	connect(document: Document): void;
	/**
	 * Disconnects the timer from the DOM and also disables the usage of the Page Visibility API.
	 */
	disconnect(): void;
	/**
	 * Returns the time delta in seconds.
	 */
	getDelta(): number;
	/**
	 * Returns the elapsed time in seconds.
	 */
	getElapsed(): number;
	/**
	 * Returns the time scale.
	 */
	getTimescale(): number;
	/**
	 * Sets a time scale that scales the time delta in {@link .update()}.
	 */
	setTimescale(timescale: number): this;
	/**
	 * Resets the time computation for the current simulation step.
	 */
	reset(): this;
	/**
	 * Can be used to free all internal resources. Usually called when the timer instance isn't required anymore.
	 */
	dispose(): this;
	/**
	 * Updates the internal state of the timer. This method should be called once per simulation step and before you
	 * perform queries against the timer (e.g. via {@link getDelta()}).
	 *
	 * @param timestamp The current time in milliseconds. Can be obtained from the {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame | requestAnimationFrame} callback argument. If not provided, the current time will be determined with {@link https://developer.mozilla.org/en-US/docs/Web/API/Performance/now | performance.now}.
	 */
	update(timestamp?: number): this;
}
declare abstract class Controls<TEventMap extends {}> extends EventDispatcher<TEventMap> {
	/**
	 * The 3D object that is managed by the controls.
	 */
	object: Object3D;
	/**
	 * The HTML element used for event listeners. If not provided via the constructor, {@link .connect} must be called
	 * after `domElement` has been set.
	 */
	domElement: HTMLElement | SVGElement | null;
	/**
	 * When set to `false`, the controls will not respond to user input. Default is `true`.
	 */
	enabled: boolean;
	/**
	 * Creates a new instance of {@link Controls}.
	 * @param object The object the controls should manage (usually the camera).
	 * @param domElement The HTML element used for event listeners. (optional)
	 */
	constructor(object: Object3D, domElement?: HTMLElement | SVGElement | null);
	/**
	 * Connects the controls to the DOM. This method has so called "side effects" since it adds the module's event
	 * listeners to the DOM.
	 */
	connect(element: HTMLElement | SVGElement): void;
	/**
	 * Disconnects the controls from the DOM.
	 */
	disconnect(): void;
	/**
	 * Call this method if you no longer want use to the controls. It frees all internal resources and removes all event
	 * listeners.
	 */
	dispose(): void;
	/**
	 * Controls should implement this method if they have to update their internal state per simulation step.
	 */
	update(delta: number): void;
}
declare class ShapePath {
	/**
	 * Creates a new {@link ShapePath}
	 * @remarks
	 * Unlike a {@link THREE.Path | Path}, no points are passed in as the {@link ShapePath} is designed to be generated after creation.
	 */
	constructor();
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `ShapePath`
	 */
	readonly type: "ShapePath";
	/**
	 * Array of {@link THREE.Path | Path's}s.
	 * @defaultValue `[]`
	 */
	subPaths: Path[];
	/**
	 * The current {@link THREE.Path | Path} that is being generated.
	 * @defaultValue `null`
	 */
	readonly currentPath: Path | null;
	/**
	 * {@link THREE.Color | Color} of the shape, by default set to white _(0xffffff)_.
	 * @defaultValue `new THREE.Color()`
	 */
	color: Color;
	/**
	 * Starts a new {@link THREE.Path | Path} and calls {@link THREE.Path.moveTo | Path.moveTo}( x, y ) on that {@link THREE.Path | Path}
	 * @remarks
	 * Also points {@link ShapePath.currentPath | currentPath} to that {@link THREE.Path | Path}.
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	moveTo(x: number, y: number): this;
	/**
	 * This creates a line from the {@link ShapePath.currentPath | currentPath}'s offset to X and Y and updates the offset to X and Y.
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	lineTo(x: number, y: number): this;
	/**
	 * This creates a quadratic curve from the {@link ShapePath.currentPath | currentPath}'s
	 * offset to _x_ and _y_ with _cpX_ and _cpY_ as control point and updates the {@link ShapePath.currentPath | currentPath}'s offset to _x_ and _y_.
	 * @param cpX Expects a `Float`
	 * @param cpY Expects a `Float`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): this;
	/**
	 * This creates a bezier curve from the {@link ShapePath.currentPath | currentPath}'s
	 * offset to _x_ and _y_ with _cp1X_, _cp1Y_ and _cp2X_, _cp2Y_ as control points and
	 * updates the {@link ShapePath.currentPath | currentPath}'s offset to _x_ and _y_.
	 * @param cp1X Expects a `Float`
	 * @param cp1Y Expects a `Float`
	 * @param cp2X Expects a `Float`
	 * @param cp2Y Expects a `Float`
	 * @param x Expects a `Float`
	 * @param y Expects a `Float`
	 */
	bezierCurveTo(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number): this;
	/**
	 * Connects a new {@link THREE.SplineCurve | SplineCurve} onto the {@link ShapePath.currentPath | currentPath}.
	 * @param points An array of {@link THREE.Vector2 | Vector2}s
	 */
	splineThru(pts: Vector2[]): this;
	/**
	 * Converts the {@link ShapePath.subPaths | subPaths} array into an array of Shapes
	 * @remarks
	 * By default solid shapes are defined clockwise (CW) and holes are defined counterclockwise (CCW)
	 * If isCCW is set to true, then those are flipped.
	 * @param isCCW Changes how solids and holes are generated
	 */
	toShapes(isCCW: boolean): Shape[];
}
declare class EllipseCurve extends Curve<Vector2> {
	/**
	 * This constructor creates a new {@link EllipseCurve}.
	 * @param aX The X center of the ellipse. Expects a `Float`. Default is `0`.
	 * @param aY The Y center of the ellipse. Expects a `Float`. Default is `0`.
	 * @param xRadius The radius of the ellipse in the x direction. Expects a `Float`. Default is `1`.
	 * @param yRadius The radius of the ellipse in the y direction. Expects a `Float`. Default is `1`.
	 * @param aStartAngle The start angle of the curve in radians starting from the positive X axis. Default is `0`.
	 * @param aEndAngle The end angle of the curve in radians starting from the positive X axis. Default is `2 x Math.PI`.
	 * @param aClockwise Whether the ellipse is drawn clockwise. Default is `false`.
	 * @param aRotation The rotation angle of the ellipse in radians, counterclockwise from the positive X axis. Default is `0`.
	 */
	constructor(aX?: number, aY?: number, xRadius?: number, yRadius?: number, aStartAngle?: number, aEndAngle?: number, aClockwise?: boolean, aRotation?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link EllipseCurve}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isEllipseCurve = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `EllipseCurve`
	 */
	override readonly type: string | "EllipseCurve";
	/**
	 * The X center of the ellipse.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	aX: number;
	/**
	 * The Y center of the ellipse.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	aY: number;
	/**
	 * The radius of the ellipse in the x direction.
	 * @defaultValue `1`
	 */
	xRadius: number;
	/**
	 * The radius of the ellipse in the y direction.
	 * @defaultValue `1`
	 */
	yRadius: number;
	/**
	 * The start angle of the curve in radians starting from the middle right side.
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	aStartAngle: number;
	/**
	 * The end angle of the curve in radians starting from the middle right side.
	 * @remarks Expects a `Float`
	 * @defaultValue `2 * Math.PI`
	 */
	aEndAngle: number;
	/**
	 * Whether the ellipse is drawn clockwise.
	 * @defaultValue `false``
	 */
	aClockwise: boolean;
	/**
	 * The rotation angle of the ellipse in radians, counterclockwise from the positive X axis (optional).
	 * @remarks Expects a `Float`
	 * @defaultValue `0`
	 */
	aRotation: number;
}
declare class ArcCurve extends EllipseCurve {
	/**
	 * This constructor creates a new {@link ArcCurve}.
	 * @param aX The X center of the ellipse. Expects a `Float`. Default is `0`.
	 * @param aY The Y center of the ellipse. Expects a `Float`. Default is `0`.
	 * @param xRadius The radius of the ellipse in the x direction. Expects a `Float`. Default is `1`.
	 * @param yRadius The radius of the ellipse in the y direction. Expects a `Float`. Default is `1`.
	 * @param aStartAngle The start angle of the curve in radians starting from the positive X axis. Default is `0`.
	 * @param aEndAngle The end angle of the curve in radians starting from the positive X axis. Default is `2 x Math.PI`.
	 * @param aClockwise Whether the ellipse is drawn clockwise. Default is `false`.
	 */
	constructor(aX?: number, aY?: number, aRadius?: number, aStartAngle?: number, aEndAngle?: number, aClockwise?: boolean);
	/**
	 * Read-only flag to check if a given object is of type {@link ArcCurve}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isArcCurve = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `ArcCurve`
	 */
	override readonly type: string | "ArcCurve";
}
export type CurveType = "centripetal" | "chordal" | "catmullrom";
declare class CatmullRomCurve3 extends Curve<Vector3> {
	/**
	 * This constructor creates a new {@link CatmullRomCurve3}.
	 * @param points An array of {@link THREE.Vector3 | Vector3} points
	 * @param closed Whether the curve is closed. Default `false`
	 * @param curveType Type of the curve. Default `centripetal`
	 * @param tension Tension of the curve. Expects a `Float`. Default `0.5`
	 */
	constructor(points?: Vector3[], closed?: boolean, curveType?: CurveType, tension?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link CatmullRomCurve3}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCatmullRomCurve3 = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `CatmullRomCurve3`
	 */
	override readonly type: string | "CatmullRomCurve3";
	/**
	 * The curve will loop back onto itself when this is true.
	 * @defaultValue `false`
	 */
	closed: boolean;
	/**
	 * The array of {@link THREE.Vector3 | Vector3} points that define the curve.
	 * @remarks It needs at least two entries.
	 * @defaultValue `[]`
	 */
	points: Vector3[];
	/**
	 * Possible values are `centripetal`, `chordal` and `catmullrom`.
	 * @defaultValue `centripetal`
	 */
	curveType: CurveType;
	/**
	 * When {@link .curveType} is `catmullrom`, defines catmullrom's tension.
	 * @remarks Expects a `Float`
	 */
	tension: number;
}
declare class CubicBezierCurve extends Curve<Vector2> {
	/**
	 * This constructor creates a new {@link CubicBezierCurve}.
	 * @param v0 The starting point. Default is `new THREE.Vector2()`.
	 * @param v1 The first control point. Default is `new THREE.Vector2()`.
	 * @param v2 The second control point. Default is `new THREE.Vector2()`.
	 * @param v3 The ending point. Default is `new THREE.Vector2()`.
	 */
	constructor(v0?: Vector2, v1?: Vector2, v2?: Vector2, v3?: Vector2);
	/**
	 * Read-only flag to check if a given object is of type {@link CubicBezierCurve}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCubicBezierCurve = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `CubicBezierCurve`
	 */
	override readonly type: string | "CubicBezierCurve";
	/**
	 * The starting point.
	 * @defaultValue `new THREE.Vector2()`
	 */
	v0: Vector2;
	/**
	 * The first control point.
	 * @defaultValue `new THREE.Vector2()`
	 */
	v1: Vector2;
	/**
	 * The second control point.
	 * @defaultValue `new THREE.Vector2()`
	 */
	v2: Vector2;
	/**
	 * The ending point.
	 * @defaultValue `new THREE.Vector2()`
	 */
	v3: Vector2;
}
declare class CubicBezierCurve3 extends Curve<Vector3> {
	/**
	 * This constructor creates a new {@link CubicBezierCurve3}.
	 * @param v0 The starting point. Default is `new THREE.Vector3()`.
	 * @param v1 The first control point. Default is `new THREE.Vector3()`.
	 * @param v2 The second control point. Default is `new THREE.Vector3()`.
	 * @param v3 The ending point. Default is `new THREE.Vector3()`.
	 */
	constructor(v0?: Vector3, v1?: Vector3, v2?: Vector3, v3?: Vector3);
	/**
	 * Read-only flag to check if a given object is of type {@link CubicBezierCurve3}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCubicBezierCurve3 = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `CubicBezierCurve3`
	 */
	override readonly type: string | "CubicBezierCurve3";
	/**
	 * The starting point.
	 * @defaultValue `new THREE.Vector3()`.
	 */
	v0: Vector3;
	/**
	 * The first control point.
	 * @defaultValue `new THREE.Vector3()`.
	 */
	v1: Vector3;
	/**
	 * The second control point.
	 * @defaultValue `new THREE.Vector3()`.
	 */
	v2: Vector3;
	/**
	 * The ending point.
	 * @defaultValue `new THREE.Vector3()`.
	 */
	v3: Vector3;
}
declare class LineCurve extends Curve<Vector2> {
	/**
	 * This constructor creates a new {@link LineCurve}.
	 * @param v1 The start point. Default is `new THREE.Vector2()`.
	 * @param v2 The end point. Default is `new THREE.Vector2()`.
	 */
	constructor(v1?: Vector2, v2?: Vector2);
	/**
	 * Read-only flag to check if a given object is of type {@link LineCurve}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLineCurve = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `LineCurve`
	 */
	override readonly type: string | "LineCurve";
	/**
	 * The start point.
	 * @defaultValue `new THREE.Vector2()`
	 */
	v1: Vector2;
	/**
	 * The end point
	 * @defaultValue `new THREE.Vector2()`
	 */
	v2: Vector2;
}
declare class LineCurve3 extends Curve<Vector3> {
	/**
	 * This constructor creates a new {@link LineCurve3}.
	 * @param v1 The start point. Default is `new THREE.Vector3()`.
	 * @param v2 The end point. Default is `new THREE.Vector3()`.
	 */
	constructor(v1?: Vector3, v2?: Vector3);
	/**
	 * Read-only flag to check if a given object is of type {@link LineCurve3}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLineCurve3 = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `LineCurve3`
	 */
	override readonly type: string | "LineCurve3";
	/**
	 * The start point.
	 * @defaultValue `new THREE.Vector3()`.
	 */
	v1: Vector3;
	/**
	 * The end point.
	 * @defaultValue `new THREE.Vector3()`.
	 */
	v2: Vector3;
}
declare class QuadraticBezierCurve extends Curve<Vector2> {
	/**
	 * This constructor creates a new {@link QuadraticBezierCurve}.
	 * @param v0 The start point. Default is `new THREE.Vector2()`.
	 * @param v1 The control point. Default is `new THREE.Vector2()`.
	 * @param v2 The end point. Default is `new THREE.Vector2()`.
	 */
	constructor(v0?: Vector2, v1?: Vector2, v2?: Vector2);
	/**
	 * Read-only flag to check if a given object is of type {@link LineCurve3}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isQuadraticBezierCurve = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `QuadraticBezierCurve`
	 */
	override readonly type: string | "QuadraticBezierCurve";
	/**
	 * The start point.
	 * @defaultValue `new THREE.Vector2()`
	 */
	v0: Vector2;
	/**
	 * The control point.
	 * @defaultValue `new THREE.Vector2()`
	 */
	v1: Vector2;
	/**
	 * The end point.
	 * @defaultValue `new THREE.Vector2()`
	 */
	v2: Vector2;
}
declare class QuadraticBezierCurve3 extends Curve<Vector3> {
	/**
	 * This constructor creates a new {@link QuadraticBezierCurve}.
	 * @param v0 The start point. Default is `new THREE.Vector3()`.
	 * @param v1 The control point. Default is `new THREE.Vector3()`.
	 * @param v2 The end point. Default is `new THREE.Vector3()`.
	 */
	constructor(v0?: Vector3, v1?: Vector3, v2?: Vector3);
	/**
	 * Read-only flag to check if a given object is of type {@link QuadraticBezierCurve3}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isQuadraticBezierCurve3 = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `QuadraticBezierCurve3`
	 */
	override readonly type: string | "QuadraticBezierCurve3";
	/**
	 * The start point.
	 * @defaultValue `new THREE.Vector3()`
	 */
	v0: Vector3;
	/**
	 * The control point.
	 * @defaultValue `new THREE.Vector3()`
	 */
	v1: Vector3;
	/**
	 * The end point.
	 * @defaultValue `new THREE.Vector3()`
	 */
	v2: Vector3;
}
declare class SplineCurve extends Curve<Vector2> {
	/**
	 * This constructor creates a new {@link SplineCurve}.
	 * @param points An array of {@link THREE.Vector2 | Vector2} points that define the curve. Default `[]`
	 */
	constructor(points?: Vector2[]);
	/**
	 * Read-only flag to check if a given object is of type {@link SplineCurve}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSplineCurve = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `SplineCurve`
	 */
	override readonly type: string | "SplineCurve";
	/**
	 * The array of {@link THREE.Vector2 | Vector2} points that define the curve.
	 * @defaultValue `[]`
	 */
	points: Vector2[];
}
declare class DataUtils {
	static toHalfFloat(val: number): number;
	static fromHalfFloat(val: number): number;
}
declare class ImageUtils {
	/**
	 * Returns a data URI containing a representation of the given image.
	 * @param image The image object.
	 */
	static getDataURL(image: HTMLImageElement | HTMLCanvasElement | CanvasImageSource | ImageBitmap | ImageData, type?: string): string;
	/**
	 * Converts the given sRGB image data to linear color space.
	 * @param image
	 */
	static sRGBToLinear(image: HTMLImageElement | HTMLCanvasElement | ImageBitmap): HTMLCanvasElement;
	/**
	 * Converts the given sRGB image data to linear color space.
	 * @param image
	 */
	static sRGBToLinear(image: ImageData): {
		data: ImageData["data"];
		width: ImageData["width"];
		height: ImageData["height"];
	};
}
declare class ShapeUtils {
	/**
	 * Calculate area of a ( 2D ) contour polygon.
	 */
	static area(contour: readonly Vector2Like[]): number;
	/**
	 * Note that this is a linear function so it is necessary to calculate separately for x, y components of a polygon.
	 * @remarks Used internally by {@link THREE.Path | Path}, {@link THREE.ExtrudeGeometry | ExtrudeGeometry} and {@link THREE.ShapeGeometry | ShapeGeometry}.
	 */
	static isClockWise(pts: readonly Vector2Like[]): boolean;
	/**
	 * Used internally by {@link THREE.ExtrudeGeometry | ExtrudeGeometry} and {@link THREE.ShapeGeometry | ShapeGeometry} to calculate faces in shapes with holes.
	 */
	static triangulateShape(contour: Vector2Like[], holes: Vector2Like[][]): number[][];
}
declare function contain(texture: Texture, aspect: number): Texture;
declare function cover(texture: Texture, aspect: number): Texture;
declare function fill(texture: Texture): Texture;
declare function getByteLength(width: number, height: number, format: PixelFormat | CompressedPixelFormat, type: TextureDataType): number;
declare const TextureUtils: {
	contain: typeof contain;
	cover: typeof cover;
	fill: typeof fill;
	getByteLength: typeof getByteLength;
};
declare class BoxGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link BoxGeometry}
	 * @param width Width; that is, the length of the edges parallel to the X axis. Optional; Expects a `Float`. Default `1`
	 * @param height Height; that is, the length of the edges parallel to the Y axis. Optional; Expects a `Float`. Default `1`
	 * @param depth Depth; that is, the length of the edges parallel to the Z axis. Optional; Expects a `Float`. Default `1`
	 * @param widthSegments Number of segmented rectangular faces along the width of the sides. Optional; Expects a `Integer`. Default `1`
	 * @param heightSegments Number of segmented rectangular faces along the height of the sides. Optional; Expects a `Integer`. Default `1`
	 * @param depthSegments Number of segmented rectangular faces along the depth of the sides. Optional; Expects a `Integer`. Default `1`
	 */
	constructor(width?: number, height?: number, depth?: number, widthSegments?: number, heightSegments?: number, depthSegments?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `BoxGeometry`
	 */
	override readonly type: string | "BoxGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly width: number;
		readonly height: number;
		readonly depth: number;
		readonly widthSegments: number;
		readonly heightSegments: number;
		readonly depthSegments: number;
	};
	/** @internal */
	static fromJSON(data: {}): BoxGeometry;
}
declare class CapsuleGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link CapsuleGeometry}
	 * @param radius Radius of the capsule. Expects a `Float`. Default `1`
	 * @param height Height of the middle section. Expects a `Float`. Default `1`
	 * @param capSegments Number of curve segments used to build the caps. Expects a `Integer`. Default `4`
	 * @param radialSegments Number of segmented faces around the circumference of the capsule. Expects a `Integer`. Default `8`
	 * @param heightSegments Number of rows of faces along the height of the capsule. Optional; defaults to `1`.
	 */
	constructor(radius?: number, height?: number, capSegments?: number, radialSegments?: number, heightSegments?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `CapsuleGeometry`
	 */
	override readonly type: string | "CapsuleGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly radius: number;
		readonly height: number;
		readonly capSegments: number;
		readonly radialSegments: number;
		readonly heightSegments: number;
	};
	/** @internal */
	static fromJSON(data: {}): CapsuleGeometry;
}
declare class CircleGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link CircleGeometry}
	 * @param radius Radius of the circle. Expects a `Float`. Default `1`
	 * @param segments Number of segments (triangles). Expects a `Integer`. Minimum `3`. Default `32`
	 * @param thetaStart Start angle for first segment. Expects a `Float`. Default `0`, _(three o'clock position)_.
	 * @param thetaLength The central angle, often called theta, of the circular sector. Expects a `Float`. Default `Math.PI * 2`, _which makes for a complete circle_.
	 */
	constructor(radius?: number, segments?: number, thetaStart?: number, thetaLength?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `CircleGeometry`
	 */
	override readonly type: string | "CircleGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly radius: number;
		readonly segments: number;
		readonly thetaStart: number;
		readonly thetaLength: number;
	};
	/** @internal */
	static fromJSON(data: {}): CircleGeometry;
}
declare class CylinderGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link CylinderGeometry}
	 * @param radiusTop Radius of the cylinder at the top. Default `1`
	 * @param radiusBottom Radius of the cylinder at the bottom. Default `1`
	 * @param height Height of the cylinder. Default `1`
	 * @param radialSegments Number of segmented faces around the circumference of the cylinder. Default `32`
	 * @param heightSegments Number of rows of faces along the height of the cylinder. Expects a `Integer`. Default `1`
	 * @param openEnded A Boolean indicating whether the ends of the cylinder are open or capped. Default `false`, _meaning capped_.
	 * @param thetaStart Start angle for first segment. Default `0`, _(three o'clock position)_.
	 * @param thetaLength The central angle, often called theta, of the circular sector. Default `Math.PI * 2`, _which makes for a complete cylinder.
	 */
	constructor(radiusTop?: number, radiusBottom?: number, height?: number, radialSegments?: number, heightSegments?: number, openEnded?: boolean, thetaStart?: number, thetaLength?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `CylinderGeometry`
	 */
	override readonly type: string | "CylinderGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly radiusTop: number;
		readonly radiusBottom: number;
		readonly height: number;
		readonly radialSegments: number;
		readonly heightSegments: number;
		readonly openEnded: boolean;
		readonly thetaStart: number;
		readonly thetaLength: number;
	};
	/** @internal */
	static fromJSON(data: any): CylinderGeometry;
}
declare class ConeGeometry extends CylinderGeometry {
	/**
	 * Create a new instance of {@link ConeGeometry}
	 * @param radius Radius of the cone base. Expects a `Float`. Default `1`
	 * @param height Height of the cone. Expects a `Float`. Default `1`
	 * @param radialSegments Number of segmented faces around the circumference of the cone. Expects a `Integer`. Default `32`
	 * @param heightSegments Number of rows of faces along the height of the cone. Expects a `Integer`. Default `1`
	 * @param openEnded A Boolean indicating whether the base of the cone is open or capped. Default `false`, _meaning capped_.
	 * @param thetaStart Start angle for first segment. Expects a `Float`. Default `0`, _(three o'clock position)_.
	 * @param thetaLength The central angle, often called theta, of the circular sector. Expects a `Float`. Default `Math.PI * 2`, _which makes for a complete cone_.
	 */
	constructor(radius?: number, height?: number, radialSegments?: number, heightSegments?: number, openEnded?: boolean, thetaStart?: number, thetaLength?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `ConeGeometry`
	 */
	override readonly type: string | "ConeGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks {@link radiusTop} and {@link radiusBottom} are from base {@link THREE.CylinderGeometry} class.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	override readonly parameters: {
		readonly radius: number;
		readonly radiusTop: number;
		readonly radiusBottom: number;
		readonly height: number;
		readonly radialSegments: number;
		readonly heightSegments: number;
		readonly openEnded: boolean;
		readonly thetaStart: number;
		readonly thetaLength: number;
	};
	/** @internal */
	static fromJSON(data: {}): ConeGeometry;
}
declare class PolyhedronGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link PolyhedronGeometry}
	 * @param vertices Array of points of the form [1,1,1, -1,-1,-1, ... ]. Default `[]`.
	 * @param indices Array of indices that make up the faces of the form [0,1,2, 2,3,0, ... ]. Default `[]`.
	 * @param radius [page:The radius of the final shape Expects a `Float`. Default `1`
	 * @param detail [page:How many levels to subdivide the geometry. The more detail, the smoother the shape. Expects a `Integer`. Default `0`
	 */
	constructor(vertices?: number[], indices?: number[], radius?: number, detail?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `PolyhedronGeometry`
	 */
	override readonly type: string | "PolyhedronGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly vertices: number[];
		readonly indices: number[];
		readonly radius: number;
		readonly detail: number;
	};
	/** @internal */
	static fromJSON(data: {}): PolyhedronGeometry;
}
declare class DodecahedronGeometry extends PolyhedronGeometry {
	/**
	 * Create a new instance of {@link DodecahedronGeometry}
	 * @param radius Radius of the dodecahedron. Expects a `Float`. Default `1`
	 * @param detail Setting this to a value greater than 0 adds vertices making it no longer a dodecahedron. Expects a `Integer`. Default `0`
	 */
	constructor(radius?: number, detail?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `DodecahedronGeometry`
	 */
	override readonly type: string | "DodecahedronGeometry";
	/** @internal */
	static fromJSON(data: {}): DodecahedronGeometry;
}
declare class EdgesGeometry<TBufferGeometry extends BufferGeometry = BufferGeometry> extends BufferGeometry {
	/**
	 * Create a new instance of {@link EdgesGeometry}
	 * @param geometry Any geometry object. Default `null`.
	 * @param thresholdAngle An edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. Expects a `Integer`. Default `1` _degree_.
	 */
	constructor(geometry?: TBufferGeometry | null, thresholdAngle?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `EdgesGeometry`
	 */
	override readonly type: string | "EdgesGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly geometry: TBufferGeometry | null;
		readonly thresholdAngle: number;
	};
}
export interface ExtrudeGeometryOptions {
	/**
	 * Number of points on the curves.
	 * Expects a `Integer`.
	 * @defaultValue `12`
	 */
	curveSegments?: number | undefined;
	/**
	 * Number of points used for subdividing segments along the depth of the extruded spline.
	 * @defaultValue `1`
	 */
	steps?: number | undefined;
	/**
	 * Depth to extrude the shape.
	 * @defaultValue `1`
	 */
	depth?: number | undefined;
	/**
	 * Turn on bevel. Applying beveling to the shape.
	 * @defaultValue `true`
	 */
	bevelEnabled?: boolean | undefined;
	/**
	 * How deep into the original shape the bevel goes.
	 * Expects a `Float`.
	 * @defaultValue `0.2`
	 */
	bevelThickness?: number | undefined;
	/**
	 * Distance from the shape outline that the bevel extends
	 * Expects a `Float`.
	 * @defaultValue `bevelThickness - 0.1`
	 */
	bevelSize?: number | undefined;
	/**
	 * Distance from the shape outline that the bevel starts.
	 * Expects a `Float`.
	 * @defaultValue `0`
	 */
	bevelOffset?: number | undefined;
	/**
	 * Number of bevel layers/segments.
	 * Expects a `Integer`.
	 * @defaultValue `3`
	 */
	bevelSegments?: number | undefined;
	/**
	 * A 3D spline path along which the shape should be extruded.
	 * @remarks Bevels not supported for path extrusion.
	 */
	extrudePath?: Curve<Vector3> | undefined;
	/**
	 * A object that provides UV generator functions.
	 */
	UVGenerator?: UVGenerator | undefined;
}
export interface UVGenerator {
	generateTopUV(geometry: ExtrudeGeometry, vertices: number[], indexA: number, indexB: number, indexC: number): Vector2[];
	generateSideWallUV(geometry: ExtrudeGeometry, vertices: number[], indexA: number, indexB: number, indexC: number, indexD: number): Vector2[];
}
declare class ExtrudeGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link ExtrudeGeometry}
	 * @param shapes Shape or an array of shapes. Default `new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)])`.
	 * @param options Object that can contain the following parameters. @see {@link ExtrudeGeometryOptions} for defaults.
	 */
	constructor(shapes?: Shape | Shape[], options?: ExtrudeGeometryOptions);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `ExtrudeGeometry`
	 */
	override readonly type: string | "ExtrudeGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly shapes: Shape | Shape[];
		readonly options: ExtrudeGeometryOptions;
	};
	addShape(shape: Shape): void;
	/** @internal */
	static fromJSON(data: {}, shapes: unknown): ExtrudeGeometry;
}
declare class IcosahedronGeometry extends PolyhedronGeometry {
	/**
	 * Create a new instance of {@link IcosahedronGeometry}
	 * @param radius Expects a `Float`. Default `1`
	 * @param detail Setting this to a value greater than 0 adds more vertices making it no longer an icosahedron.
	 *               When detail is greater than 1, it's effectively a sphere. Expects a `Integer`. Default `0`
	 */
	constructor(radius?: number, detail?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `IcosahedronGeometry`
	 */
	override readonly type: string | "IcosahedronGeometry";
	/** @internal */
	static fromJSON(data: {}): IcosahedronGeometry;
}
declare class LatheGeometry extends BufferGeometry {
	/**
	 * This creates a {@link LatheGeometry} based on the parameters.
	 * @param points Array of Vector2s. The x-coordinate of each point must be greater than zero.
	 *               Default `[new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)]` _which creates a simple diamond shape_.
	 * @param segments The number of circumference segments to generate. Expects a `Integer`. Default `12`.
	 * @param phiStart The starting angle in radians. Expects a `Float`. Default `0`.
	 * @param phiLength The radian (0 to 2*PI) range of the lathed section 2*PI is a closed lathe, less than 2PI is a portion. Expects a `Float`. Default `Math.PI * 2`.
	 */
	constructor(points?: Vector2[], segments?: number, phiStart?: number, phiLength?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `LatheGeometry`
	 */
	override readonly type: string | "LatheGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly points: Vector2[];
		readonly segments: number;
		readonly phiStart: number;
		readonly phiLength: number;
	};
	/** @internal */
	static fromJSON(data: {}): LatheGeometry;
}
declare class OctahedronGeometry extends PolyhedronGeometry {
	/**
	 * Create a new instance of {@link OctahedronGeometry}
	 * @param radius Radius of the octahedron. Expects a `Float`. Default `1`
	 * @param detail Setting this to a value greater than zero add vertices making it no longer an octahedron. Expects a `Integer`. Default `0`
	 */
	constructor(radius?: number, detail?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `OctahedronGeometry`
	 */
	override readonly type: string | "OctahedronGeometry";
	/** @internal */
	static fromJSON(data: {}): OctahedronGeometry;
}
declare class PlaneGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link PlaneGeometry}
	 * @param width Width along the X axis. Expects a `Float`. Default `1`
	 * @param height Height along the Y axis. Expects a `Float`. Default `1`
	 * @param widthSegments Number of segmented faces along the width of the sides. Expects a `Integer`. Default `1`
	 * @param heightSegments Number of segmented faces along the height of the sides. Expects a `Integer`. Default `1`
	 */
	constructor(width?: number, height?: number, widthSegments?: number, heightSegments?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `PlaneGeometry`
	 */
	override readonly type: string | "PlaneGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly width: number;
		readonly height: number;
		readonly widthSegments: number;
		readonly heightSegments: number;
	};
	/** @internal */
	static fromJSON(data: {}): PlaneGeometry;
}
declare class RingGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link RingGeometry}
	 * @param innerRadius Expects a `Float`. Default `0.5`.
	 * @param outerRadius Expects a `Float`. Default `1`.
	 * @param thetaSegments Number of segments. A higher number means the ring will be more round. Minimum is 3. Expects a `Integer`. Default `32`.
	 * @param phiSegments Number of segments per ring segment. Minimum is `1`. Expects a `Integer`. Default `1`.
	 * @param thetaStart Starting angle. Expects a `Float`. Default `0`.
	 * @param thetaLength Central angle. Expects a `Float`. Default `Math.PI * 2`.
	 */
	constructor(innerRadius?: number, outerRadius?: number, thetaSegments?: number, phiSegments?: number, thetaStart?: number, thetaLength?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `RingGeometry`
	 */
	override readonly type: string | "RingGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly innerRadius: number;
		readonly outerRadius: number;
		readonly thetaSegments: number;
		readonly phiSegments: number;
		readonly thetaStart: number;
		readonly thetaLength: number;
	};
	/** @internal */
	static fromJSON(data: {}): RingGeometry;
}
declare class ShapeGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link ShapeGeometry}
	 * @param shapes Array of shapes or a single {@link THREE.Shape | Shape}. Default `new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)])`, _a single triangle shape_.
	 * @param curveSegments Number of segments per shape. Expects a `Integer`. Default `12`
	 */
	constructor(shapes?: Shape | Shape[], curveSegments?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `ShapeGeometry`
	 */
	override readonly type: string | "ShapeGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly shapes: Shape | Shape[];
		readonly curveSegments: number;
	};
	/** @internal */
	static fromJSON(data: {}): ShapeGeometry;
}
declare class SphereGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link SphereGeometry}
	 * @remarks
	 * The geometry is created by sweeping and calculating vertexes
	 * around the **Y** axis (horizontal sweep) and the **Z** axis (vertical sweep)
	 * Thus, incomplete spheres (akin to `'sphere slices'`) can be created
	 * through the use of different values of {@link phiStart}, {@link phiLength}, {@link thetaStart} and {@link thetaLength},
	 * in order to define the points in which we start (or end) calculating those vertices.
	 * @param radius Sphere radius. Expects a `Float`. Default `1`
	 * @param widthSegments Number of horizontal segments. Minimum value is 3, and the Expects a `Integer`. Default `32`
	 * @param heightSegments Number of vertical segments. Minimum value is 2, and the Expects a `Integer`. Default `16`
	 * @param phiStart Specify horizontal starting angle. Expects a `Float`. Default `0`
	 * @param phiLength Specify horizontal sweep angle size. Expects a `Float`. Default `Math.PI * 2`
	 * @param thetaStart Specify vertical starting angle. Expects a `Float`. Default `0`
	 * @param thetaLength Specify vertical sweep angle size. Expects a `Float`. Default `Math.PI`
	 */
	constructor(radius?: number, widthSegments?: number, heightSegments?: number, phiStart?: number, phiLength?: number, thetaStart?: number, thetaLength?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `SphereGeometry`
	 */
	override readonly type: string | "SphereGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly radius: number;
		readonly widthSegments: number;
		readonly heightSegments: number;
		readonly phiStart: number;
		readonly phiLength: number;
		readonly thetaStart: number;
		readonly thetaLength: number;
	};
	/** @internal */
	static fromJSON(data: {}): SphereGeometry;
}
declare class TetrahedronGeometry extends PolyhedronGeometry {
	/**
	 * Create a new instance of {@link TetrahedronGeometry}
	 * @param radius Radius of the tetrahedron. Expects a `Float`. Default `1`
	 * @param detail Setting this to a value greater than 0 adds vertices making it no longer a tetrahedron. Expects a `Integer`. Default `0`
	 */
	constructor(radius?: number, detail?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `TetrahedronGeometry`
	 */
	override readonly type: string | "TetrahedronGeometry";
	/** @internal */
	static fromJSON(data: {}): TetrahedronGeometry;
}
declare class TorusGeometry extends BufferGeometry {
	/**
	 * @param radius Radius of the torus, from the center of the torus to the center of the tube. Default `1`.
	 * @param tube Radius of the tube. Must be smaller than `radius`. Default is `0.4`.
	 * @param radialSegments Default is `12`.
	 * @param tubularSegments Default is `48`.
	 * @param arc Central angle. Default is Math.PI * 2.
	 */
	constructor(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, arc?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `TorusGeometry`
	 */
	override readonly type: string | "TorusGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly radius: number;
		readonly tube: number;
		readonly radialSegments: number;
		readonly tubularSegments: number;
		readonly arc: number;
	};
	/** @internal */
	static fromJSON(data: any): TorusGeometry;
}
declare class TorusKnotGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link TorusKnotGeometry}
	 * @param radius Radius of the torus.. Default `1`.
	 * @param tube Expects a `Float`. Default `0.4`.
	 * @param tubularSegments Expects a `Integer`. Default `64`.
	 * @param radialSegments Expects a `Integer`. Default `8`.
	 * @param p This value determines, how many times the geometry winds around its axis of rotational symmetry. Expects a `Integer`. Default `2`.
	 * @param q This value determines, how many times the geometry winds around a circle in the interior of the torus. Expects a `Integer`. Default `3`.
	 */
	constructor(radius?: number, tube?: number, tubularSegments?: number, radialSegments?: number, p?: number, q?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `TorusKnotGeometry`
	 */
	override readonly type: string | "TorusKnotGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly radius: number;
		readonly tube: number;
		readonly tubularSegments: number;
		readonly radialSegments: number;
		readonly p: number;
		readonly q: number;
	};
	/** @internal */
	static fromJSON(data: {}): TorusKnotGeometry;
}
declare class TubeGeometry extends BufferGeometry {
	/**
	 * Create a new instance of {@link TubeGeometry}
	 * @param path A 3D path that inherits from the {@link THREE.Curve | Curve} base class.
	 *             Default {@link THREE.QuadraticBezierCurve3 | new THREE.QuadraticBezierCurve3(new Vector3(-1, -1, 0 ), new Vector3(-1, 1, 0), new Vector3(1, 1, 0))}.
	 * @param tubularSegments The number of segments that make up the tube. Expects a `Integer`. Default `64`.
	 * @param radius The radius of the tube. Expects a `Float`. Default `1`.
	 * @param radialSegments The number of segments that make up the cross-section. Expects a `Integer`. Default `8`.
	 * @param closed Is the tube open or closed. Default `false`.
	 */
	constructor(path?: Curve<Vector3>, tubularSegments?: number, radius?: number, radialSegments?: number, closed?: boolean);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `TubeGeometry`
	 */
	override readonly type: string | "TubeGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly path: Curve<Vector3>;
		readonly tubularSegments: number;
		readonly radius: number;
		readonly radialSegments: number;
		readonly closed: boolean;
	};
	/**
	 * An array of {@link THREE.Vector3 | Vector3} tangents
	 */
	tangents: Vector3[];
	/**
	 * An array of {@link THREE.Vector3 | Vector3} normals
	 */
	normals: Vector3[];
	/**
	 * An array of {@link THREE.Vector3 | Vector3} binormals
	 */
	binormals: Vector3[];
	/** @internal */
	static fromJSON(data: {}): TubeGeometry;
}
declare class WireframeGeometry<TBufferGeometry extends BufferGeometry = BufferGeometry> extends BufferGeometry {
	/**
	 * Create a new instance of {@link WireframeGeometry}
	 * @param geometry Any geometry object. Default `null`.
	 */
	constructor(geometry?: TBufferGeometry);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `WireframeGeometry`
	 */
	override readonly type: string | "WireframeGeometry";
	/**
	 * An object with a property for each of the constructor parameters.
	 * @remarks Any modification after instantiation does not change the geometry.
	 */
	readonly parameters: {
		readonly geometry: TBufferGeometry;
	};
}
declare class Line<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[], TEventMap extends Object3DEventMap = Object3DEventMap> extends Object3D<TEventMap> {
	/**
	 * Create a new instance of {@link Line}
	 * @param geometry Vertices representing the {@link Line} segment(s). Default {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material Material for the line. Default {@link THREE.LineBasicMaterial | `new THREE.LineBasicMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link Line}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLine: true;
	/**
	 * @override
	 * @defaultValue `Line`
	 */
	override readonly type: string | "Line";
	/**
	 * Vertices representing the {@link Line} segment(s).
	 */
	geometry: TGeometry;
	/**
	 * Material for the line.
	 */
	material: TMaterial;
	/**
	 * An array of weights typically from `0-1` that specify how much of the morph is applied.
	 * @defaultValue `undefined`, but reset to a blank array by {@link updateMorphTargets | .updateMorphTargets()}.
	 */
	morphTargetInfluences?: number[] | undefined;
	/**
	 * A dictionary of morphTargets based on the `morphTarget.name` property.
	 * @defaultValue `undefined`, but reset to a blank array by {@link updateMorphTargets | .updateMorphTargets()}.
	 */
	morphTargetDictionary?: {
		[key: string]: number;
	} | undefined;
	/**
	 * Computes an array of distance values which are necessary for {@link THREE.LineDashedMaterial | LineDashedMaterial}
	 * @remarks
	 * For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line.
	 */
	computeLineDistances(): this;
	/**
	 * Updates the morphTargets to have no influence on the object
	 * @remarks
	 * Resets the {@link morphTargetInfluences | .morphTargetInfluences} and {@link morphTargetDictionary | .morphTargetDictionary} properties.
	 */
	updateMorphTargets(): void;
}
declare class ArrowHelper extends Object3D {
	/**
	 * Create a new instance of {@link ArrowHelper}
	 * @param dir Direction from origin. Must be a unit vector. Default `new THREE.Vector3(0, 0, 1)`
	 * @param origin Point at which the arrow starts. Default `new THREE.Vector3(0, 0, 0)`
	 * @param length Length of the arrow. Default `1`
	 * @param hex Hexadecimal value to define color. Default `0xffff00`
	 * @param headLength The length of the head of the arrow. Default `0.2 * length`
	 * @param headWidth The width of the head of the arrow. Default `0.2 * headLength`
	 */
	constructor(dir?: Vector3, origin?: Vector3, length?: number, color?: ColorRepresentation, headLength?: number, headWidth?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `ArrowHelper`
	 */
	override readonly type: string | "ArrowHelper";
	/**
	 * Contains the line part of the arrowHelper.
	 */
	line: Line;
	/**
	 * Contains the cone part of the arrowHelper.
	 */
	cone: Mesh;
	/**
	 * Sets the color of the arrowHelper.
	 * @param color The desired color.
	 */
	setColor(color: ColorRepresentation): void;
	/**
	 * @param dir The desired direction. Must be a unit vector.
	 */
	setDirection(dir: Vector3): void;
	/**
	 * Sets the length of the arrowhelper.
	 * @param length The desired length.
	 * @param headLength The length of the head of the arrow. Default `0.2 * length`
	 * @param headWidth The width of the head of the arrow. Default `0.2 * headLength`
	 */
	setLength(length: number, headLength?: number, headWidth?: number): void;
	/**
	 * Copy the given object into this object
	 * @remarks Note: event listeners and user-defined callbacks ({@link onAfterRender | .onAfterRender} and {@link onBeforeRender | .onBeforeRender}) are not copied.
	 * @param source
	 */
	override copy(source: this): this;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class LineSegments<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[], TEventMap extends Object3DEventMap = Object3DEventMap> extends Line<TGeometry, TMaterial, TEventMap> {
	/**
	 * Create a new instance of {@link LineSegments}
	 * @param geometry Pair(s) of vertices representing each line segment(s). Default {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material Material for the line. Default {@link THREE.LineBasicMaterial | `new THREE.LineBasicMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link LineSegments}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLineSegments: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `LineSegments`
	 */
	override readonly type: string | "LineSegments";
}
declare class AxesHelper extends LineSegments<BufferGeometry, LineBasicMaterial> {
	/**
	 * Create a new instance of {@link AxesHelper}
	 * @param size Size of the lines representing the axes. Default `1`
	 */
	constructor(size?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `AxesHelper`
	 */
	override readonly type: string | "AxesHelper";
	/**
	 * Sets the axes colors to {@link Color | xAxisColor}, {@link Color | yAxisColor}, {@link Color | zAxisColor}.
	 * @param xAxisColor
	 * @param yAxisColor
	 * @param zAxisColor
	 */
	setColors(xAxisColor: ColorRepresentation, yAxisColor: ColorRepresentation, zAxisColor: ColorRepresentation): this;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class Box3Helper extends LineSegments {
	/**
	 * Creates a new wireframe box that represents the passed Box3.
	 * @param box The Box3 to show.
	 * @param color The box's color. Default `0xffff00`
	 */
	constructor(box: Box3, color?: ColorRepresentation);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `Box3Helper`
	 */
	override readonly type: string | "Box3Helper";
	/**
	 * The Box3 being visualized.
	 */
	box: Box3;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class BoxHelper extends LineSegments<BufferGeometry, LineBasicMaterial> {
	/**
	 * Creates a new wireframe box that bounds the passed object
	 * @remarks
	 * Internally this uses {@link THREE.Box3.setFromObject | Box3.setFromObject} to calculate the dimensions
	 * Note that this includes any children.
	 * @param object The object3D to show the world-axis-aligned bounding box.
	 * @param color Hexadecimal value that defines the box's color. Default `0xffff00`
	 */
	constructor(object: Object3D, color?: ColorRepresentation);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `BoxHelper`
	 */
	override readonly type: string | "BoxHelper";
	/**
	 * Updates the helper's geometry to match the dimensions of the object, including any children
	 * @remarks
	 * See {@link THREE.Box3.setFromObject | Box3.setFromObject}.
	 */
	update(object?: Object3D): void;
	/**
	 * Updates the wireframe box for the passed object.
	 * @param object {@link THREE.Object3D | Object3D} to create the helper of.
	 */
	setFromObject(object: Object3D): this;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class CameraHelper extends LineSegments {
	/**
	 * This create a new {@link CameraHelper} for the specified camera.
	 * @param camera The camera to visualize.
	 */
	constructor(camera: Camera);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `CameraHelper`
	 */
	override readonly type: string | "CameraHelper";
	/**
	 * The camera being visualized.
	 */
	camera: Camera;
	/**
	 * This contains the points used to visualize the camera.
	 */
	pointMap: {
		[id: string]: number[];
	};
	/**
	 * Reference to the {@link THREE.Camera.matrixWorld | camera.matrixWorld}.
	 */
	matrix: Matrix4;
	/**
	 * Is set to `false`, as the helper is using the {@link THREE.Camera.matrixWorld | camera.matrixWorld}.
	 * @see {@link THREE.Object3D.matrixAutoUpdate | Object3D.matrixAutoUpdate}.
	 * @defaultValue `false`.
	 */
	override matrixAutoUpdate: boolean;
	/**
	 * Defines the colors of the helper.
	 * @param frustum
	 * @param cone
	 * @param up
	 * @param target
	 * @param cross
	 */
	setColors(frustum: Color, cone: Color, up: Color, target: Color, cross: Color): this;
	/**
	 * Updates the helper based on the projectionMatrix of the camera.
	 */
	update(): void;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class DirectionalLightShadow extends LightShadow<OrthographicCamera> {
	/**
	 * Create a new instance of {@link DirectionalLightShadow}
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link DirectionalLightShadow}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDirectionalLightShadow: true;
	/**
	 * The light's view of the world.
	 * @remarks This is used to generate a depth map of the scene; objects behind other objects from the light's perspective will be in shadow.
	 * @defaultValue is an {@link THREE.OrthographicCamera | OrthographicCamera} with
	 * {@link OrthographicCamera.left | left} and {@link OrthographicCamera.bottom | bottom} set to -5,
	 * {@link OrthographicCamera.right | right} and {@link OrthographicCamera.top | top} set to 5,
	 * the {@link OrthographicCamera.near | near} clipping plane at 0.5 and
	 * the {@link OrthographicCamera.far | far} clipping plane at 500.
	 */
	camera: OrthographicCamera;
}
export interface DirectionalLightJSON extends LightJSON {
	shadow: LightShadowJSON;
	target: string;
}
declare class DirectionalLight extends Light<DirectionalLightShadow> {
	/**
	 * Creates a new {@link DirectionalLight}.
	 * @param color Hexadecimal color of the light. Default `0xffffff` _(white)_.
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`
	 */
	constructor(color?: ColorRepresentation, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link DirectionalLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDirectionalLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `DirectionalLight`
	 */
	override readonly type: string | "DirectionalLight";
	/**
	 * Whether the object gets rendered into shadow map.
	 * @remarks
	 * If set to `true` light will cast dynamic shadows.
	 * **Warning**: This is expensive and requires tweaking to get shadows looking right.
	 * @see {@link THREE.DirectionalLightShadow | DirectionalLightShadow} for details.
	 * @defaultValue `false`
	 */
	override castShadow: boolean;
	/**
	 * This is set equal to {@link THREE.Object3D.DEFAULT_UP}, so that the light shines from the top down.
	 * @defaultValue {@link Object3D.DEFAULT_UP} _(0, 1, 0)_
	 */
	override readonly position: Vector3;
	/**
	 * A {@link THREE.DirectionalLightShadow | DirectionalLightShadow} used to calculate shadows for this light.
	 * @defaultValue `new THREE.DirectionalLightShadow()`
	 */
	shadow: DirectionalLightShadow;
	/**
	 * The {@link DirectionalLight} points from its {@link DirectionalLight.position | position} to target.position.
	 * @remarks **Note**: For the target's position to be changed to anything other than the default,
	 * it must be added to the {@link THREE.Scene | scene} using
	 * ```typescript
	 * Scene.add( light.target );
	 * ```
	 * This is so that the target's {@link THREE.Object3D.matrixWorld | matrixWorld} gets automatically updated each frame.
	 *
	 * It is also possible to set the target to be another object in the scene (anything with a {@link THREE.Object3D.position | position} property),
	 * like so:
	 * ```typescript
	 * const targetObject = new THREE.Object3D();
	 * scene.add(targetObject);
	 * light.target = targetObject;
	 * ```
	 * The {@link DirectionalLight} will now track the target object.
	 * @defaultValue `new THREE.Object3D()` at _(0, 0, 0)_
	 */
	target: Object3D;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
	toJSON(meta?: JSONMeta): DirectionalLightJSON;
}
declare class DirectionalLightHelper extends Object3D {
	/**
	 * Create a new instance of {@link DirectionalLightHelper}
	 * @param light The light to be visualized.
	 * @param size Dimensions of the plane. Default `1`
	 * @param color If this is not the set the helper will take the color of the light. Default `light.color`
	 */
	constructor(light: DirectionalLight, size?: number, color?: ColorRepresentation);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `DirectionalLightHelper`
	 */
	override readonly type: string | "DirectionalLightHelper";
	/**
	 * Contains the line mesh showing the location of the directional light.
	 */
	lightPlane: Line;
	/**
	 * Reference to the {@link THREE.DirectionalLight | directionalLight} being visualized.
	 */
	light: DirectionalLight;
	/**
	 * Reference to the {@link THREE.DirectionalLight.matrixWorld | light.matrixWorld}.
	 */
	matrix: Matrix4;
	/**
	 * Is set to `false`, as the helper is using the {@link THREE.DirectionalLight.matrixWorld | light.matrixWorld}.
	 * @see {@link THREE.Object3D.matrixAutoUpdate | Object3D.matrixAutoUpdate}.
	 * @defaultValue `false`.
	 */
	override matrixAutoUpdate: boolean;
	/**
	 * The color parameter passed in the constructor.
	 * @remarks If this is changed, the helper's color will update the next time {@link update} is called.
	 * @defaultValue `undefined`
	 */
	color: ColorRepresentation | undefined;
	targetLine: Line; // TODO: Double check if this need to be exposed or not.
	/**
	 * Updates the helper to match the position and direction of the {@link light | DirectionalLight} being visualized.
	 */
	update(): void;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class GridHelper extends LineSegments<BufferGeometry, LineBasicMaterial> {
	/**
	 * Creates a new {@link GridHelper} of size 'size' and divided into 'divisions' segments per side
	 * @remarks
	 * Colors are optional.
	 * @param size The size of the grid. Default `10`
	 * @param divisions The number of divisions across the grid. Default `10`
	 * @param colorCenterLine The color of the centerline. This can be a {@link THREE.Color | Color}, a hexadecimal value and an CSS-Color name. Default `0x444444`
	 * @param colorGrid The color of the lines of the grid. This can be a {@link THREE.Color | Color}, a hexadecimal value and an CSS-Color name. Default `0x888888`
	 */
	constructor(size?: number, divisions?: number, color1?: ColorRepresentation, color2?: ColorRepresentation);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `GridHelper`
	 */
	override readonly type: string | "GridHelper";
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
export interface HemisphereLightJSON extends LightJSON {
	groundColor: number;
}
declare class HemisphereLight extends Light<undefined> {
	/**
	 * Creates a new {@link HemisphereLight}.
	 * @param skyColor Hexadecimal color of the sky. Expects a `Integer`. Default `0xffffff` _(white)_.
	 * @param groundColor Hexadecimal color of the ground. Expects a `Integer`. Default `0xffffff` _(white)_.
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`.
	 */
	constructor(skyColor?: ColorRepresentation, groundColor?: ColorRepresentation, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link HemisphereLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isHemisphereLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `HemisphereLight`
	 */
	override readonly type: string | "HemisphereLight";
	/**
	 * This is set equal to {@link THREE.Object3D.DEFAULT_UP}, so that the light shines from the top down.
	 * @defaultValue {@link Object3D.DEFAULT_UP} _(0, 1, 0)_
	 */
	override readonly position: Vector3;
	/**
	 * The light's sky color, as passed in the constructor.
	 * @defaultValue `new THREE.Color()` set to white _(0xffffff)_.
	 */
	override color: Color;
	/**
	 * The light's ground color, as passed in the constructor.
	 * @defaultValue `new THREE.Color()` set to white _(0xffffff)_.
	 */
	groundColor: Color;
	toJSON(meta?: JSONMeta): HemisphereLightJSON;
}
declare class HemisphereLightHelper extends Object3D {
	/**
	 *  Create a new instance of {@link HemisphereLightHelper}
	 * @param light The light being visualized.
	 * @param size Thr sphere size
	 * @param color If this is not the set the helper will take the color of the light.
	 */
	constructor(light: HemisphereLight, size: number, color?: ColorRepresentation);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `HemisphereLightHelper`
	 */
	override readonly type: string | "HemisphereLightHelper";
	/**
	 * Reference to the HemisphereLight being visualized.
	 */
	light: HemisphereLight;
	/**
	 * Reference to the {@link THREE.HemisphereLight.matrixWorld | light.matrixWorld}.
	 */
	matrix: Matrix4;
	/**
	 * Is set to `false`, as the helper is using the {@link THREE.HemisphereLight.matrixWorld | light.matrixWorld}.
	 * @see {@link THREE.Object3D.matrixAutoUpdate | Object3D.matrixAutoUpdate}.
	 * @defaultValue `false`.
	 */
	override matrixAutoUpdate: boolean;
	material: MeshBasicMaterial; // TODO: Double check if this need to be exposed or not.
	/**
	 * The color parameter passed in the constructor.
	 * @remarks If this is changed, the helper's color will update the next time {@link update} is called.
	 * @defaultValue `undefined`
	 */
	color: ColorRepresentation | undefined;
	/**
	 * Updates the helper to match the position and direction of the {@link .light | HemisphereLight}.
	 */
	update(): void;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class PlaneHelper extends LineSegments {
	/**
	 * Creates a new wireframe representation of the passed plane.
	 * @param plane The plane to visualize.
	 * @param size Side length of plane helper. Expects a `Float`. Default `1`
	 * @param hex Color. Default `0xffff00`
	 */
	constructor(plane: Plane, size?: number, hex?: number);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `PlaneHelper`
	 */
	override readonly type: string | "PlaneHelper";
	/**
	 * The {@link Plane | plane} being visualized.
	 */
	plane: Plane;
	/**
	 * The side lengths of plane helper.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	size: number;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class PointLightShadow extends LightShadow<PerspectiveCamera> {
	/**
	 * Read-only flag to check if a given object is of type {@link PointLightShadow}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isPointLightShadow: true;
}
export interface PointLightJSON extends LightJSON {
	distance: number;
	decay: number;
	shadow: LightShadowJSON;
}
declare class PointLight extends Light<PointLightShadow> {
	/**
	 * Creates a new PointLight.
	 * @param color Hexadecimal color of the light. Default is 0xffffff (white). Expects an `Integer`
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`
	 * @param distance Maximum range of the light. Default is 0 (no limit).
	 * @param decay The amount the light dims along the distance of the light. Expects a `Float`. Default `2`
	 */
	constructor(color?: ColorRepresentation, intensity?: number, distance?: number, decay?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link PointLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isPointLight: true;
	/**
	 * @default 'PointLight'
	 */
	type: string;
	/**
	 * The light's intensity.
	 *
	 * When **{@link WebGLRenderer.useLegacyLights | legacy lighting mode} is disabled** — intensity is the luminous intensity of the light measured in candela (cd).
	 * @remarks Changing the intensity will also change the light's power.
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	intensity: number;
	/**
	 * When **Default mode** — When distance is zero, light does not attenuate. When distance is non-zero,
	 * light will attenuate linearly from maximum intensity at the light's position down to zero at this distance from the light.
	 *
	 * When **{@link WebGLRenderer.useLegacyLights | legacy lighting mode} is disabled** — When distance is zero,
	 * light will attenuate according to inverse-square law to infinite distance.
	 * When distance is non-zero, light will attenuate according to inverse-square law until near the distance cutoff,
	 * where it will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not physically correct.
	 *
	 * @defaultValue `0.0`
	 * @remarks Expects a `Float`
	 */
	distance: number;
	/**
	 * If set to `true` light will cast dynamic shadows.
	 * **Warning**: This is expensive and requires tweaking to get shadows looking right.
	 * @see {@link THREE.PointLightShadow | PointLightShadow} for details.
	 * @defaultValue `false`
	 */
	castShadow: boolean;
	/**
	 * The amount the light dims along the distance of the light.
	 * In context of physically-correct rendering the default value should not be changed.
	 * @remarks Expects a `Float`
	 * @defaultValue `2`
	 */
	decay: number;
	/**
	 * A {@link THREE.PointLightShadow | PointLightShadow} used to calculate shadows for this light.
	 * The lightShadow's {@link LightShadow.camera | camera} is set to
	 * a {@link THREE.PerspectiveCamera | PerspectiveCamera} with {@link PerspectiveCamera.fov | fov} of 90,
	 * {@link PerspectiveCamera.aspect | aspect} of 1,
	 * {@link PerspectiveCamera.near | near} clipping plane at 0.5
	 * and {@link PerspectiveCamera.far | far} clipping plane at 500.
	 * @defaultValue new THREE.PointLightShadow()
	 */
	shadow: PointLightShadow;
	/**
	 * The light's power.
	 * When **{@link WebGLRenderer.useLegacyLights | legacy lighting mode} is disabled** — power is the luminous power of the light measured in lumens (lm).
	 * @remarks Changing the power will also change the light's intensity.
	 * @remarks Expects a `Float`
	 */
	power: number;
	toJSON(meta?: JSONMeta): PointLightJSON;
}
declare class PointLightHelper extends Object3D {
	/**
	 * Create a new instance of {@link PointLightHelper}
	 * @param light The light to be visualized.
	 * @param sphereSize The size of the sphere helper. Expects a `Float`. Default `1`
	 * @param color If this is not the set the helper will take the color of the light.
	 */
	constructor(light: PointLight, sphereSize?: number, color?: ColorRepresentation);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `PointLightHelper`
	 */
	override readonly type: string | "PointLightHelper";
	/**
	 * The {@link THREE.PointLight | PointLight} that is being visualized.
	 */
	light: PointLight;
	/**
	 * Reference to the {@link THREE.PointLight.matrixWorld | light.matrixWorld}.
	 */
	matrix: Matrix4;
	/**
	 * The color parameter passed in the constructor.
	 * @remarks If this is changed, the helper's color will update the next time {@link update} is called.
	 * @defaultValue `undefined`
	 */
	color: ColorRepresentation | undefined;
	/**
	 * Is set to `false`, as the helper is using the {@link THREE.PointLight.matrixWorld | light.matrixWorld}.
	 * @see {@link THREE.Object3D.matrixAutoUpdate | Object3D.matrixAutoUpdate}.
	 * @defaultValue `false`.
	 */
	override matrixAutoUpdate: boolean;
	/**
	 * Updates the helper to match the position of the {@link THREE..light | .light}.
	 */
	update(): void;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class PolarGridHelper extends LineSegments {
	/**
	 * Creates a new {@link PolarGridHelper} of radius 'radius' with 'sectors' number of sectors and 'rings' number of rings, where each circle is smoothed into 'divisions' number of line segments.
	 * @remarks Colors are optional.
	 * @param radius The radius of the polar grid. This can be any positive number. Default `10`.
	 * @param sectors The number of sectors the grid will be divided into. This can be any positive integer. Default `16`.
	 * @param rings The number of rings. This can be any positive integer. Default `8`.
	 * @param divisions The number of line segments used for each circle. This can be any positive integer that is 3 or greater. Default `64`.
	 * @param color1 The first color used for grid elements. This can be a {@link THREE.Color | Color}, a hexadecimal value and an CSS-Color name. Default `0x444444`.
	 * @param color2 The second color used for grid elements. This can be a {@link THREE.Color | Color}, a hexadecimal value and an CSS-Color name. Default `0x888888`.
	 */
	constructor(radius?: number, radials?: number, circles?: number, divisions?: number, color1?: ColorRepresentation, color2?: ColorRepresentation);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `PolarGridHelper`
	 */
	override readonly type: string | "PolarGridHelper";
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
export interface SkinnedMeshJSONObject extends MeshJSONObject {
	bindMode: BindMode;
	bindMatrix: Matrix4Tuple;
	skeleton?: string;
}
export interface SkinnedMeshJSON extends MeshJSON {
	object: SkinnedMeshJSONObject;
}
declare class SkinnedMesh<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[], TEventMap extends Object3DEventMap = Object3DEventMap> extends Mesh<TGeometry, TMaterial, TEventMap> {
	/**
	 * Create a new instance of {@link SkinnedMesh}
	 * @param geometry An instance of {@link THREE.BufferGeometry | BufferGeometry}. Default {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material A single or an array of {@link THREE.Material | Material}. Default {@link THREE.MeshBasicMaterial | `new THREE.MeshBasicMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial, useVertexTexture?: boolean);
	/**
	 * Read-only flag to check if a given object is of type {@link SkinnedMesh}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSkinnedMesh: true;
	/**
	 * @override
	 * @defaultValue `SkinnedMesh`
	 */
	override readonly type: string | "SkinnedMesh";
	/**
	 * Either {@link AttachedBindMode} or {@link DetachedBindMode}. {@link AttachedBindMode} means the skinned mesh
	 * shares the same world space as the skeleton. This is not true when using {@link DetachedBindMode} which is useful
	 * when sharing a skeleton across multiple skinned meshes.
	 * @defaultValue `AttachedBindMode`
	 */
	bindMode: BindMode;
	/**
	 * The base matrix that is used for the bound bone transforms.
	 */
	bindMatrix: Matrix4;
	/**
	 * The base matrix that is used for resetting the bound bone transforms.
	 */
	bindMatrixInverse: Matrix4;
	/**
	 * The bounding box of the SkinnedMesh. Can be calculated with {@link computeBoundingBox | .computeBoundingBox()}.
	 * @default `null`
	 */
	boundingBox: Box3;
	/**
	 * The bounding box of the SkinnedMesh. Can be calculated with {@link computeBoundingSphere | .computeBoundingSphere()}.
	 * @default `null`
	 */
	boundingSphere: Sphere;
	/**
	 * {@link THREE.Skeleton | Skeleton} representing the bone hierarchy of the skinned mesh.
	 */
	skeleton: Skeleton;
	/**
	 * Bind a skeleton to the skinned mesh
	 * @remarks
	 * The bindMatrix gets saved to .bindMatrix property and the .bindMatrixInverse gets calculated.
	 * @param skeleton {@link THREE.Skeleton | Skeleton} created from a {@link Bone | Bones} tree.
	 * @param bindMatrix {@link THREE.Matrix4 | Matrix4} that represents the base transform of the skeleton.
	 */
	bind(skeleton: Skeleton, bindMatrix?: Matrix4): void;
	/**
	 * Computes the bounding box of the skinned mesh, and updates the {@link .boundingBox} attribute. The bounding box
	 * is not computed by the engine; it must be computed by your app. If the skinned mesh is animated, the bounding box
	 * should be recomputed per frame.
	 */
	computeBoundingBox(): void;
	/**
	 * Computes the bounding sphere of the skinned mesh, and updates the {@link .boundingSphere} attribute. The bounding
	 * sphere is automatically computed by the engine when it is needed, e.g., for ray casting and view frustum culling.
	 * If the skinned mesh is animated, the bounding sphere should be recomputed per frame.
	 */
	computeBoundingSphere(): void;
	/**
	 * This method sets the skinned mesh in the rest pose (resets the pose).
	 */
	pose(): void;
	/**
	 * Normalizes the skin weights.
	 */
	normalizeSkinWeights(): void;
	/**
	 * Applies the bone transform associated with the given index to the given position vector
	 * @remarks Returns the updated vector.
	 * @param index Expects a `Integer`
	 * @param vector
	 */
	applyBoneTransform(index: number, vector: Vector3): Vector3;
	toJSON(meta?: JSONMeta): SkinnedMeshJSON;
}
declare class SkeletonHelper extends LineSegments {
	/**
	 * Create a new instance of {@link SkeletonHelper}
	 * @param object Usually an instance of {@link THREE.SkinnedMesh | SkinnedMesh}.
	 * However, any instance of {@link THREE.Object3D | Object3D} can be used if it represents a hierarchy of {@link Bone | Bone}s (via {@link THREE.Object3D.children | Object3D.children}).
	 */
	constructor(object: SkinnedMesh | Object3D);
	/**
	 * Read-only flag to check if a given object is of type {@link SkeletonHelper}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSkeletonHelper = true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `SkeletonHelper`
	 */
	override readonly type: string | "SkeletonHelper";
	/**
	 * The object passed in the constructor.
	 */
	root: SkinnedMesh | Object3D;
	/**
	 * The list of bones that the helper renders as {@link Line | Lines}.
	 */
	bones: Bone[];
	/**
	 * Is set to `false`, as the helper is using the {@link THREE.Object3D.matrixWorld | root.matrixWorld}.
	 * @see {@link THREE.Object3D.matrixAutoUpdate | Object3D.matrixAutoUpdate}.
	 * @defaultValue `false`.
	 */
	override matrixAutoUpdate: boolean;
	setColors(color1: Color, color2: Color): this;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class SpotLightHelper extends Object3D {
	/**
	 * Create a new instance of {@link SpotLightHelper}
	 * @param light The {@link THREE.SpotLight | SpotLight} to be visualized.
	 * @param color If this is not the set the helper will take the color of the light. Default `light.color`
	 */
	constructor(light: Light, color?: ColorRepresentation);
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @override
	 * @defaultValue `SpotLightHelper`
	 */
	override readonly type: string | "SpotLightHelper";
	/**
	 * {@link THREE.LineSegments | LineSegments} used to visualize the light.
	 */
	cone: LineSegments;
	/**
	 * Reference to the {@link THREE.SpotLight | SpotLight} being visualized.
	 */
	light: Light;
	/**
	 * Reference to the spotLight's {@link Object3D.matrixWorld | matrixWorld}.
	 */
	matrix: Matrix4;
	/**
	 * The color parameter passed in the constructor.
	 * If this is changed, the helper's color will update the next time {@link SpotLightHelper.update | update} is called.
	 * @defaultValue `undefined`
	 */
	color: ColorRepresentation | undefined;
	/**
	 * Is set to `false`, as the helper is using the {@link THREE.Light.matrixWorld | light.matrixWorld}.
	 * @see {@link THREE.Object3D.matrixAutoUpdate | Object3D.matrixAutoUpdate}.
	 * @defaultValue `false`.
	 */
	override matrixAutoUpdate: boolean;
	/**
	 * Updates the light helper.
	 */
	update(): void;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare class AmbientLight extends Light<undefined> {
	/**
	 * Creates a new {@link AmbientLight}.
	 * @param color Numeric value of the RGB component of the color. Default `0xffffff`
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`
	 */
	constructor(color?: ColorRepresentation, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link AmbientLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isAmbientLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `AmbientLight`
	 */
	override readonly type: string | "AmbientLight";
}
declare class SphericalHarmonics3 {
	constructor();
	/**
	 * @default [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(),
	 * new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]
	 */
	coefficients: Vector3[];
	readonly isSphericalHarmonics3: true;
	set(coefficients: Vector3[]): SphericalHarmonics3;
	zero(): SphericalHarmonics3;
	add(sh: SphericalHarmonics3): SphericalHarmonics3;
	addScaledSH(sh: SphericalHarmonics3, s: number): SphericalHarmonics3;
	scale(s: number): SphericalHarmonics3;
	lerp(sh: SphericalHarmonics3, alpha: number): SphericalHarmonics3;
	equals(sh: SphericalHarmonics3): boolean;
	copy(sh: SphericalHarmonics3): SphericalHarmonics3;
	clone(): this;
	/**
	 * Sets the values of this spherical harmonics from the provided array or array-like.
	 * @param array the source array or array-like.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
	/**
	 * Returns an array with the values of this spherical harmonics, or copies them into the provided array.
	 * @param array (optional) array to store the spherical harmonics to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray(array?: number[], offset?: number): number[];
	/**
	 * Returns an array with the values of this spherical harmonics, or copies them into the provided array-like.
	 * @param array array-like to store the spherical harmonics to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
	getAt(normal: Vector3, target: Vector3): Vector3;
	getIrradianceAt(normal: Vector3, target: Vector3): Vector3;
	static getBasisAt(normal: Vector3, shBasis: number[]): void;
}
export interface LightProbeJSON extends LightJSON {
	sh: number[];
}
declare class LightProbe extends Light {
	/**
	 * Creates a new LightProbe.
	 * @param sh An instance of {@link THREE.SphericalHarmonics3 | SphericalHarmonics3}. Default `new THREE.SphericalHarmonics3()``.
	 * @param intensity Numeric value of the light probe's intensity. Expects a `Float`. Default `1`.
	 */
	constructor(sh?: SphericalHarmonics3, intensity?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link DirectionalLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLightProbe: true;
	/**
	 * A light probe uses spherical harmonics to encode lighting information.
	 * @defaultValue `new THREE.SphericalHarmonics3()`
	 */
	sh: SphericalHarmonics3;
	toJSON(meta?: JSONMeta): LightProbeJSON;
}
declare class RectAreaLight extends Light<undefined> {
	/**
	 * Creates a new {@link RectAreaLight}.
	 * @param color Hexadecimal color of the light. Default `0xffffff` _(white)_.
	 * @param intensity The light's intensity, or brightness. Expects a `Float`. Default `1`
	 * @param width Width of the light. Expects a `Float`. Default `10`
	 * @param height Height of the light. Expects a `Float`. Default `10`
	 */
	constructor(color?: ColorRepresentation, intensity?: number, width?: number, height?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link RectAreaLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isRectAreaLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `RectAreaLight`
	 */
	override readonly type: string | "RectAreaLight";
	/**
	 * The width of the light.
	 * @remarks Expects a `Float`
	 * @defaultValue `10`
	 */
	width: number;
	/**
	 * The height of the light.
	 * @remarks Expects a `Float`
	 * @defaultValue `10`
	 */
	height: number;
	/**
	 * The light's intensity.
	 * @remarks Changing the intensity will also change the light's power.
	 * When **{@link WebGLRenderer.useLegacyLights | legacy lighting mode} is disabled** — intensity is the luminance (brightness) of the light measured in nits (cd/m^2).
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	intensity: number;
	/**
	 * The light's power.
	 * @remarks Changing the power will also change the light's intensity.
	 * When **{@link WebGLRenderer.useLegacyLights | legacy lighting mode} is disabled** — power is the luminous power of the light measured in lumens (lm).
	 * @remarks Expects a `Float`
	 */
	power: number;
}
declare class SpotLightShadow extends LightShadow<PerspectiveCamera> {
	/**
	 * Read-only flag to check if a given object is of type {@link SpotLightShadow}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSpotLightShadow: true;
	/**
	 * The light's view of the world.
	 * @remarks This is used to generate a depth map of the scene; objects behind other objects from the light's perspective will be in shadow.
	 * @remarks
	 * The {@link THREE.PerspectiveCamera.fov | fov} will track the {@link THREE.SpotLight.angle | angle} property
	 * of the owning {@link SpotLight | SpotLight} via the {@link SpotLightShadow.update | update} method.
	 * Similarly, the {@link THREE.PerspectiveCamera.aspect | aspect} property will track the aspect of the {@link LightShadow.mapSize | mapSize}.
	 * If the {@link SpotLight.distance | distance} property of the light is set, the {@link THREE.PerspectiveCamera.far | far} clipping plane will track that, otherwise it defaults to `500`.
	 * @defaultValue is a {@link THREE.PerspectiveCamera | PerspectiveCamera} with {@link THREE.PerspectiveCamera.near | near} clipping plane at `0.5`.
	 */
	camera: PerspectiveCamera;
	/**
	 * Used to focus the shadow camera.
	 * @remarks The camera's field of view is set as a percentage of the spotlight's field-of-view. Range is `[0, 1]`. 0`.
	 * @defaultValue `1`
	 */
	focus: number;
	aspect: number;
}
export interface SpotLightJSON extends LightJSON {
	distance: number;
	angle: number;
	decay: number;
	penumbra: number;
	target: string;
	map?: string | undefined;
	shadow: LightShadowJSON;
}
declare class SpotLight extends Light<SpotLightShadow> {
	/**
	 * Creates a new SpotLight.
	 * @param color Hexadecimal color of the light. Default `0xffffff` _(white)_.
	 * @param intensity Numeric value of the light's strength/intensity. Expects a `Float`. Default `1`.
	 * @param distance Maximum range of the light. Default is 0 (no limit). Expects a `Float`.
	 * @param angle Maximum angle of light dispersion from its direction whose upper bound is Math.PI/2.
	 * @param penumbra Percent of the {@link SpotLight} cone that is attenuated due to penumbra. Takes values between zero and 1. Expects a `Float`. Default `0`.
	 * @param decay The amount the light dims along the distance of the light. Expects a `Float`. Default `2`.
	 */
	constructor(color?: ColorRepresentation, intensity?: number, distance?: number, angle?: number, penumbra?: number, decay?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link SpotLight}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isSpotLight: true;
	/**
	 * A Read-only _string_ to check if `this` object type.
	 * @remarks Sub-classes will update this value.
	 * @defaultValue `SpotLight`
	 */
	override readonly type: string | "SpotLight";
	/**
	 * This is set equal to {@link THREE.Object3D.DEFAULT_UP | Object3D.DEFAULT_UP} (0, 1, 0), so that the light shines from the top down.
	 * @defaultValue `{@link Object3D.DEFAULT_UP}`
	 */
	readonly position: Vector3;
	/**
	 * The {@link SpotLight} points from its {@link SpotLight.position | position} to target.position.
	 * @remarks
	 * **Note**: For the target's position to be changed to anything other than the default,
	 * it must be added to the {@link Scene | scene} using
	 *
	 * ```typescript
	 * scene.add( light.target );
	 * ```
	 *
	 * This is so that the target's {@link Object3D.matrixWorld | matrixWorld} gets automatically updated each frame.
	 * It is also possible to set the target to be another object in the scene (anything with a {@link THREE.Object3D.position | position} property), like so:
	 * ```typescript
	 * const targetObject = new THREE.Object3D();
	 * scene.add(targetObject);
	 * light.target = targetObject;
	 * ```
	 * The {@link SpotLight} will now track the target object.
	 * @defaultValue `new THREE.Object3D()` _The default position of the target is *(0, 0, 0)*._
	 */
	target: Object3D;
	/**
	 * If set to `true` light will cast dynamic shadows.
	 * @remarks  **Warning**: This is expensive and requires tweaking to get shadows looking right. the {@link THREE.SpotLightShadow | SpotLightShadow} for details.
	 * @defaultValue `false`
	 */
	override castShadow: boolean;
	/**
	 * The light's intensity.
	 * @remarks Changing the intensity will also change the light's power.
	 * When **{@link WebGLRenderer.useLegacyLights | legacy lighting mode} is disabled** — intensity is the luminous intensity of the light measured in candela (cd).
	 * @remarks Expects a `Float`
	 * @defaultValue `1`
	 */
	intensity: number;
	/**
	 * When **Default mode** — When distance is zero, light does not attenuate. When distance is non-zero,
	 * light will attenuate linearly from maximum intensity at the light's position down to zero at this distance from the light.
	 *
	 * When **{@link WebGLRenderer.useLegacyLights | legacy lighting mode} is disabled** — When distance is zero,
	 * light will attenuate according to inverse-square law to infinite distance.
	 * When distance is non-zero, light will attenuate according to inverse-square law until near the distance cutoff,
	 * where it will then attenuate quickly and smoothly to `0`. Inherently, cutoffs are not physically correct.
	 * @remarks Expects a `Float`
	 * @defaultValue `0.0`
	 */
	distance: number;
	/**
	 * Maximum extent of the spotlight, in radians, from its direction.
	 * @remarks Should be no more than `Math.PI/2`.
	 * @remarks Expects a `Float`
	 * @defaultValue `Math.PI / 3`
	 */
	angle: number;
	/**
	 * The amount the light dims along the distance of the light.
	 * In context of physically-correct rendering the default value should not be changed.
	 * @remarks Expects a `Float`
	 * @defaultValue `2`
	 */
	decay: number;
	/**
	 * A {@link THREE.SpotLightShadow | SpotLightShadow} used to calculate shadows for this light.
	 * @defaultValue `new THREE.SpotLightShadow()`
	 */
	shadow: SpotLightShadow;
	/**
	 * The light's power.
	 * @remarks Changing the power will also change the light's intensity.
	 * When **{@link WebGLRenderer.useLegacyLights | legacy lighting mode} is disabled** —  power is the luminous power of the light measured in lumens (lm).
	 * @remarks Expects a `Float`
	 */
	power: number;
	/**
	 * Percent of the {@link SpotLight} cone that is attenuated due to penumbra.
	 * @remarks Takes values between zero and 1.
	 * @remarks Expects a `Float`
	 * @defaultValue `0.0`
	 */
	penumbra: number;
	/**
	 * A {@link THREE.Texture | Texture} used to modulate the color of the light.
	 * The spot light color is mixed with the _RGB_ value of this texture, with a ratio corresponding to its alpha value.
	 * The cookie-like masking effect is reproduced using pixel values (0, 0, 0, 1-cookie_value).
	 * @remarks **Warning**: {@link SpotLight.map} is disabled if {@link SpotLight.castShadow} is `false`.
	 */
	map: Texture | null;
	toJSON(meta?: JSONMeta): SpotLightJSON;
}
declare class LoadingManager {
	constructor(onLoad?: () => void, onProgress?: (url: string, loaded: number, total: number) => void, onError?: (url: string) => void);
	/**
	 * Will be called when loading of an item starts.
	 * @param url The url of the item that started loading.
	 * @param loaded The number of items already loaded so far.
	 * @param total The total amount of items to be loaded.
	 */
	onStart: ((url: string, loaded: number, total: number) => void) | undefined;
	/**
	 * Will be called when all items finish loading.
	 * The default is a function with empty body.
	 */
	onLoad: () => void;
	/**
	 * Will be called for each loaded item.
	 * The default is a function with empty body.
	 * @param url The url of the item just loaded.
	 * @param loaded The number of items already loaded so far.
	 * @param total The total amount of items to be loaded.
	 */
	onProgress: (url: string, loaded: number, total: number) => void;
	/**
	 * Will be called when item loading fails.
	 * The default is a function with empty body.
	 * @param url The url of the item that errored.
	 */
	onError: (url: string) => void;
	abortController: AbortController;
	itemStart: (url: string) => void;
	itemEnd: (url: string) => void;
	itemError: (url: string) => void;
	/**
	 * Given a URL, uses the URL modifier callback (if any) and returns a resolved URL.
	 * If no URL modifier is set, returns the original URL.
	 * @param url the url to load
	 */
	resolveURL: (url: string) => string;
	/**
	 * If provided, the callback will be passed each resource URL before a request is sent.
	 * The callback may return the original URL, or a new URL to override loading behavior.
	 * This behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs.
	 * @param callback URL modifier callback. Called with url argument, and must return resolvedURL.
	 */
	setURLModifier: (callback?: (url: string) => string) => this;
	addHandler: (regex: RegExp, loader: Loader) => this;
	removeHandler: (regex: RegExp) => this;
	getHandler: (file: string) => Loader | null;
	abort: () => this;
}
declare const DefaultLoadingManager: LoadingManager;
declare class Loader<TData = unknown, TUrl = string> {
	constructor(manager?: LoadingManager);
	/**
	 * @default 'anonymous'
	 */
	crossOrigin: string;
	/**
	 * @default false
	 */
	withCredentials: boolean;
	/**
	 * @default ''
	 */
	path: string;
	/**
	 * @default ''
	 */
	resourcePath: string;
	manager: LoadingManager;
	/**
	 * @default {}
	 */
	requestHeader: {
		[header: string]: string;
	};
	load(url: TUrl, onLoad: (data: TData) => void, onProgress?: (event: ProgressEvent) => void, onError?: (err: unknown) => void): void;
	loadAsync(url: TUrl, onProgress?: (event: ProgressEvent) => void): Promise<TData>;
	setCrossOrigin(crossOrigin: string): this;
	setWithCredentials(value: boolean): this;
	setPath(path: string): this;
	setResourcePath(resourcePath: string): this;
	setRequestHeader(requestHeader: {
		[header: string]: string;
	}): this;
	abort(): this;
	static DEFAULT_MATERIAL_NAME: string;
}
declare class AnimationLoader extends Loader<AnimationClip[]> {
	constructor(manager?: LoadingManager);
	parse(json: readonly unknown[]): AnimationClip[];
}
declare class AudioLoader extends Loader<AudioBuffer> {
	constructor(manager?: LoadingManager);
}
declare class BufferGeometryLoader extends Loader<InstancedBufferGeometry | BufferGeometry> {
	constructor(manager?: LoadingManager);
	parse(json: unknown): InstancedBufferGeometry | BufferGeometry;
}
declare const Cache$1: {
	/**
	 * @default false
	 */
	enabled: boolean;
	/**
	 * @default {}
	 */
	files: any;
	add(key: string, file: any): void;
	get(key: string): any;
	remove(key: string): void;
	clear(): void;
};
declare class CompressedTextureLoader extends Loader<CompressedTexture> {
	constructor(manager?: LoadingManager);
	load(url: string, onLoad?: (data: CompressedTexture) => void, onProgress?: (event: ProgressEvent) => void, onError?: (err: unknown) => void): CompressedTexture;
}
declare class CubeTextureLoader extends Loader<CubeTexture, readonly string[]> {
	constructor(manager?: LoadingManager);
	load(url: readonly string[], onLoad?: (data: CubeTexture) => void, onProgress?: (event: ProgressEvent) => void, onError?: (err: unknown) => void): CubeTexture;
}
declare class DataTextureLoader extends Loader<DataTexture> {
	constructor(manager?: LoadingManager);
	load(url: string, onLoad?: (data: DataTexture, texData: object) => void, onProgress?: (event: ProgressEvent) => void, onError?: (err: unknown) => void): DataTexture;
}
declare class FileLoader extends Loader<string | ArrayBuffer> {
	constructor(manager?: LoadingManager);
	load(url: string, onLoad?: (data: string | ArrayBuffer) => void, onProgress?: (event: ProgressEvent) => void, onError?: (err: unknown) => void): void;
	mimeType: string;
	responseType: string;
	setResponseType(value: string): this;
	setMimeType(value: string): this;
}
declare class ImageBitmapLoader extends Loader<ImageBitmap> {
	readonly isImageBitmapLoader: true;
	/**
	 * @default { premultiplyAlpha: 'none' }
	 */
	options: ImageBitmapOptions;
	constructor(manager?: LoadingManager);
	setOptions(options: ImageBitmapOptions): this;
	load(url: string, onLoad?: (data: ImageBitmap) => void, onProgress?: (event: ProgressEvent) => void, onError?: (err: unknown) => void): void;
}
declare class ImageLoader extends Loader<HTMLImageElement> {
	constructor(manager?: LoadingManager);
	load(url: string, onLoad?: (data: HTMLImageElement) => void, onProgress?: (event: ProgressEvent) => void, onError?: (err: unknown) => void): HTMLImageElement;
}
declare class LoaderUtils {
	static extractUrlBase(url: string): string;
	static resolveURL(url: string, path: string): string;
}
declare class MaterialLoader extends Loader<Material> {
	/**
	 * @default {}
	 */
	textures: {
		[key: string]: Texture;
	};
	constructor(manager?: LoadingManager);
	parse(json: unknown): Material;
	setTextures(textures: {
		[key: string]: Texture;
	}): this;
	createMaterialFromType(type: string): Material;
	static createMaterialFromType(type: string): Material;
}
declare class ObjectLoader extends Loader<Object3D> {
	constructor(manager?: LoadingManager);
	load(url: string, onLoad?: (data: Object3D) => void, onProgress?: (event: ProgressEvent) => void, onError?: (err: unknown) => void): void;
	parse(json: unknown, onLoad?: (object: Object3D) => void): Object3D;
	parseAsync(json: unknown): Promise<Object3D>;
	parseGeometries(json: unknown): {
		[key: string]: InstancedBufferGeometry | BufferGeometry;
	};
	parseMaterials(json: unknown, textures: {
		[key: string]: Texture;
	}): {
		[key: string]: Material;
	};
	parseAnimations(json: unknown): {
		[key: string]: AnimationClip;
	};
	parseImages(json: unknown, onLoad?: () => void): {
		[key: string]: Source<unknown>;
	};
	parseImagesAsync(json: unknown): Promise<{
		[key: string]: Source<unknown>;
	}>;
	parseTextures(json: unknown, images: {
		[key: string]: Source<unknown>;
	}): {
		[key: string]: Texture;
	};
	parseObject(data: unknown, geometries: {
		[key: string]: InstancedBufferGeometry | BufferGeometry;
	}, materials: {
		[key: string]: Material;
	}, animations: {
		[key: string]: AnimationClip;
	}): Object3D;
}
declare class TextureLoader extends Loader<Texture<HTMLImageElement>> {
	constructor(manager?: LoadingManager);
	load(url: string, onLoad?: (data: Texture<HTMLImageElement>) => void, onProgress?: (event: ProgressEvent) => void, onError?: (err: unknown) => void): Texture<HTMLImageElement>;
}
declare class FrustumArray {
	coordinateSystem: CoordinateSystem;
	constructor();
	intersectsObject(object: Object3D, cameraArray: ArrayCamera): boolean;
	intersectsSprite(sprite: Sprite, cameraArray: ArrayCamera): boolean;
	intersectsSprite(sphere: Sphere, cameraArray: ArrayCamera): boolean;
	intersectsBox(box: Box3, cameraArray: ArrayCamera): boolean;
	containsPoint(point: Vector3, cameraArray: ArrayCamera): boolean;
	clone(): FrustumArray;
}
declare class QuaternionLinearInterpolant extends Interpolant {
	constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
	interpolate_(i1: number, t0: number, t: number, t1: number): any;
}
declare const DEG2RAD: number;
declare const RAD2DEG: number;
declare function generateUUID(): string;
declare function clamp(value: number, min: number, max: number): number;
declare function euclideanModulo(n: number, m: number): number;
declare function mapLinear(x: number, a1: number, a2: number, b1: number, b2: number): number;
declare function inverseLerp(x: number, y: number, t: number): number;
declare function lerp(x: number, y: number, t: number): number;
declare function damp(x: number, y: number, lambda: number, dt: number): number;
declare function pingpong(x: number, length?: number): number;
declare function smoothstep(x: number, min: number, max: number): number;
declare function smootherstep(x: number, min: number, max: number): number;
declare function randInt(low: number, high: number): number;
declare function randFloat(low: number, high: number): number;
declare function randFloatSpread(range: number): number;
declare function seededRandom(seed?: number): number;
declare function degToRad(degrees: number): number;
declare function radToDeg(radians: number): number;
declare function isPowerOfTwo(value: number): boolean;
declare function ceilPowerOfTwo(value: number): number;
declare function floorPowerOfTwo(value: number): number;
declare function setQuaternionFromProperEuler(q: Quaternion, a: number, b: number, c: number, order: string): void;
declare function denormalize(value: number, array: Float32Array | Uint32Array | Uint16Array | Uint8Array | Int32Array | Int16Array | Int8Array): number;
declare function normalize(value: number, array: Float32Array | Uint32Array | Uint16Array | Uint8Array | Int32Array | Int16Array | Int8Array): number;
declare const MathUtils: {
	DEG2RAD: typeof DEG2RAD;
	RAD2DEG: typeof RAD2DEG;
	generateUUID: typeof generateUUID;
	clamp: typeof clamp;
	euclideanModulo: typeof euclideanModulo;
	mapLinear: typeof mapLinear;
	inverseLerp: typeof inverseLerp;
	lerp: typeof lerp;
	damp: typeof damp;
	pingpong: typeof pingpong;
	smoothstep: typeof smoothstep;
	smootherstep: typeof smootherstep;
	randInt: typeof randInt;
	randFloat: typeof randFloat;
	randFloatSpread: typeof randFloatSpread;
	seededRandom: typeof seededRandom;
	degToRad: typeof degToRad;
	radToDeg: typeof radToDeg;
	isPowerOfTwo: typeof isPowerOfTwo;
	ceilPowerOfTwo: typeof ceilPowerOfTwo;
	floorPowerOfTwo: typeof floorPowerOfTwo;
	setQuaternionFromProperEuler: typeof setQuaternionFromProperEuler;
	normalize: typeof normalize;
	denormalize: typeof denormalize;
};
export type Matrix2Tuple = [
	n11: number,
	n12: number,
	n21: number,
	n22: number
];
declare class Matrix2 {
	readonly isMatrix2: true;
	/**
	 * A {@link https://en.wikipedia.org/wiki/Row-_and_column-major_order column-major} list of matrix values.
	 */
	elements: Matrix2Tuple;
	/**
	 * Creates a 2x2 {@link https://en.wikipedia.org/wiki/Identity_matrix identity matrix}.
	 */
	constructor();
	/**
	 * Creates a 2x2 matrix with the given arguments in row-major order.
	 */
	constructor(n11: number, n12: number, n21: number, n22: number);
	/**
	 * Resets this matrix to the 2x2 identity matrix:
	 */
	identity(): this;
	/**
	 * Sets the elements of this matrix based on an array in
	 * {@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order column-major} format.
	 *
	 * @param array the array to read the elements from
	 * @param offset (optional) index of first element in the array. Default is `0`.
	 */
	fromArray(array: ArrayLike<number>, offset?: number): this;
	/**
	 * Sets the 2x2 matrix values to the given
	 * {@link https://en.wikipedia.org/wiki/Row-_and_column-major_order row-major} sequence of values:
	 * [n11, n12,
	 *  n21, n22]
	 */
	set(n11: number, n12: number, n21: number, n22: number): this;
}
export interface BatchedMeshGeometryRange {
	vertexStart: number;
	vertexCount: number;
	reservedVertexCount: number;
	indexStart: number;
	indexCount: number;
	reservedIndexCount: number;
	start: number;
	count: number;
}
declare class BatchedMesh extends Mesh<BufferGeometry, Material> {
	/**
	 * This bounding box encloses all instances of the {@link BatchedMesh}. Can be calculated with
	 * {@link .computeBoundingBox()}.
	 * @default null
	 */
	boundingBox: Box3 | null;
	/**
	 * This bounding sphere encloses all instances of the {@link BatchedMesh}. Can be calculated with
	 * {@link .computeBoundingSphere()}.
	 * @default null
	 */
	boundingSphere: Sphere | null;
	customSort: ((this: this, list: Array<{
		start: number;
		count: number;
		z: number;
	}>, camera: Camera) => void) | null;
	/**
	 * If true then the individual objects within the {@link BatchedMesh} are frustum culled.
	 * @default true
	 */
	perObjectFrustumCulled: boolean;
	/**
	 * If true then the individual objects within the {@link BatchedMesh} are sorted to improve overdraw-related
	 * artifacts. If the material is marked as "transparent" objects are rendered back to front and if not then they are
	 * rendered front to back.
	 * @default true
	 */
	sortObjects: boolean;
	/**
	 * The maximum number of individual geometries that can be stored in the {@link BatchedMesh}. Read only.
	 */
	get maxInstanceCount(): number;
	get instanceCount(): number;
	get unusedVertexCount(): number;
	get unusedIndexCount(): number;
	/**
	 * Read-only flag to check if a given object is of type {@link BatchedMesh}.
	 */
	readonly isBatchedMesh: true;
	/**
	 * @param maxInstanceCount the max number of individual geometries planned to be added.
	 * @param maxVertexCount the max number of vertices to be used by all geometries.
	 * @param maxIndexCount the max number of indices to be used by all geometries.
	 * @param material an instance of {@link Material}. Default is a new {@link MeshBasicMaterial}.
	 */
	constructor(maxInstanceCount: number, maxVertexCount: number, maxIndexCount?: number, material?: Material);
	/**
	 * Computes the bounding box, updating {@link .boundingBox} attribute.
	 * Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 */
	computeBoundingBox(): void;
	/**
	 * Computes the bounding sphere, updating {@link .boundingSphere} attribute.
	 * Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 */
	computeBoundingSphere(): void;
	/**
	 * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer
	 * used in your app.
	 */
	dispose(): this;
	/**
	 * Takes a sort a function that is run before render. The function takes a list of instances to sort and a camera.
	 * The objects in the list include a "z" field to perform a depth-ordered sort with.
	 */
	setCustomSort(sortFunction: ((this: this, list: Array<{
		start: number;
		count: number;
		z: number;
	}>, camera: Camera) => void) | null): this;
	/**
	 * Get the color of the defined geometry.
	 * @param instanceId The id of an instance to get the color of.
	 * @param target The target object to copy the color in to.
	 */
	getColorAt(instanceId: number, target: Color): void;
	/**
	 * Get the local transformation matrix of the defined instance.
	 * @param instanceId The id of an instance to get the matrix of.
	 * @param target This 4x4 matrix will be set to the local transformation matrix of the defined instance.
	 */
	getMatrixAt(instanceId: number, target: Matrix4): Matrix4;
	/**
	 * Get whether the given instance is marked as "visible" or not.
	 * @param instanceId The id of an instance to get the visibility state of.
	 */
	getVisibleAt(instanceId: number): boolean;
	/**
	 * Get the range representing the subset of triangles related to the attached geometry, indicating the starting
	 * offset and count, or `null` if invalid.
	 *
	 * Return an object of the form: { start: Integer, count: Integer }
	 * @param geometryId The id of the geometry to get the range of.
	 * @param target Optional target object to copy the range in to.
	 */
	getGeometryRangeAt(geometryId: number, target?: BatchedMeshGeometryRange): BatchedMeshGeometryRange | null;
	/**
	 * Get the geometryIndex of the defined instance.
	 * @param instanceId The id of an instance to get the geometryIndex of.
	 */
	getGeometryIdAt(instanceId: number): number;
	/**
	 * Sets the given color to the defined geometry instance.
	 * @param instanceId The id of the instance to set the color of.
	 * @param color The color to set the instance to.
	 */
	setColorAt(instanceId: number, color: Color): void;
	/**
	 * Sets the given local transformation matrix to the defined instance.
	 * Negatively scaled matrices are not supported.
	 * @param instanceId The id of an instance to set the matrix of.
	 * @param matrix A 4x4 matrix representing the local transformation of a single instance.
	 */
	setMatrixAt(instanceId: number, matrix: Matrix4): this;
	/**
	 * Sets the visibility of the instance at the given index.
	 * @param instanceId The id of the instance to set the visibility of.
	 * @param visible A boolean value indicating the visibility state.
	 */
	setVisibleAt(instanceId: number, visible: boolean): this;
	/**
	 * Sets the geometryIndex of the instance at the given index.
	 * @param instanceId The id of the instance to set the geometryIndex of.
	 * @param geometryId The geometryIndex to be use by the instance.
	 */
	setGeometryIdAt(instanceId: number, geometryId: number): this;
	/**
	 * Adds the given geometry to the {@link BatchedMesh} and returns the associated index referring to it.
	 * @param geometry The geometry to add into the {@link BatchedMesh}.
	 * @param reservedVertexRange Optional parameter specifying the amount of vertex buffer space to reserve for the
	 * added geometry. This is necessary if it is planned to set a new geometry at this index at a later time that is
	 * larger than the original geometry. Defaults to the length of the given geometry vertex buffer.
	 * @param reservedIndexRange Optional parameter specifying the amount of index buffer space to reserve for the added
	 * geometry. This is necessary if it is planned to set a new geometry at this index at a later time that is larger
	 * than the original geometry. Defaults to the length of the given geometry index buffer.
	 */
	addGeometry(geometry: BufferGeometry, reservedVertexRange?: number, reservedIndexRange?: number): number;
	/**
	 * Adds a new instance to the {@link BatchedMesh} using the geometry of the given geometryId and returns a new id
	 * referring to the new instance to be used by other functions.
	 * @param geometryId The id of a previously added geometry via "addGeometry" to add into the {@link BatchedMesh} to
	 * render.
	 */
	addInstance(geometryId: number): number;
	/**
	 * @param geometryId The id of a geometry to remove from the [name] that was previously added via "addGeometry". Any
	 * instances referencing this geometry will also be removed as a side effect.
	 */
	deleteGeometry(geometryId: number): this;
	/**
	 * Removes an existing instance from the BatchedMesh using the given instanceId.
	 * @param instanceId The id of an instance to remove from the BatchedMesh that was previously added via
	 * "addInstance".
	 */
	deleteInstance(instanceId: number): this;
	/**
	 * Replaces the geometry at `geometryId` with the provided geometry. Throws an error if there is not enough space
	 * reserved for geometry. Calling this will change all instances that are rendering that geometry.
	 * @param geometryId Which geometry id to replace with this geometry.
	 * @param geometry The geometry to substitute at the given geometry id.
	 */
	setGeometryAt(geometryId: number, geometry: BufferGeometry): number;
	/**
	 * Repacks the sub geometries in [name] to remove any unused space remaining from previously deleted geometry,
	 * freeing up space to add new geometry.
	 */
	optimize(): this;
	/**
	 * Resizes the available space in BatchedMesh's vertex and index buffer attributes to the provided sizes. If the
	 * provided arguments shrink the geometry buffers but there is not enough unused space at the end of the geometry
	 * attributes then an error is thrown.
	 * @param maxVertexCount the max number of vertices to be used by all unique geometries to resize to.
	 * @param maxIndexCount the max number of indices to be used by all unique geometries to resize to.
	 */
	setGeometrySize(maxVertexCount: number, maxIndexCount: number): void;
	/**
	 * Resizes the necessary buffers to support the provided number of instances. If the provided arguments shrink the
	 * number of instances but there are not enough unused ids at the end of the list then an error is thrown.
	 * @param maxInstanceCount the max number of individual instances that can be added and rendered by the BatchedMesh.
	 */
	setInstanceCount(maxInstanceCount: number): void;
	getBoundingBoxAt(geometryId: number, target: Box3): Box3 | null;
	getBoundingSphereAt(geometryId: number, target: Sphere): Sphere | null;
}
export interface InstancedMeshJSONObject extends MeshJSONObject {
	count: number;
	instanceMatrix: BufferAttributeJSON;
	instanceColor?: BufferAttributeJSON;
}
export interface InstancedMeshJSON extends MeshJSONObject {
	object: InstancedMeshJSONObject;
}
export interface InstancedMeshEventMap extends Object3DEventMap {
	dispose: {};
}
declare class InstancedMesh<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[], TEventMap extends InstancedMeshEventMap = InstancedMeshEventMap> extends Mesh<TGeometry, TMaterial, TEventMap> {
	/**
	 * Create a new instance of {@link InstancedMesh}
	 * @param geometry An instance of {@link BufferGeometry}.
	 * @param material A single or an array of {@link Material}. Default is a new {@link MeshBasicMaterial}.
	 * @param count The **maximum** number of instances of this Mesh. Expects a `Integer`
	 */
	constructor(geometry: TGeometry | undefined, material: TMaterial | undefined, count: number);
	/**
	 * Read-only flag to check if a given object is of type {@link InstancedMesh}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isInstancedMesh: true;
	/**
	 * This bounding box encloses all instances of the {@link InstancedMesh},, which can be calculated with {@link computeBoundingBox | .computeBoundingBox()}.
	 * @remarks Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 * @defaultValue `null`
	 */
	boundingBox: Box3 | null;
	/**
	 * This bounding sphere encloses all instances of the {@link InstancedMesh}, which can be calculated with {@link computeBoundingSphere | .computeBoundingSphere()}.
	 * @remarks bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are `null`.
	 * @defaultValue `null`
	 */
	boundingSphere: Sphere | null;
	/**
	 * The number of instances.
	 * @remarks
	 * The `count` value passed into the {@link InstancedMesh | constructor} represents the **maximum** number of instances of this mesh.
	 * You can change the number of instances at runtime to an integer value in the range `[0, count]`.
	 * If you need more instances than the original `count` value, you have to create a new InstancedMesh.
	 * Expects a `Integer`
	 */
	count: number;
	/**
	 * Represents the colors of all instances.
	 * You have to set {@link InstancedBufferAttribute.needsUpdate | .instanceColor.needsUpdate()} flag to `true` if you modify instanced data via {@link setColorAt | .setColorAt()}.
	 * @defaultValue `null`
	 */
	instanceColor: InstancedBufferAttribute | null;
	/**
	 * Represents the local transformation of all instances.
	 * You have to set {@link InstancedBufferAttribute.needsUpdate | .instanceMatrix.needsUpdate()} flag to `true` if you modify instanced data via {@link setMatrixAt | .setMatrixAt()}.
	 */
	instanceMatrix: InstancedBufferAttribute;
	/**
	 * Represents the morph target weights of all instances. You have to set its {@link .needsUpdate} flag to true if
	 * you modify instanced data via {@link .setMorphAt}.
	 */
	morphTexture: DataTexture | null;
	/**
	 * Computes the bounding box of the instanced mesh, and updates the {@link .boundingBox} attribute. The bounding box
	 * is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if an
	 * instance is transformed via {@link .setMatrixAt()}.
	 */
	computeBoundingBox(): void;
	/**
	 * Computes the bounding sphere of the instanced mesh, and updates the {@link .boundingSphere} attribute. The engine
	 * automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You
	 * may need to recompute the bounding sphere if an instance is transformed via [page:.setMatrixAt]().
	 */
	computeBoundingSphere(): void;
	/**
	 * Get the color of the defined instance.
	 * @param index The index of an instance. Values have to be in the range `[0, count]`. Expects a `Integer`
	 * @param color This color object will be set to the color of the defined instance.
	 */
	getColorAt(index: number, color: Color): void;
	/**
	 * Sets the given color to the defined instance
	 * @remarks
	 * Make sure you set {@link InstancedBufferAttribute.needsUpdate | .instanceColor.needsUpdate()} to `true` after updating all the colors.
	 * @param index The index of an instance. Values have to be in the range `[0, count]`. Expects a `Integer`
	 * @param color The color of a single instance.
	 */
	setColorAt(index: number, color: Color): void;
	/**
	 * Get the local transformation matrix of the defined instance.
	 * @param index The index of an instance Values have to be in the range `[0, count]`. Expects a `Integer`
	 * @param matrix This 4x4 matrix will be set to the local transformation matrix of the defined instance.
	 */
	getMatrixAt(index: number, matrix: Matrix4): void;
	/**
	 * Get the morph target weights of the defined instance.
	 * @param index The index of an instance. Values have to be in the range [0, count].
	 * @param mesh The {@link .morphTargetInfluences} property of this mesh will be filled with the morph target weights of the defined instance.
	 */
	getMorphAt(index: number, mesh: Mesh): void;
	/**
	 * Sets the given local transformation matrix to the defined instance. Make sure you set
	 * {@link InstancedBufferAttribute.needsUpdate | .instanceMatrix.needsUpdate()} flag to `true` after updating all
	 * the matrices.
	 * Negatively scaled matrices are not supported.
	 * @param index The index of an instance. Values have to be in the range `[0, count]`. Expects a `Integer`
	 * @param matrix A 4x4 matrix representing the local transformation of a single instance.
	 */
	setMatrixAt(index: number, matrix: Matrix4): void;
	/**
	 * Sets the morph target weights to the defined instance. Make sure you set {@link .morphTexture}{@link .needsUpdate}
	 * to true after updating all the influences.
	 * @param index The index of an instance. Values have to be in the range [0, count].
	 * @param mesh A mesh with {@link .morphTargetInfluences} property containing the morph target weights of a single instance.
	 */
	setMorphAt(index: number, mesh: Mesh): void;
	/**
	 * No effect in {@link InstancedMesh}.
	 * @ignore
	 * @hidden
	 */
	override updateMorphTargets(): void;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): this;
	toJSON(meta?: JSONMeta): InstancedMeshJSON;
}
declare class LineLoop<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[], TEventMap extends Object3DEventMap = Object3DEventMap> extends Line<TGeometry, TMaterial, TEventMap> {
	/**
	 * Create a new instance of {@link LineLoop}
	 * @param geometry  List of vertices representing points on the line loop. Default {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material Material for the line. Default {@link THREE.LineBasicMaterial | `new THREE.LineBasicMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link LineLoop}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLineLoop: true;
	/**
	 * @override
	 * @defaultValue `LineLoop`
	 */
	override readonly type: string | "LineLoop";
}
export interface LODJSONObject extends Object3DJSONObject {
	autoUpdate?: boolean;
	levels: Array<{
		object: string;
		distance: number;
		hysteresis: number;
	}>;
}
export interface LODJSON extends Object3DJSON {
	object: LODJSONObject;
}
declare class LOD<TEventMap extends Object3DEventMap = Object3DEventMap> extends Object3D<TEventMap> {
	/**
	 * Creates a new {@link LOD}.
	 */
	constructor();
	/**
	 * Read-only flag to check if a given object is of type {@link LOD}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isLOD: true;
	/**
	 * @override
	 * @defaultValue `LOD`
	 */
	override readonly type: string | "LOD";
	/**
	 * An array of level objects
	 */
	readonly levels: Array<{
		/** The Object3D to display at this level. */
		object: Object3D;
		/** The distance at which to display this level of detail. Expects a `Float`. */
		distance: number;
		/** Threshold used to avoid flickering at LOD boundaries, as a fraction of distance. Expects a `Float`. */
		hysteresis: number;
	}>;
	/**
	 * Whether the {@link LOD} object is updated automatically by the renderer per frame or not.
	 * If set to `false`, you have to call {@link update | .update()} in the render loop by yourself.
	 * @defaultValue `true`
	 */
	autoUpdate: boolean;
	/**
	 * Adds a mesh that will display at a certain distance and greater. Typically the further away the distance, the lower the detail on the mesh.
	 *
	 * @param object The Object3D to display at this level.
	 * @param distance The distance at which to display this level of detail. Expects a `Float`. Default `0.0`.
	 * @param hysteresis Threshold used to avoid flickering at LOD boundaries, as a fraction of distance. Expects a `Float`. Default `0.0`.
	 */
	addLevel(object: Object3D, distance?: number, hysteresis?: number): this;
	/**
	 * Removes an existing level, based on the distance from the camera. Returns `true` when the level has been removed.
	 * Otherwise `false`.
	 * @param distance Distance of the level to delete.
	 */
	removeLevel(distance: number): boolean;
	/**
	 * Get the currently active {@link LOD} level
	 * @remarks
	 * As index of the levels array.
	 */
	getCurrentLevel(): number;
	/**
	 * Get a reference to the first {@link THREE.Object3D | Object3D} (mesh) that is greater than {@link distance}.
	 * @param distance Expects a `Float`
	 */
	getObjectForDistance(distance: number): Object3D | null;
	/**
	 * Set the visibility of each {@link levels | level}'s {@link THREE.Object3D | object} based on distance from the {@link THREE.Camera | camera}.
	 * @param camera
	 */
	update(camera: Camera): void;
	toJSON(meta?: JSONMeta): LODJSON;
}
declare class Points<TGeometry extends BufferGeometry<NormalOrGLBufferAttributes> = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[], TEventMap extends Object3DEventMap = Object3DEventMap> extends Object3D<TEventMap> {
	/**
	 * Create a new instance of {@link Points}
	 * @param geometry An instance of {@link THREE.BufferGeometry | BufferGeometry}. Default {@link THREE.BufferGeometry | `new THREE.BufferGeometry()`}.
	 * @param material A single or an array of {@link THREE.Material | Material}. Default {@link THREE.PointsMaterial | `new THREE.PointsMaterial()`}.
	 */
	constructor(geometry?: TGeometry, material?: TMaterial);
	/**
	 * Read-only flag to check if a given object is of type {@link Points}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isPoints: true;
	/**
	 * @override
	 * @defaultValue `Points`
	 */
	override readonly type: string | "Points";
	/**
	 * An array of weights typically from `0-1` that specify how much of the morph is applied.
	 * @defaultValue `undefined`, _but reset to a blank array by {@link updateMorphTargets | .updateMorphTargets()}._
	 */
	morphTargetInfluences?: number[] | undefined;
	/**
	 * A dictionary of morphTargets based on the `morphTarget.name` property.
	 * @defaultValue `undefined`, _but rebuilt by {@link updateMorphTargets | .updateMorphTargets()}._
	 */
	morphTargetDictionary?: {
		[key: string]: number;
	} | undefined;
	/**
	 * An instance of {@link THREE.BufferGeometry | BufferGeometry} (or derived classes), defining the object's structure.
	 * @remarks each vertex designates the position of a particle in the system.
	 */
	geometry: TGeometry;
	/**
	 * An instance of {@link THREE.Material | Material}, defining the object's appearance.
	 * @defaultValue {@link THREE.PointsMaterial | `new THREE.PointsMaterial()`}, _with randomised colour_.
	 */
	material: TMaterial;
	/**
	 * Updates the morphTargets to have no influence on the object
	 * @remarks Resets the {@link morphTargetInfluences} and {@link morphTargetDictionary} properties.
	 */
	updateMorphTargets(): void;
}
declare class Data3DTexture extends Texture<Data3DTextureImageData> {
	/**
	 * Create a new instance of {@link Data3DTexture}
	 * @param data {@link https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView | ArrayBufferView} of the texture. Default `null`.
	 * @param width Width of the texture. Default `1`.
	 * @param height Height of the texture. Default `1`.
	 * @param depth Depth of the texture. Default `1`.
	 */
	constructor(data?: TypedArray | null, width?: number, height?: number, depth?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link Data3DTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isData3DTexture: true;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link THREE.ClampToEdgeWrapping}
	 */
	wrapR: Wrapping;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
	/**
	 * @override
	 * @defaultValue `1`
	 */
	unpackAlignment: number;
}
export interface Data3DTextureImageData {
	data: TypedArray | null;
	width: number;
	height: number;
	depth: number;
}
declare class WebGL3DRenderTarget extends WebGLRenderTarget {
	/**
	 * Creates a new WebGL3DRenderTarget.
	 *
	 * @param width the width of the render target, in pixels. Default is `1`.
	 * @param height the height of the render target, in pixels. Default is `1`.
	 * @param depth the depth of the render target. Default is `1`.
	 * @param options optional object that holds texture parameters for an auto-generated target texture and
	 * depthBuffer/stencilBuffer booleans. See {@link WebGLRenderTarget} for details.
	 */
	constructor(width?: number, height?: number, depth?: number, options?: RenderTargetOptions);
	textures: Data3DTexture[];
	/**
	 * The texture property is overwritten with an instance of {@link Data3DTexture}.
	 */
	get texture(): Data3DTexture;
	set texture(value: Data3DTexture);
	readonly isWebGL3DRenderTarget: true;
}
declare class DataArrayTexture extends Texture<DataArrayTextureImageData> {
	/**
	 * Read-only flag to check if a given object is of type {@link DataArrayTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isDataArrayTexture: true;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override
	 * @defaultValue  {@link THREE.ClampToEdgeWrapping}
	 */
	wrapR: boolean;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	flipY: boolean;
	/**
	 * @override
	 * @defaultValue `1`
	 */
	unpackAlignment: number;
	/**
	 * A set of all layers which need to be updated in the texture. See {@link DataArrayTexture.addLayerUpdate}.
	 */
	layerUpdates: Set<number>;
	/**
	 * This creates a new {@link THREE.DataArrayTexture | DataArrayTexture} object.
	 * @remarks The interpretation of the data depends on {@link format} and {@link type}.
	 * @remarks If the {@link type} is {@link THREE.UnsignedByteType}, a {@link Uint8Array} will be useful for addressing the texel data
	 * @remarks If the {@link format} is {@link THREE.RGBAFormat}, data needs four values for one texel; Red, Green, Blue and Alpha (typically the opacity).
	 * @remarks For the packed {@link type | types}, {@link THREE.UnsignedShort4444Type} and {@link THREE.UnsignedShort5551Type}
	 * all color components of one texel can be addressed as bitfields within an integer element of a {@link Uint16Array}.
	 * @remarks In order to use the {@link type | types} {@link THREE.FloatType} and {@link THREE.HalfFloatType},
	 * the WebGL implementation must support the respective extensions _OES_texture_float_ and _OES_texture_half_float_
	 * @remarks In order to use {@link THREE.LinearFilter} for component-wise, bilinear interpolation of the texels based on these types,
	 * the WebGL extensions _OES_texture_float_linear_ or _OES_texture_half_float_linear_ must also be present.
	 * @param data {@link https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView | ArrayBufferView} of the texture. Default `null`.
	 * @param width Width of the texture. Default `1`.
	 * @param height Height of the texture. Default `1`.
	 * @param depth Depth of the texture. Default `1`.
	 */
	constructor(data?: TypedArray | null, width?: number, height?: number, depth?: number);
	/**
	 * Describes that a specific layer of the texture needs to be updated. Normally when {@link Texture.needsUpdate} is
	 * set to true, the entire compressed texture array is sent to the GPU. Marking specific layers will only transmit
	 * subsets of all mipmaps associated with a specific depth in the array which is often much more performant.
	 */
	addLayerUpdate(layerIndex: number): void;
	/**
	 * Resets the layer updates registry. See {@link DataArrayTexture.addLayerUpdate}.
	 */
	clearLayoutUpdates(): void;
}
export interface DataArrayTextureImageData {
	data: TypedArray | null;
	width: number;
	height: number;
	depth: number;
}
declare class WebGLArrayRenderTarget extends WebGLRenderTarget {
	/**
	 * Creates a new WebGLArrayRenderTarget.
	 *
	 * @param width the width of the render target, in pixels. Default is `1`.
	 * @param height the height of the render target, in pixels. Default is `1`.
	 * @param depth the depth/layer count of the render target. Default is `1`.
	 * @param options optional object that holds texture parameters for an auto-generated target texture and
	 * depthBuffer/stencilBuffer booleans. See {@link WebGLRenderTarget} for details.
	 */
	constructor(width?: number, height?: number, depth?: number, options?: RenderTargetOptions);
	textures: DataArrayTexture[];
	/**
	 * The texture property is overwritten with an instance of {@link DataArrayTexture}.
	 */
	get texture(): DataArrayTexture;
	set texture(value: DataArrayTexture);
	readonly isWebGLArrayRenderTarget: true;
}
declare class CanvasTexture<TCanvas = HTMLCanvasElement> extends Texture<TCanvas> {
	/**
	 * This creates a new {@link THREE.CanvasTexture | CanvasTexture} object.
	 * @param canvas The HTML canvas element from which to load the texture.
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link THREE.Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link THREE.LinearFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link THREE.LinearMipmapLinearFilter}
	 * @param format See {@link Texture.format | .format}. Default {@link THREE.RGBAFormat}
	 * @param type See {@link Texture.type | .type}. Default {@link THREE.UnsignedByteType}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link THREE.Texture.DEFAULT_ANISOTROPY}
	 */
	constructor(canvas?: TCanvas, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link CanvasTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCanvasTexture: true;
}
declare class CompressedArrayTexture extends CompressedTexture<CompressedArrayTextureImageData> {
	/**
	 * Read-only flag to check if a given object is of type {@link CompressedArrayTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isCompressedArrayTexture: true;
	/**
	 * This defines how the texture is wrapped in the depth direction.
	 * @see {@link https://threejs.org/docs/index.html#api/en/constants/Textures | Texture Constants}
	 * @defaultValue {@link THREE.ClampToEdgeWrapping}
	 */
	wrapR: Wrapping;
	/**
	 * A set of all layers which need to be updated in the texture. See {@link CompressedArrayTexture.addLayerUpdate}.
	 */
	layerUpdates: Set<number>;
	/**
	 * Create a new instance of {@link CompressedArrayTexture}
	 * @param mipmaps The mipmaps array should contain objects with data, width and height. The mipmaps should be of the
	 * correct format and type.
	 * @param width The width of the biggest mipmap.
	 * @param height The height of the biggest mipmap.
	 * @param depth The number of layers of the 2D array texture
	 * @param format The format used in the mipmaps. See {@link THREE.CompressedPixelFormat}.
	 * @param type See {@link Texture.type | .type}. Default {@link THREE.UnsignedByteType}
	 */
	constructor(mipmaps: CompressedTextureMipmap[], width: number, height: number, depth: number, format: CompressedPixelFormat, type?: TextureDataType);
	/**
	 * Describes that a specific layer of the texture needs to be updated. Normally when {@link Texture.needsUpdate} is
	 * set to true, the entire compressed texture array is sent to the GPU. Marking specific layers will only transmit
	 * subsets of all mipmaps associated with a specific depth in the array which is often much more performant.
	 */
	addLayerUpdate(layerIndex: number): void;
	/**
	 * Resets the layer updates registry. See {@link CompressedArrayTexture.addLayerUpdate}.
	 */
	clearLayoutUpdates(): void;
}
export interface CompressedArrayTextureImageData extends CompressedTextureImageData {
	depth: number;
}
declare class CompressedCubeTexture extends CompressedTexture<CompressedTextureImageData[]> {
	readonly isCompressedCubeTexture: true;
	readonly isCubeTexture: true;
	constructor(images: CompressedTextureImageData[], format?: CompressedPixelFormat, type?: TextureDataType);
}
declare class FramebufferTexture extends Texture<FramebufferTextureImageData> {
	/**
	 * Create a new instance of {@link FramebufferTexture}
	 * @param width The width of the texture.
	 * @param height The height of the texture.
	 */
	constructor(width: number, height: number);
	/**
	 * Read-only flag to check if a given object is of type {@link FramebufferTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isFramebufferTexture: true;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link THREE.NearestFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
}
export interface FramebufferTextureImageData {
	width: number;
	height: number;
}
declare class VideoTexture<TVideo = HTMLVideoElement> extends Texture<TVideo> {
	/**
	 * Create a new instance of {@link VideoTexture}
	 * @param video The video element to use as the texture.
	 * @param mapping See {@link Texture.mapping | .mapping}. Default {@link THREE.Texture.DEFAULT_MAPPING}
	 * @param wrapS See {@link Texture.wrapS | .wrapS}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param wrapT See {@link Texture.wrapT | .wrapT}. Default {@link THREE.ClampToEdgeWrapping}
	 * @param magFilter See {@link Texture.magFilter | .magFilter}. Default {@link THREE.LinearFilter}
	 * @param minFilter  See {@link Texture.minFilter | .minFilter}. Default {@link THREE.LinearFilter}
	 * @param format See {@link Texture.format | .format}. Default {@link THREE.RGBAFormat}
	 * @param type See {@link Texture.type | .type}. Default {@link THREE.UnsignedByteType}
	 * @param anisotropy See {@link Texture.anisotropy | .anisotropy}. Default {@link THREE.Texture.DEFAULT_ANISOTROPY}
	 */
	constructor(video: TVideo, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number);
	/**
	 * Read-only flag to check if a given object is of type {@link VideoTexture}.
	 * @remarks This is a _constant_ value
	 * @defaultValue `true`
	 */
	readonly isVideoTexture: true;
	/**
	 * @override
	 * @defaultValue {@link THREE.LinearFilter}
	 */
	magFilter: MagnificationTextureFilter;
	/**
	 * @override
	 * @defaultValue {@link THREE.LinearFilter}
	 */
	minFilter: MinificationTextureFilter;
	/**
	 * @override
	 * @defaultValue `false`
	 */
	generateMipmaps: boolean;
	/**
	 * @override
	 * You will **not** need to set this manually here as it is handled by the {@link update | update()} method.
	 */
	set needsUpdate(value: boolean);
	/**
	 * This is called automatically and sets {@link needsUpdate | .needsUpdate } to `true` every time a new frame is available.
	 */
	update(): void;
}
declare class VideoFrameTexture extends VideoTexture<VideoFrame | {}> {
	constructor(mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: MagnificationTextureFilter, minFilter?: MinificationTextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number);
	// FIXME Replace with VideoFrame when we no longer need to support TypeScript 5.0
	setFrame(frame: unknown): void;
}
export interface PMREMGeneratorOptions {
	size?: number | undefined;
	position?: Vector3 | undefined;
}
declare class PMREMGenerator {
	/**
	 * This constructor creates a new PMREMGenerator.
	 * @param renderer
	 */
	constructor(renderer: WebGLRenderer);
	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an image if networking bandwidth is low
	 * @remarks
	 * Optional near and far planes ensure the scene is rendered in its entirety.
	 * @param scene The given scene.
	 * @param sigma Specifies a blur radius in radians to be applied to the scene before PMREM generation. Default `0`.
	 * @param near The near plane value. Default `0.1`.
	 * @param far The far plane value. Default `100`.
	 * @param {?Object} [options={}]
	 */
	fromScene(scene: Scene, sigma?: number, near?: number, far?: number, options?: PMREMGeneratorOptions): WebGLRenderTarget;
	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR or HDR. The ideal input image size is
	 * 1k (1024 x 512), as this matches best with the 256 x 256 cubemap output. The smallest supported equirectangular
	 * image size is 64 x 32.
	 */
	fromEquirectangular(equirectangular: Texture, renderTarget?: WebGLRenderTarget | null): WebGLRenderTarget;
	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR or HDR. The ideal input cube size is
	 * 256 x 256, as this matches best with the 256 x 256 cubemap output. The smallest supported cube size is 16 x 16.
	 */
	fromCubemap(cubemap: CubeTexture, renderTarget?: WebGLRenderTarget | null): WebGLRenderTarget;
	/**
	 * Pre-compiles the cubemap shader
	 * @remarks
	 * You can get faster start-up by invoking this method during your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader(): void;
	/**
	 * Pre-compiles the equirectangular shader
	 * @remarks
	 * You can get faster start-up by invoking this method during your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader(): void;
	/**
	 * Frees the GPU-related resources allocated by this instance
	 * @remarks
	 * Call this method whenever this instance is no longer used in your app.
	 */
	dispose(): void;
}
declare const ShaderChunk: {
	alphahash_fragment: string;
	alphahash_pars_fragment: string;
	alphamap_fragment: string;
	alphamap_pars_fragment: string;
	alphatest_fragment: string;
	alphatest_pars_fragment: string;
	aomap_fragment: string;
	aomap_pars_fragment: string;
	batching_pars_vertex: string;
	begin_vertex: string;
	beginnormal_vertex: string;
	bsdfs: string;
	iridescence_fragment: string;
	bumpmap_pars_fragment: string;
	clipping_planes_fragment: string;
	clipping_planes_pars_fragment: string;
	clipping_planes_pars_vertex: string;
	clipping_planes_vertex: string;
	color_fragment: string;
	color_pars_fragment: string;
	color_pars_vertex: string;
	color_vertex: string;
	common: string;
	cube_uv_reflection_fragment: string;
	defaultnormal_vertex: string;
	displacementmap_pars_vertex: string;
	displacementmap_vertex: string;
	emissivemap_fragment: string;
	emissivemap_pars_fragment: string;
	colorspace_fragment: string;
	colorspace_pars_fragment: string;
	envmap_fragment: string;
	envmap_common_pars_fragment: string;
	envmap_pars_fragment: string;
	envmap_pars_vertex: string;
	envmap_physical_pars_fragment: string;
	envmap_vertex: string;
	fog_vertex: string;
	fog_pars_vertex: string;
	fog_fragment: string;
	fog_pars_fragment: string;
	gradientmap_pars_fragment: string;
	lightmap_pars_fragment: string;
	lights_lambert_fragment: string;
	lights_lambert_pars_fragment: string;
	lights_pars_begin: string;
	lights_toon_fragment: string;
	lights_toon_pars_fragment: string;
	lights_phong_fragment: string;
	lights_phong_pars_fragment: string;
	lights_physical_fragment: string;
	lights_physical_pars_fragment: string;
	lights_fragment_begin: string;
	lights_fragment_maps: string;
	lights_fragment_end: string;
	logdepthbuf_fragment: string;
	logdepthbuf_pars_fragment: string;
	logdepthbuf_pars_vertex: string;
	logdepthbuf_vertex: string;
	map_fragment: string;
	map_pars_fragment: string;
	map_particle_fragment: string;
	map_particle_pars_fragment: string;
	metalnessmap_fragment: string;
	metalnessmap_pars_fragment: string;
	morphcolor_vertex: string;
	morphnormal_vertex: string;
	morphtarget_pars_vertex: string;
	morphtarget_vertex: string;
	normal_fragment_begin: string;
	normal_fragment_maps: string;
	normal_pars_fragment: string;
	normal_pars_vertex: string;
	normal_vertex: string;
	normalmap_pars_fragment: string;
	clearcoat_normal_fragment_begin: string;
	clearcoat_normal_fragment_maps: string;
	clearcoat_pars_fragment: string;
	iridescence_pars_fragment: string;
	opaque_fragment: string;
	packing: string;
	premultiplied_alpha_fragment: string;
	project_vertex: string;
	dithering_fragment: string;
	dithering_pars_fragment: string;
	roughnessmap_fragment: string;
	roughnessmap_pars_fragment: string;
	shadowmap_pars_fragment: string;
	shadowmap_pars_vertex: string;
	shadowmap_vertex: string;
	shadowmask_pars_fragment: string;
	skinbase_vertex: string;
	skinning_pars_vertex: string;
	skinning_vertex: string;
	skinnormal_vertex: string;
	specularmap_fragment: string;
	specularmap_pars_fragment: string;
	tonemapping_fragment: string;
	tonemapping_pars_fragment: string;
	transmission_fragment: string;
	transmission_pars_fragment: string;
	uv_pars_fragment: string;
	uv_pars_vertex: string;
	uv_vertex: string;
	worldpos_vertex: string;
	background_vert: string;
	background_frag: string;
	backgroundCube_vert: string;
	backgroundCube_frag: string;
	cube_vert: string;
	cube_frag: string;
	depth_vert: string;
	depth_frag: string;
	distanceRGBA_vert: string;
	distanceRGBA_frag: string;
	equirect_vert: string;
	equirect_frag: string;
	linedashed_vert: string;
	linedashed_frag: string;
	meshbasic_vert: string;
	meshbasic_frag: string;
	meshlambert_vert: string;
	meshlambert_frag: string;
	meshmatcap_vert: string;
	meshmatcap_frag: string;
	meshnormal_vert: string;
	meshnormal_frag: string;
	meshphong_vert: string;
	meshphong_frag: string;
	meshphysical_vert: string;
	meshphysical_frag: string;
	meshtoon_vert: string;
	meshtoon_frag: string;
	points_vert: string;
	points_frag: string;
	shadow_vert: string;
	shadow_frag: string;
	sprite_vert: string;
	sprite_frag: string;
};
export interface ShaderLibShader {
	uniforms: {
		[uniform: string]: IUniform;
	};
	vertexShader: string;
	fragmentShader: string;
}
declare const ShaderLib: {
	[name: string]: ShaderLibShader;
	basic: ShaderLibShader;
	lambert: ShaderLibShader;
	phong: ShaderLibShader;
	standard: ShaderLibShader;
	matcap: ShaderLibShader;
	points: ShaderLibShader;
	dashed: ShaderLibShader;
	depth: ShaderLibShader;
	normal: ShaderLibShader;
	sprite: ShaderLibShader;
	background: ShaderLibShader;
	cube: ShaderLibShader;
	equirect: ShaderLibShader;
	distance: ShaderLibShader;
	shadow: ShaderLibShader;
	physical: ShaderLibShader;
};
declare function cloneUniforms<T extends {
	[uniform: string]: IUniform;
}>(uniformsSrc: T): T;
declare function mergeUniforms(uniforms: Array<{
	[uniform: string]: IUniform;
}>): {
	[uniform: string]: IUniform;
};
declare const UniformsUtils: {
	clone: typeof cloneUniforms;
	merge: typeof mergeUniforms;
};
declare class WebGLBufferRenderer {
	constructor(gl: WebGLRenderingContext, extensions: WebGLExtensions, info: WebGLInfo);
	setMode: (value: any) => void;
	render: (start: any, count: number) => void;
	renderInstances: (start: any, count: number, primcount: number) => void;
	renderMultiDraw: (starts: Int32Array, counts: Int32Array, drawCount: number) => void;
	renderMultiDrawInstances: (starts: Int32Array, counts: Int32Array, drawCount: number, primcount: Int32Array) => void;
}
declare class WebGLCubeUVMaps {
	constructor(renderer: WebGLRenderer);
	get<T>(texture: T): T extends Texture ? Texture : T;
	dispose(): void;
}
declare class WebGLGeometries {
	constructor(gl: WebGLRenderingContext, attributes: WebGLAttributes, info: WebGLInfo);
	get(object: Object3D, geometry: BufferGeometry): BufferGeometry;
	update(geometry: BufferGeometry): void;
	getWireframeAttribute(geometry: BufferGeometry): BufferAttribute;
}
declare class WebGLIndexedBufferRenderer {
	constructor(gl: WebGLRenderingContext, extensions: any, info: any);
	setMode: (value: any) => void;
	setIndex: (index: any) => void;
	render: (start: any, count: number) => void;
	renderInstances: (start: any, count: number, primcount: number) => void;
	renderMultiDraw: (starts: Int32Array, counts: Int32Array, drawCount: number) => void;
	renderMultiDrawInstances: (starts: Int32Array, counts: Int32Array, drawCount: number, primcount: Int32Array) => void;
}
declare function WebGLShader$1(gl: WebGLRenderingContext, type: string, string: string): WebGLShader;
declare class WebXRDepthSensing {
	texture: ExternalTexture | null;
	mesh: Mesh | null;
	depthNear: number;
	depthFar: number;
	constructor();
	init(depthData: XRWebGLDepthInformation, renderState: XRRenderState): void;
	getMesh(cameraXR: WebXRArrayCamera): Mesh | null;
	reset(): void;
	getDepthTexture(): ExternalTexture | null;
}
declare class LineSegmentsGeometry extends InstancedBufferGeometry {
	/**
	 * Read-only flag to check if a given object is of type LineSegmentsGeometry.
	 */
	readonly isLineSegmentsGeometry: true;
	/**
	 * Creates a new geometry. Call [setPositions]{@link LineSegmentsGeometry.setPositions} to add segments.
	 */
	constructor();
	/**
	 * Replace the vertex positions with a new set. The array can be an `Array` or `Float32Array`. The length must be a
	 * multiple of six.
	 * @param array
	 */
	setPositions(array: number[] | Float32Array): this;
	/**
	 * Replace the per-vertex colors. Every sixtuple describes a segment: `[r1, g1, b1, r2, g2, b2]`. The array can be
	 * an `Array` or `Float32Array`.
	 * @param array
	 */
	setColors(array: number[] | Float32Array): this;
	/**
	 * Copy the vertex positions of a wireframe geometry into this geometry.
	 */
	fromWireframeGeometry(geometry: WireframeGeometry): this;
	/**
	 * Copy the vertex positions of an edge geometry into this geometry.
	 */
	fromEdgesGeometry(geometry: EdgesGeometry): this;
	/**
	 * Copy the vertex positions of a mesh object into this geometry.
	 */
	fromMesh(mesh: Mesh): this;
	/**
	 * Copy the vertex positions of a {@link LineSegments} object into this geometry. Assumes the source geometry is not
	 * using indices.
	 */
	fromLineSegments(lineSegments: LineSegments): this;
}
declare class LineGeometry extends LineSegmentsGeometry {
	/**
	 * Read-only flag to check if a given object is of type LineGeometry.
	 */
	readonly isLineGeometry: true;
	/**
	 * Creates a new geometry.
	 * Call [setPositions]{@link LineGeometry.setPositions} to add segments.
	 */
	constructor();
	/**
	 * Copy the vertex positions of a {@link Line} object into this geometry.
	 * Assumes the source geometry is not using indices.
	 */
	fromLine(line: Line): this;
}
export interface LineMaterialParameters extends ShaderMaterialParameters {
	alphaToCoverage?: boolean | undefined;
	color?: ColorRepresentation | undefined;
	dashed?: boolean | undefined;
	dashScale?: number | undefined;
	dashSize?: number | undefined;
	dashOffset?: number | undefined;
	gapSize?: number | undefined;
	resolution?: Vector2 | undefined;
	worldUnits?: boolean | undefined;
}
declare class LineMaterial extends ShaderMaterial {
	readonly isLineMaterial: true;
	/**
	 * @param parameters (optional) an object with one or more properties defining the material's appearance. Any
	 * property of the material (including any property inherited from {@link ShaderMaterial}) can be passed in here.
	 *
	 * The exception is the property color, which can be passed in as a number or hexadecimal string and is `0xffffff`
	 * (white) by default. Color.set( color ) is called internally.
	 */
	constructor(parameters?: LineMaterialParameters);
	/**
	 * {@link Color} of the material, by default set to white (0xffffff).
	 */
	get color(): Color;
	set color(value: Color);
	/**
	 * Whether the material's sizes (width, dash gaps) are in world units. Default is `false` (screen space units.)
	 */
	get worldUnits(): boolean;
	set worldUnits(value: boolean);
	/**
	 * Whether the line is dashed, or solid. Default is `false`.
	 */
	get dashed(): boolean;
	set dashed(value: boolean);
	/**
	 * The scale of the dashes and gaps. Default is `1`.
	 */
	get dashScale(): number;
	set dashScale(value: number);
	/**
	 * The size of the dash. Default is `1`.
	 */
	get dashSize(): number;
	set dashSize(value: number);
	/**
	 * Where in the dash cycle the dash starts. Default is `0`.
	 */
	get dashOffset(): number;
	set dashOffset(value: number);
	/**
	 * The size of the gap. Default is `1`.
	 */
	get gapSize(): number;
	set gapSize(value: number);
	/**
	 * The size of the viewport, in screen pixels. This must be kept updated to make screen-space rendering accurate.
	 * The {@link LineSegments2.onBeforeRender} callback performs the update for visible objects. Default is `[1, 1]`.
	 */
	get resolution(): Vector2;
	set resolution(value: Vector2);
}
declare class LineSegments2 extends Mesh {
	geometry: LineSegmentsGeometry;
	material: LineMaterial;
	/**
	 * Read-only flag to check if a given object is of type LineSegments2.
	 */
	readonly isLineSegments2: true;
	resolution: Vector2;
	/**
	 * @param geometry (optional) Pair(s) of vertices representing each line segment.
	 * @param material (optional) Material for the line. Default is a {@link LineMaterial} with random color.
	 */
	constructor(geometry?: LineSegmentsGeometry, material?: LineMaterial);
	computeLineDistances(): this;
	/**
	 * Called by the framework to update the material's resolution property, needed for screen-scaled widths.
	 *
	 * If your object is not visible to a camera (e.g. by [layers]{@link Object3D.layers} or
	 * [visible]{@link Object3D.visible}), you must call this manually whenever the viewport changes.
	 * @param renderer
	 */
	onBeforeRender(renderer: WebGLRenderer): void;
}
declare class Line2 extends LineSegments2 {
	geometry: LineGeometry;
	material: LineMaterial;
	/**
	 * Read-only flag to check if a given object is of type Line2.
	 */
	readonly isLine2: true;
	/**
	 * @param geometry (optional) Pair(s) of vertices representing each line segment
	 * @param material (optional) Material for the line. Default is a {@link LineMaterial} with random color.
	 */
	constructor(geometry?: LineGeometry, material?: LineMaterial);
}
type Text$1 = THREE.Mesh<THREE.ShapeGeometry, THREE.MeshBasicMaterial | THREE.MeshStandardMaterial>;
type Sphere$1 = THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial | THREE.MeshStandardMaterial>;
export type Cone = THREE.Mesh<THREE.ConeGeometry, THREE.MeshBasicMaterial | THREE.MeshStandardMaterial>;
declare class Arrow extends Object3D {
	/**
	 * The line part of the arrow.
	 */
	line: Line2;
	/**
	 * The cone part of the arrow.
	 */
	cone: Cone;
	constructor(pos: Vec3, dir: Vec3, line: Line2, cone: Cone);
}
/** Returns a new THREE.Vector2 instance. */
export declare const vec2: (x: number, y: number) => Vector2;
/** Returns a new THREE.Vector3 instance. */
export declare const vec3: (x: number, y: number, z: number) => Vector3;
/** Returns a new THREE.Vector4 instance. */
export declare const vec4: (x: number, y: number, z: number, w: number) => Vector4;
export type Vec2 = number | [
	number,
	number
] | Vector2;
export type Vec3 = [
	number,
	number,
	number
] | Vector3 | Vec2;
export type Vec4 = [
	number,
	number,
	number,
	number
] | Vector4 | Vec3;
/** Common direction vectors. */
export declare const DIR: {
	readonly Y: Vector3;
	readonly NEG_Y: Vector3;
	readonly X: Vector3;
	readonly NEG_X: Vector3;
	readonly Z: Vector3;
	readonly NEG_Z: Vector3;
};
declare class Points$1 {
	/**
	 * The inner THREE.Points object.
	 */
	innerPoints: THREE.Points<THREE.BufferGeometry<THREE.NormalBufferAttributes, THREE.BufferGeometryEventMap>, THREE.PointsMaterial, THREE.Object3DEventMap>;
	constructor(points: Vec3[], size: number, color: THREE.Color);
	/**
	 * Gets the number of points in the point cloud.
	 * @returns Number of points.
	 */
	get count(): number;
	/**
	 * Gets the position of a specific point.
	 * @param index Index of the point to get the position for.
	 * @returns Position of the specified point.
	 */
	getPosition(index: number): THREE.Vector3;
	/**
	 * Sets the position of a specific point.
	 * @param index Index of the point to set the position for.
	 * @param position New position for the point.
	 */
	setPosition(index: number, position: Vec3): void;
	/**
	 * Gets the color of a specific point.
	 * @param index Index of the point to get the color for.
	 * @returns Color of the specified point.
	 */
	getColor(index: number): THREE.Color;
	/**
	 * Sets the color of a specific point.
	 * @param index Index of the point to set the color for.
	 * @param color New color for the point.
	 */
	setColor(index: number, color: THREE.ColorRepresentation, alpha?: number): void;
	/**
	 * Gets the alpha of a specific point.
	 * @param index Index of the point to get the alpha for.
	 * @returns Alpha of the specified point.
	 */
	getAlpha(index: number): number;
	/**
	 * Sets the alpha of a specific point.
	 * @param index Index of the point to set the alpha for.
	 * @param alpha New alpha for the point.
	 */
	setAlpha(index: number, alpha: number): void;
}
declare class Slider {
	/** The container that contains the label and the input slider */
	container: HTMLDivElement;
	/** The input slider element */
	slider: HTMLInputElement;
	/** The div that contains the label and value label */
	labelContainer: HTMLDivElement;
	/** The label element for the slider */
	label: HTMLLabelElement | null;
	/** The span element that displays the current value of the slider */
	valueLabel: HTMLSpanElement | null;
	constructor(container: HTMLDivElement, slider: HTMLInputElement, labelContainer: HTMLDivElement, label: HTMLLabelElement | null, valueLabel: HTMLSpanElement | null);
	/** Returns the current value of the slider as a number */
	value: () => number;
	/** Sets the value of the slider */
	setValue: (value: number) => void;
}
declare class Checkbox {
	/** The container that contains the label and the input checkbox */
	container: HTMLDivElement;
	/** The input checkbox element */
	checkbox: HTMLInputElement;
	/** The label element for the checkbox */
	label: HTMLLabelElement | null;
	constructor(container: HTMLDivElement, checkbox: HTMLInputElement, label: HTMLLabelElement | null);
	/** Returns whether the checkbox is checked */
	value: () => boolean;
	/** Sets the checked state of the checkbox */
	setValue: (value: boolean) => void;
}
export type UpdateFn = (dt: number, elapsed: number) => void;
export type LineConfig<Extra extends object = {}> = {
	color?: THREE.ColorRepresentation;
	dashSize?: number;
	gapSize?: number;
	lineWidth?: number;
} & ({
	colorStart: THREE.ColorRepresentation;
	colorEnd: THREE.ColorRepresentation;
} | {}) & Extra;
export type LineStyle<Extra extends object = {}> = null | undefined | "dashed" | THREE.ColorRepresentation | LineConfig<Extra>;
export type ArrowLineStyle = LineStyle<{
	headLength?: number | "auto";
}>;
export declare class Ctx {
	/**
	 * The active camera used for rendering the scene. Modify or override it to change the view.
	 *
	 * Defaults to an orthographic camera positioned at (-1, 1, 1) looking at the origin.
	 * ### Example
	 * ```js
	 * ctx.camera.position.set(10, 10, 10);
	 * ctx.camera.lookAt(0, 0, 0);
	 *
	 * ctx.camera = new THREE.PerspectiveCamera(75, 16 / 9, 0.1, 1000);
	 * ```
	 */
	camera: THREE.OrthographicCamera;
	/**
	 * A reference to the THREE.js Scene instance.
	 */
	private readonly sceneRef;
	/**
	 * A reference to the wrapper div containing the renderer's DOM element.
	 */
	private readonly wrapperRef;
	/**
	 * The current rendering mode.
	 *   - `RETAINED`: Objects added to the scene will remain until removed manually.
	 *   - `IMMEDIATE`: Objects added to the scene will be removed at the beginning of the next frame unless re-added
	 *     in the next update call.
	 */
	private mode;
	/**
	 * An array of objects to be removed at the beginning of the next frame. This is only used in IMMEDIATE mode.
	 */
	private garbage;
	/**
	 * An array of registered update functions that will be called on each animation frame. See the {@link update}
	 * method for more details.
	 */
	private readonly updateFns;
	/**
	 * The current theme of the context. This can be used to adjust colors and styles based on light or dark mode.
	 */
	private theme;
	/**
	 * The font used for rendering text. Loaded on demand.
	 */
	private font;
	/**
	 * Global hemisphere light added to the scene for basic illumination.
	 */
	private globalLight;
	/**
	 * Orbit controls for the camera. Initialized when orbit() is first called.
	 */
	private orbitControls;
	constructor(scene: THREE.Scene, wrapper: HTMLDivElement);
	/**
	 * Sets the current theme of the renderer, affecting colors used in the rendering context. This also sets the
	 * background to match the theme.
	 * @param theme The theme to set.
	 */
	setTheme: (theme: Theme) => void;
	/**
	 * Sets global light intensity
	 * @param intensity Light intensity. Default is 3.
	 * @returns The hemisphere light instance.
	 */
	light: (intensity?: number) => THREE.HemisphereLight;
	/**
	 * Sets the background color of the canvas.
	 * ### Example
	 * ```js
	 * ctx.background("#ff0000");
	 * ctx.background("red");
	 * ctx.background(0xff0000);
	 * ```
	 * @param color A Three.js color representation. E.g. "#ff0000", "red", 0xff0000, etc.
	 */
	background: (color: THREE.ColorRepresentation) => void;
	/**
	 * Configures orbit controls for the camera.
	 * ### Example
	 * ```js
	 * ctx.orbit(); // Default orbit controls
	 * ctx.orbit({ target: [0, 0, 0], autoRotate: 1.0 }); // Orbit around the origin with auto-rotation speed of 1.0
	 * ```
	 * @param config (Optional) Configuration options for the orbit controls.
	 */
	orbit: (config?: {
		/** The target position for the orbit controls to look at */
		target?: Vec3;
		/** The auto-rotate speed. If defined, enables auto-rotation */
		autoRotate?: number;
		/** Whether to enable rotation. Default is true. */
		enabledRotate?: boolean;
		/** Whether to enable panning. Default is true. */
		enablePan?: boolean;
		/** Whether to enable zooming. Default is true. */
		enableZoom?: boolean;
	}) => void;
	/**
	 * Registers an update function that will be called on animation iteration. Multiple update functions can be
	 * registered at the same time. They will be called in the order they were registered.
	 *
	 * Spawning new objects inside an update function is done in "immediate mode", meaning that the object will be
	 * removed at the beginning of the next frame, unless it is re-added in the next update call.
	 *
	 * ### Performance
	 * Prefer to use retained objects and only modify their properties inside update functions for better performance.
	 *
	 * ### Example
	 * ```js
	 * ctx.update((dt, elapsed) => {
	 *     // Moves a sphere along the X axis over time.
	 *     const position = vec3(elapsed * 20, 0, 0);
	 *     const radius = 5;
	 *     ctx.sphere(position, radius);
	 * });
	 * ```
	 * @param fn Update function, receiving delta time `dt` and `elapsed` in seconds.
	 */
	update: (fn: UpdateFn) => number;
	/**
	 * A collection of commonly used colors based on the current theme.
	 */
	get COLOR(): {
		readonly FOREGROUND: THREE.Color;
		readonly MUTED: THREE.Color;
		readonly SECONDARY: THREE.Color;
		readonly BACKGROUND: THREE.Color;
		gray(factor: number): THREE.Color;
	};
	/**
	 * Creates and adds 3D text to the scene.
	 * ### Example
	 * ```js
	 * ctx.text("Hello, World!", 24);
	 * ```
	 * @param value The text string to be rendered.
	 * @param size The size of the text. If null, defaults to 16.
	 * @param color (Optional) Object color. See {@link ObjectColor} for details.
	 * @param direction (Optional) The direction of the text. Can be "ltr" (left-to-right), "rtl" (right-to-left), or "tb" (top-to-bottom).
	 * @returns The created THREE.Mesh instance representing the text. For convenience, this is typed as {@link Text}.
	 */
	text: (value: string, size?: number | null, color?: ObjectColor, direction?: "ltr" | "rtl" | "tb") => Text$1;
	/**
	 * A billboarding version of {@link text}, which always faces the camera.
	 * ### Example
	 * ```js
	 * ctx.textBillboard("Hello, World!", 24);
	 * ```
	 * @param value The text string to be rendered.
	 * @param size The size of the text. If null, defaults to 16.
	 * @param color (Optional) Object color. See {@link ObjectColor} for details.
	 * @param direction (Optional) The direction of the text. Can be "ltr" (left-to-right), "rtl" (right-to-left), or "tb" (top-to-bottom).
	 * @returns The created THREE.Mesh instance representing the billboarding text. For convenience, this is typed as {@link Text}.
	 */
	textBillboard: (value: string, size?: number | null, color?: ObjectColor, direction?: "ltr" | "rtl" | "tb") => Text$1;
	/**
	 * Creates a button element and adds it to the renderer's DOM wrapper.
	 * ### Example
	 * ```js
	 * let count = 0;
	 * const button = ctx.button("Increase", () => {
	 *     count++;
	 * });
	 *
	 * ctx.update(() => {
	 *     ctx.text(`Count: ${count}`);
	 * });
	 * ```
	 * @param label The text label of the button.
	 * @param onClick The callback function to be executed when the button is clicked.
	 * @returns The created HTMLButtonElement.
	 */
	button: (label: string, onClick: () => void) => HTMLButtonElement;
	/**
	 * Creates a slider element and adds it to the renderer's DOM wrapper.
	 * ### Example
	 * ```js
	 * const radiusSlider = ctx.slider("Radius", 1, 100);
	 *
	 * ctx.update(() => {
	 *    const radius = radiusSlider.value();
	 *    ctx.sphere([0, 0, 0], radius);
	 * });
	 *
	 * // Slider with custom step size and initial value
	 * ctx.slider("Opacity", 0, 1, 0.25, { step: 0.01 });
	 * ```
	 * @param label The text label of the slider. If null or empty, no label is created.
	 * @param min The minimum value of the slider.
	 * @param max The maximum value of the slider.
	 * @param initial The initial value of the slider. If null, defaults to the midpoint between min and max.
	 * @param config Configuration options for the slider, such as step size and whether to show the current value.
	 * @returns A Slider object containing references to the created DOM elements and methods to get/set the slider value.
	 */
	slider: (label: string | null, min: number, max: number, initial?: number | null, config?: {
		step?: number;
		showValue?: boolean;
	}) => Slider;
	/**
	 * Creates a text element (span) and adds it to the renderer's DOM wrapper.
	 * ### Example
	 * ```js
	 * ctx.textElement("Hello, World!", 24, "red");
	 * ```
	 * @param value The text content of the element.
	 * @param size The font size of the text element in pixels. Defaults to 16 if not provided.
	 * @param color The color of the text. Defaults to the context's foreground color if not provided.
	 */
	textElement: (value: string, size?: number | null, color?: THREE.ColorRepresentation) => void;
	/**
	 * Creates a checkbox element and adds it to the renderer's DOM wrapper.
	 * ### Example
	 * ```js
	 * const checkbox = ctx.checkbox("Enable Feature");
	 *
	 * ctx.update(() => {
	 *    if (checkbox.value()) {
	 *       // Feature is enabled
	 *    }
	 * });
	 *
	 * // Usage with callback:
	 * ctx.checkbox("Show Grid", true, (isChecked) => {
	 *    console.log("Checkbox is now:", isChecked);
	 * });
	 * ```
	 * @param label The text label of the checkbox.
	 * @param initial The initial checked state of the checkbox. Defaults to false.
	 * @param onToggle The callback function to be executed when the checkbox state changes.
	 * @returns A Checkbox object containing references to the created DOM elements and methods to get/set the checkbox state.
	 */
	checkbox: (label: string | null, initial?: boolean, onToggle?: (isChecked: boolean) => void) => Checkbox;
	/**
	 * Creates and adds a line to the scene.
	 * ### Example
	 * ```js
	 * ctx.line([0, 0, 0], [10, 10, 10]); // Uses default foreground color
	 * ctx.line(vec3(0, 0, 0), vec3(10, 0, 0), "dashed");
	 * ctx.line([0, 0, 0], [0, 10, 0], { color: "red", dashSize: 5, gapSize: 2 });
	 * ```
	 * @param start A vector representing the start point of the line.
	 * @param end A vector representing the end point of the line.
	 * @param style (Optional) The style of the line. Can be "dashed", a color representation, or an object specifying color, dashSize, gapSize or linewidth. Defaults to the context's foreground color.
	 * @returns The created THREE.Line instance. For convenience, this is typed as {@link Line}.
	 */
	line: (start: Vec3, end: Vec3, style?: LineStyle) => Line2;
	/**
	 * Creates and adds a line strip to the scene.
	 * ### Example
	 * ```js
	 * ctx.lineStrip([[0, 0, 0], [10, 0, 0], [10, 10, 0]]); // Uses default foreground color
	 * ctx.lineStrip([[0, 0, 0], [10, 0, 0], [10, 10, 0]], "dashed");
	 * ctx.lineStrip([[0, 0, 0], [10, 0, 0], [10, 10, 0]], { color: "blue", dashSize: 3, gapSize: 1 });
	 * ```
	 * @param points An array of vectors representing the points of the line strip.
	 * @param style (Optional) The style of the line. Can be "dashed", a color representation, or an object specifying color, dashSize, gapSize or linewidth. Defaults to the context's foreground color.
	 * @param colors (Optional) An array of color representations for each vertex in the line strip. When provided, this overrides the color specified in the style parameter.
	 * @returns The created THREE.Line instance. For convenience, this is typed as {@link Line}.
	 */
	lineStrip: (points: Vec3[], style?: LineStyle, colors?: THREE.ColorRepresentation[]) => Line2;
	/**
	 * Creates and adds an arrow to the scene.
	 * ### Example
	 * ```js
	 * ctx.arrow([0, 0, 0], [10, 10, 10]); // Uses default foreground color
	 * ctx.arrow([0, 0, 0], [10, 0, 0], "red");
	 * ```
	 * @param start The start point of the arrow.
	 * @param end The end point of the arrow.
	 * @param style (Optional) The style of the line. Can be "dashed", a color representation, or an object specifying color, dashSize, gapSize or linewidth. Defaults to the context's foreground color.
	 * @returns The created THREE.ArrowHelper instance.
	 */
	arrow: <Style extends LineStyle>(start: Vec3, end: Vec3, style?: ArrowLineStyle) => Arrow;
	/**
	 * Creates an arrow starting from the origin (0, 0, 0) to the given vector.
	 * ### Example
	 * ```js
	 * ctx.vector([10, 10, 10]); // Uses default foreground color
	 * ctx.vector(vec3(10, 0, 0), "blue");
	 * ```
	 * @param vec The vector to be drawn.
	 * @param style (Optional) The style of the line. Can be "dashed", a color representation, or an object specifying color, dashSize, gapSize or linewidth. Defaults to the context's foreground color.
	 * @returns The created THREE.ArrowHelper instance.
	 */
	vector: (vec: Vec3, style?: ArrowLineStyle) => Arrow;
	/**
	 * Creates and adds a cuboid (rectangular box) to the scene.
	 * ### Example
	 * ```js
	 * ctx.cuboid([0, 0, 0], [10, 5, 3]);
	 * ctx.cuboid(vec3(5, 5, 5), vec3(2, 4, 6), "green");
	 * ```
	 * @param position A vector representing the position of the cuboid's center.
	 * @param size A vector representing the width, height and depth of the cuboid.
	 * @param color (Optional) Object color. See {@link ObjectColor} for details.
	 * @returns The created THREE.Mesh instance representing the cuboid.
	 */
	cuboid: (position: Vec3, size: Vec3, color?: ObjectColor) => THREE.Mesh<THREE.BoxGeometry, THREE.MeshStandardMaterial | THREE.MeshBasicMaterial, THREE.Object3DEventMap>;
	/**
	 * Creates and adds a circle to the scene.
	 * ### Example
	 * ```js
	 * ctx.circle([0, 0, 0], 5);
	 * ctx.circle(vec3(10, 10, 0), 8, "blue");
	 * ```
	 * @param position A vector representing the position of the circle's center.
	 * @param radius The radius of the circle.
	 * @param color (Optional) Object color. See {@link ObjectColor} for details.
	 * @returns The created THREE.Mesh instance representing the circle.
	 */
	circle: (position: Vec3, radius: number, color?: ObjectColor) => THREE.Mesh<THREE.CircleGeometry, THREE.MeshStandardMaterial | THREE.MeshBasicMaterial, THREE.Object3DEventMap>;
	/**
	 * Creates and adds a cylinder to the scene.
	 * ### Example
	 * ```js
	 * ctx.cylinder([0, 0, 0], 5, 5, 10);
	 * ctx.cylinder(vec3(10, 10, 0), 4, 6, 12, "green");
	 * ```
	 * @param position A vector representing the position of the cylinder's center.
	 * @param radiusTop The radius of the cylinder at the top.
	 * @param radiusBottom The radius of the cylinder at the bottom.
	 * @param height The height of the cylinder.
	 * @param color (Optional) Object color. See {@link ObjectColor} for details.
	 * @returns The created THREE.Mesh instance representing the cylinder.
	 */
	cylinder: (position: Vec3, radiusTop: number, radiusBottom: number, height: number, color?: ObjectColor) => THREE.Mesh<THREE.CylinderGeometry, THREE.MeshStandardMaterial | THREE.MeshBasicMaterial, THREE.Object3DEventMap>;
	/**
	 * Creates and adds a plane to the scene.
	 * ### Example
	 * ```js
	 * ctx.plane([0, 0, 0], [10, 5]);
	 * ctx.plane(vec3(10, 10, 0), vec2(8, 4), "gray");
	 * ```
	 * @param position A vector representing the position of the plane's center.
	 * @param size A vector representing the width and height of the plane.
	 * @param color (Optional) Object color. See {@link ObjectColor} for details.
	 * @returns The created THREE.Mesh instance representing the plane.
	 */
	plane: (position: Vec3, size: Vec2, color?: ObjectColor) => THREE.Mesh<THREE.PlaneGeometry, THREE.MeshStandardMaterial | THREE.MeshBasicMaterial, THREE.Object3DEventMap>;
	/**
	 * Creates and adds a torus to the scene.
	 * ### Example
	 * ```js
	 * ctx.torus([0, 0, 0], 10, 3);
	 * ctx.torus(vec3(5, 5, 5), 8, 2, "purple");
	 * ```
	 * @param position A vector representing the position of the torus's center.
	 * @param radius The radius from the center of the torus to the center of the tube.
	 * @param tubeRadius The radius of the tube.
	 * @param color (Optional) Object color. See {@link ObjectColor} for details.
	 * @returns The created THREE.Mesh instance representing the torus.
	 */
	torus: (position: Vec3, radius: number, tubeRadius: number, color?: ObjectColor) => THREE.Mesh<THREE.TorusGeometry, THREE.MeshStandardMaterial | THREE.MeshBasicMaterial, THREE.Object3DEventMap>;
	/**
	 * Creates and adds a sphere to the scene.
	 * ### Example
	 * ```js
	 * ctx.sphere([0, 0, 0], 3); // Uses default foreground color
	 * ctx.sphere(vec3(0, 0, 0), 5, "red");
	 * ```
	 * @param position A vector representing the position of the sphere.
	 * @param radius The radius of the sphere.
	 * @param color (Optional) Object color. See {@link ObjectColor} for details.
	 * @returns The created THREE.Mesh instance representing the sphere. For convenience, this is typed as {@link Sphere}.
	 */
	sphere: (position: Vec3, radius: number, color?: ObjectColor) => Sphere$1;
	/**
	 * Creates and adds a cone to the scene.
	 * ### Example
	 * ```js
	 * ctx.cone(10, 5); // Uses default foreground color
	 * ctx.cone(15, 7, "green");
	 * ```
	 * @param height Height of the cone from base to tip
	 * @param radius Radius of the cone base
	 * @param color (Optional) Object color. See {@link ObjectColor} for details.
	 * @returns The created THREE.Mesh instance representing the cone. For convenience, this is typed as {@link Cone}.
	 */
	cone: (position: Vec3, height: number, radius: number, color?: ObjectColor) => Cone;
	/**
	 * Creates and adds a graph of a mathematical function to the scene.
	 * ### Example
	 * ```js
	 * // Graph a sine wave from -10 to 10
	 * ctx.graph(x => Math.sin(x), "dashed", [-10, 10]);
	 * // Graph a quadratic function over the default range
	 * ctx.graph(x => x * x, { color: "blue", dashSize: 5, gapSize: 2 });
	 * ```
	 * @param func The mathematical function to graph. Usually a function of x returning y. In addition, the function can return a tuple of [y, color] to specify per-point colors. When colors are specified, they override the style parameter colors.
	 * @param style (Optional) The style of the line. Can be "dashed", a color representation, or an object specifying color, dashSize, gapSize or linewidth. Defaults to the context's foreground color.
	 * @param range (Optional) The range [from, to] over which to graph the function.
	 * @returns The created THREE.Line instance representing the graph. For convenience, this is typed as {@link Line}.
	 */
	graph: (func: (x: number) => number | [
		number,
		THREE.ColorRepresentation
	], style?: LineStyle, range?: [
		number,
		number
	]) => Line2;
	/**
	 * Creates and adds a grid helper to the scene.
	 * ### Example
	 * ```js
	 * ctx.grid(); // Default grid
	 * ctx.grid(500, 25); // Grid of size 500 with 25 unit spacing
	 * ctx.grid(400, 20, "gray", [0, 0, 1]); // Grid with normal along Z axis
	 * ```
	 * @param size The size of the grid.
	 * @param spacing The spacing between grid lines. Defaults to 50 units.
	 * @param color The color of the grid lines. Defaults to the context's secondary color.
	 * @param normal The normal vector defining the orientation of the grid. Defaults to (0, 1, 0).
	 * @returns The created THREE.GridHelper instance.
	 */
	grid: (size?: number | null, spacing?: number | null, color?: THREE.ColorRepresentation | null, normal?: Vec3) => THREE.GridHelper;
	/**
	 * An efficient way to render large point clouds.
	 * ### Example
	 * ```js
	 * const pts = new Array(1000).fill(vec3(0, 0, 0));
	 * const points = ctx.points(pts, 3, "red");
	 *
	 * const point = points.getPosition(0); // Get position of first point
	 * points.setPosition(0, vec3(10, 10, 10)); // Move first point
	 *
	 * console.log(`Point count: ${points.count}`);
	 *
	 * const color = points.getColor(0); // Get color of first point
	 * points.setColor(0, "blue");
	 * ```
	 * @param points Array of point positions.
	 * @param size Size of the points. Defaults to 2. All points are squares facing the camera.
	 * @param color Color of the points. Defaults to the context's foreground color.
	 * @returns Points helper object.
	 */
	points: (points: Vec3[], size?: number | null, color?: THREE.ColorRepresentation) => Points$1;
	/**
	 * Spawns a Three.js object into the scene. In IMMEDIATE mode, the object will be removed at the beginning of the
	 * next frame unless re-added in the next update call. See {@link mode} for more details.
	 * @param object A Three.js object
	 */
	spawn: (object: THREE.Object3D) => void;
	/**
	 * Removes a Three.js object from the scene.
	 * @param object A Three.js object
	 */
	remove: (object: THREE.Object3D) => void;
	/**
	 * Advances the update functions by one tick. This is called internally by the Renderer on each animation frame.
	 * When a tick occurs, the context enters "immediate mode". See {@link mode} for more details.
	 * @internal Do not call this method directly. The Renderer handles this internally.
	 */
	__tick(dt: number, elapsed: number): void;
	/**
	 * @internal Checks if there are any registered update functions.
	 */
	__hasUpdateFns: () => boolean;
	/**
	 * @internal Updates camera bounds given width and height of the renderer.
	 */
	__setCameraBounds: (width: number, height: number) => void;
	/**
	 * Returns the absolute value of the near or far plane, whichever is larger. Used for setting range limits for
	 * graphs and similar objects. (Not and ideal solution, but works for now.)
	 */
	private getCameraExtent;
	/**
	 * Cleans up objects marked for removal in IMMEDIATE mode.
	 */
	private clearGarbage;
}
export declare class Renderer {
	/** The inner THREE.js WebGLRenderer instance. This is only created once per Renderer instance. */
	private readonly inner;
	/** The wrapper div containing the renderer's DOM element. */
	private readonly wrapper;
	/** The ResizeObserver to handle resizing of the renderer. */
	private readonly resizeObserver;
	constructor(setup: (ctx: Ctx) => void);
	/**
	 * Returns the DOM element used by the inner THREE.js WebGLRenderer. Add this to your document to display the
	 * rendered content. The element tries to fill the size of its parent element.
	 * ### Example
	 * ```js
	 * const renderer = new Renderer(..);
	 * document.body.appendChild(renderer.element());
	 * ```
	 */
	element: () => HTMLDivElement;
	/**
	 * Disposes of the renderer and its resources. After calling this method, the renderer should not be used
	 * anymore. Also removes the renderer's DOM element from the document if it was added.
	 */
	dispose(): void;
}

declare namespace THREE {
	export { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AnimationAction, AnimationActionLoopStyles, AnimationBlendMode, AnimationClip, AnimationClipJSON, AnimationLoader, AnimationMixer, AnimationMixerEventMap, AnimationMixerStats, AnimationObjectGroup, AnimationUtils, AnyMapping, AnyPixelFormat, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, AttributeGPUType, Audio$1 as Audio, AudioAnalyser, AudioContext$1 as AudioContext, AudioListener$1 as AudioListener, AudioLoader, AxesHelper, BackSide, BaseEvent, BasicDepthPacking, BasicShadowMap, BatchedMesh, BatchedMeshGeometryRange, BindMode, Blending, BlendingDstFactor, BlendingEquation, BlendingSrcFactor, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, Box3JSON, BoxGeometry, BoxHelper, BufferAttribute, BufferAttributeJSON, BufferGeometry, BufferGeometryEventMap, BufferGeometryJSON, BufferGeometryLoader, ByteType, Cache$1 as Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, ColorRepresentation, ColorSpace, ColorSpaceDefinition, ColorSpaceTransfer, Combine, CompressedArrayTexture, CompressedArrayTextureImageData, CompressedCubeTexture, CompressedPixelFormat, CompressedTexture, CompressedTextureImageData, CompressedTextureLoader, CompressedTextureMipmap, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CoordinateSystem, CubeCamera, CubeCameraRenderer, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeTextureMapping, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFace, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurveJSON, CurvePath, CurvePathJSON, CurveType, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, Data3DTextureImageData, DataArrayTexture, DataArrayTextureImageData, DataTexture, DataTextureImageData, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthModes, DepthPackingStrategies, DepthStencilFormat, DepthTexture, DepthTextureImageData, DepthTexturePixelFormat, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DirectionalLightJSON, DirectionalLightShadow, DiscreteInterpolant, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, Effect, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EulerOrder, EulerTuple, Event$1 as Event, EventDispatcher, EventListener$1 as EventListener, ExternalTexture, ExtrudeGeometry, ExtrudeGeometryOptions, Face, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, Fog, FogExp2, FogExp2JSON, FogJSON, FramebufferTexture, FramebufferTextureImageData, FrontSide, Frustum, FrustumArray, GLBufferAttribute, GLSL1, GLSL3, GLSLVersion, GeometryGroup, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HSL, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightJSON, IUniform, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, InstancedMeshEventMap, InstancedMeshJSON, InstancedMeshJSONObject, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InterpolationEndingModes, InterpolationModes, InterpolationSamplingMode, InterpolationSamplingType, Intersection, InvertStencilOp, JSONMeta, KeepStencilOp, KeyframeTrack, KeyframeTrackJSON, LOD, LODJSON, LODJSONObject, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightEventMap, LightJSON, LightProbe, LightProbeJSON, LightShadow, LightShadowJSON, Line, Line3, LineBasicMaterial, LineBasicMaterialParameters, LineBasicMaterialProperties, LineCurve, LineCurve3, LineDashedMaterial, LineDashedMaterialParameters, LineDashedMaterialProperties, LineLoop, LineSegments, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, MagnificationTextureFilter, MapColorPropertiesToColorRepresentations, Mapping, Material, MaterialJSON, MaterialLoader, MaterialParameters, MaterialProperties, MathUtils, Matrix2, Matrix2Tuple, Matrix3, Matrix3Tuple, Matrix4, Matrix4Tuple, MaxEquation, Mesh, MeshBasicMaterial, MeshBasicMaterialParameters, MeshBasicMaterialProperties, MeshDepthMaterial, MeshDepthMaterialParameters, MeshDepthMaterialProperties, MeshDistanceMaterial, MeshDistanceMaterialParameters, MeshDistanceMaterialProperties, MeshJSON, MeshJSONObject, MeshLambertMaterial, MeshLambertMaterialParameters, MeshLambertMaterialProperties, MeshMatcapMaterial, MeshMatcapMaterialParameters, MeshMatcapMaterialProperties, MeshNormalMaterial, MeshNormalMaterialParameters, MeshNormalMaterialProperties, MeshPhongMaterial, MeshPhongMaterialParameters, MeshPhongMaterialProperties, MeshPhysicalMaterial, MeshPhysicalMaterialParameters, MeshPhysicalMaterialProperties, MeshStandardMaterial, MeshStandardMaterialParameters, MeshStandardMaterialProperties, MeshToonMaterial, MeshToonMaterialParameters, MeshToonMaterialProperties, MinEquation, MinificationTextureFilter, MirroredRepeatWrapping, MixOperation, MixerControlInterpolant, MorphTarget, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoNormalPacking, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NormalBufferAttributes, NormalGAPacking, NormalMapTypes, NormalOrGLBufferAttributes, NormalPacking, NormalRGPacking, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, Object3DEventMap, Object3DJSON, Object3DJSONObject, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OffscreenCanvas$1 as OffscreenCanvas, OneFactor, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OrthographicCameraJSON, OrthographicCameraJSONObject, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, PMREMGeneratorOptions, ParseTrackNameResults, Path, PathJSON, PerspectiveCamera, PerspectiveCameraJSON, PerspectiveCameraJSONObject, PixelFormat, PixelFormatGPU, Plane, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, PointLightJSON, PointLightShadow, Points, PointsMaterial, PointsMaterialParameters, PointsMaterialProperties, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLike, QuaternionLinearInterpolant, QuaternionTuple, R11_EAC_Format, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RG11_EAC_Format, RGB, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDepthPacking, RGBFormat, RGBIntegerFormat, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGDepthPacking, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RaycasterParameters, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RenderItem, RenderTarget, RenderTarget3D, RenderTargetOptions, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_R11_EAC_Format, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SIGNED_RG11_EAC_Format, SRGBColorSpace, SRGBToLinear, SRGBTransfer, Scene, SceneJSON, SceneJSONObject, SerializedImage, ShaderChunk, ShaderLib, ShaderLibShader, ShaderMaterial, ShaderMaterialJSON, ShaderMaterialParameters, ShaderMaterialProperties, ShaderMaterialUniformJSON, ShadowMapType, ShadowMaterial, ShadowMaterialParameters, ShadowMaterialProperties, Shape, ShapeGeometry, ShapeJSON, ShapePath, ShapeUtils, ShortType, Side, Skeleton, SkeletonHelper, SkeletonJSON, SkinnedMesh, SkinnedMeshJSON, SkinnedMeshJSONObject, Source, SourceJSON, Sphere, SphereGeometry, SphereJSON, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, SpotLightJSON, SpotLightShadow, Sprite, SpriteMaterial, SpriteMaterialParameters, SpriteMaterialProperties, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StencilFunc, StencilOp, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TextureComparisonFunction, TextureDataType, TextureFilter, TextureJSON, TextureLoader, TextureParameters, TextureUtils, Timer, TimestampQuery, ToneMapping, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TrianglesDrawModes, TubeGeometry, TypedArray, TypedArrayConstructor, UVGenerator, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt101111Type, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, Usage, VSMShadowMap, Vector2, Vector2Like, Vector2Tuple, Vector3, Vector3Like, Vector3Tuple, Vector4, Vector4Like, Vector4Tuple, VectorKeyframeTrack, VideoFrameTexture, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLAttributes, WebGLBindingStates, WebGLBufferRenderer, WebGLCapabilities, WebGLCapabilitiesParameters, WebGLClipping, WebGLColorBuffer, WebGLCoordinateSystem, WebGLCubeMaps, WebGLCubeRenderTarget, WebGLCubeUVMaps, WebGLDebug, WebGLDepthBuffer, WebGLExtensions, WebGLGeometries, WebGLIndexedBufferRenderer, WebGLInfo, WebGLLights, WebGLLightsState, WebGLObjects, WebGLProgram$1 as WebGLProgram, WebGLProgramParameters, WebGLProgramParametersWithUniforms, WebGLPrograms, WebGLProperties, WebGLRenderList, WebGLRenderLists, WebGLRenderTarget, WebGLRenderer, WebGLRendererParameters, WebGLShader$1 as WebGLShader, WebGLShadowMap, WebGLState, WebGLStencilBuffer, WebGLTextures, WebGLUniforms, WebGLUtils, WebGPUCoordinateSystem, WebXRArrayCamera, WebXRCamera, WebXRController, WebXRDepthSensing, WebXRManager, WebXRManagerEventMap, WebXRSpaceEventMap, WireframeGeometry, WrapAroundEnding, Wrapping, XRControllerEventType, XRGripSpace, XRHandInputState, XRHandJoints, XRHandSpace, XRJointSpace$1 as XRJointSpace, XRTargetRaySpace, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, createCanvasElement, error, getConsoleFunction, log, setConsoleFunction, warn, warnOnce };
}

export {
	Sphere$1 as Sphere,
	THREE,
	Text$1 as Text,
};

export {};
